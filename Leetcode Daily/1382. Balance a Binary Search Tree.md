# ğŸŒ³ Balance a Binary Search Tree

## ğŸ“œ Problem Statement
You are given the root of a **Binary Search Tree (BST)** that may be unbalanced.  
Your task is to **rebalance the BST** so that the height difference between left and right subtrees of every node is minimized, while preserving BST properties.

Return the **root of the balanced BST**.

---

## ğŸ” Example Input/Output
**Input**
```text
BST:    1
         \
          2
           \
            3
````

**Output**

```text
Balanced BST:
      2
     / \
    1   3
```

---

## ğŸ§  Approach

This solution uses a **two-step strategy**:

### 1ï¸âƒ£ Inorder Traversal

* An inorder traversal of a BST produces a **sorted array**
* Store all node values in ascending order

### 2ï¸âƒ£ Build Balanced BST

* Use the sorted array
* Pick the **middle element as root**
* Recursively build left and right subtrees
  (same approach as *LeetCode 108 â€“ Convert Sorted Array to BST*)

This guarantees a height-balanced BST.

---

## ğŸ’» Code 

```python
class Solution:
  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:
    nums = []

    def inorder(root: TreeNode | None) -> None:
      if not root:
        return
      inorder(root.left)
      nums.append(root.val)
      inorder(root.right)

    inorder(root)

    # Same as 108. Convert Sorted Array to Binary Search Tree
    def build(l: int, r: int) -> TreeNode | None:
      if l > r:
        return None
      m = (l + r) // 2
      return TreeNode(
          nums[m],
          build(l, m - 1),
          build(m + 1, r)
      )

    return build(0, len(nums) - 1)
```

---

## â± Complexity Analysis

* **Time Complexity:** `O(n)`

  * Inorder traversal: `O(n)`
  * BST reconstruction: `O(n)`
* **Space Complexity:** `O(n)`

  * Array to store inorder traversal

---

## ğŸ§ª Edge Cases

* Empty tree â†’ returns `None`
* Already balanced BST â†’ still rebuilt but remains balanced
* Skewed BST (linked-list like) â†’ fully rebalanced

---

