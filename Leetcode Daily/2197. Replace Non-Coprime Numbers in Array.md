# Replace Non-Coprime Numbers in Array

ğŸ“œ **Problem Statement**  
You are given an integer array `nums`. Continuously replace adjacent non-coprime numbers with their least common multiple (LCM) until no such pair exists. Return the resulting array after all possible replacements.

Two numbers are **non-coprime** if their greatest common divisor (GCD) is greater than 1.

ğŸ” **Example Input/Output**  
**Input**  
    nums = [6, 4, 3, 2, 7, 6, 2]

**Output**  
    [12, 7, 6]

**Explanation**  
- 6 and 4 are non-coprime (gcd=2) â†’ replace with lcm(6,4)=12 â†’ [12,3,2,7,6,2]  
- 3 and 2 are coprime â†’ keep.  
- 2 and 7 are coprime â†’ keep.  
- 7 and 6 are coprime â†’ keep.  
- 6 and 2 are non-coprime (gcd=2) â†’ replace with lcm(6,2)=6 â†’ [12,3,2,7,6]  
- Continue until stable â†’ final result [12,7,6].

ğŸ§  **Approach (step-by-step)**  
1. Use a stack to maintain the resulting array.  
2. Iterate through each number in `nums`:  
   - While the stack is not empty and the top of the stack shares a GCD > 1 with the current number, merge them into their LCM.  
   - Pop the stack top, compute new number as `(stack[-1] * num) // gcd(stack[-1], num)`, and continue checking with new stack top.  
3. Push the final number to the stack.  
4. At the end, stack contains the processed array with all adjacent non-coprime merges resolved.

ğŸ’» **Code**
  
    from math import gcd
    from typing import List

    class Solution:
        def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
            stack = []
            for num in nums:
                while stack:
                    g = gcd(stack[-1], num)
                    if g == 1:
                        break
                    # merge into LCM
                    num = (stack.pop() * num) // g
                stack.append(num)
            return stack

â± **Complexity Analysis**  
- Let `n = len(nums)`.  
- Each element is pushed and popped at most once from the stack â†’ O(n) stack operations.  
- GCD computation is O(log(max(nums[i]))).  
- **Time Complexity:** O(n log M), where M = maximum number in `nums`.  
- **Space Complexity:** O(n) for the stack.

ğŸ§ª **Edge Cases**  
- Single element array â†’ return same array.  
- All numbers are pairwise coprime â†’ return original array.  
- All numbers share a common factor â†’ eventually merge into one number.  
- Large values in `nums` â†’ ensure no integer overflow (Python handles big integers).  
- Sequence where merging creates new opportunities for earlier numbers (handled by stack loop).  
