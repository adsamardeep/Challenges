# ğŸ· Maximum Side Length of a Square with Sum â‰¤ Threshold

## ğŸ“œ Problem Statement
Given a 2D matrix of non-negative integers and an integer `threshold`, determine the **largest side length** of a square submatrix whose sum of elements is **less than or equal to the threshold**.  
The square must be fully contained within the matrix.

## ğŸ” Example Input/Output
**Input**
```python
mat = [
    [1, 1, 3, 2, 4, 3, 2],
    [1, 1, 3, 2, 4, 3, 2],
    [1, 1, 3, 2, 4, 3, 2]
]
threshold = 4
````

**Output**

```python
2
```

**Explanation**
A `2 Ã— 2` square with sum `4` exists, but any `3 Ã— 3` square exceeds the threshold.

## ğŸ§  Approach

### Key Idea

Use a **2D prefix sum matrix** to compute the sum of any square submatrix in constant time.

### Steps

1. Build a prefix sum matrix `pref` where `pref[i][j]` stores the sum of the submatrix from `(0,0)` to `(i-1,j-1)`.
2. Iterate over each cell `(i, j)` as the bottom-right corner of a candidate square.
3. Try to extend the square side length incrementally from the current maximum (`max_len + 1`).
4. Use the prefix sums to compute the squareâ€™s sum in `O(1)`.
5. If the sum is within the threshold, update `max_len`.

This greedy expansion works because increasing side length is only attempted when smaller sizes are already valid.

## ğŸ’» Code 

```python
class Solution:
    def maxSideLength(self, mat, threshold):
        m, n = len(mat), len(mat[0])

        # Prefix sum matrix
        pref = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                pref[i][j] = (
                    mat[i - 1][j - 1]
                    + pref[i - 1][j]
                    + pref[i][j - 1]
                    - pref[i - 1][j - 1]
                )

        max_len = 0

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                k = max_len + 1
                if i >= k and j >= k:
                    curr_sum = (
                        pref[i][j]
                        - pref[i - k][j]
                        - pref[i][j - k]
                        + pref[i - k][j - k]
                    )
                    if curr_sum <= threshold:
                        max_len = k

        return max_len
```

## â± Complexity Analysis

* **Time Complexity:** `O(m Ã— n)`
  Each cell is processed once with constant-time sum checks.
* **Space Complexity:** `O(m Ã— n)`
  For the prefix sum matrix.

## ğŸ§ª Edge Cases

* Threshold too small to include even a single cell â†’ return `0`
* Matrix of size `1 Ã— 1`
* All values are `0` â†’ maximum possible square is the minimum dimension
* Non-square matrices

```
```
