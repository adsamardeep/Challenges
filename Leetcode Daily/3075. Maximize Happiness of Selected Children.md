# ğŸ· Maximum happiness sum after choosing k children

## ğŸ“œ Problem Statement
Given a list `happiness` where each value represents a childâ€™s happiness, choose exactly `k` children to maximize the total happiness sum. After choosing a child, the effective happiness of subsequently chosen children decreases by 1 for each prior selection, and no contribution can be negative.

## ğŸ” Example Input/Output
**Input:**
```python
happiness = [5, 3, 7]
k = 2
````

**Output:**

```python
11
```

**Explanation:**

* Sort descending â†’ `[7, 5, 3]`
* Pick 1st: `7 - 0 = 7`
* Pick 2nd: `5 - 1 = 4`
* Total = `7 + 4 = 11`

## ğŸ§  Approach

1. Sort the `happiness` array in descending order so the largest values are considered first.
2. Iterate through the first `k` elements:

   * For the `i`-th picked child, their contribution is `happiness[i] - i`.
   * Clamp this value to `0` using `max(0, ...)` to avoid negative contributions.
3. Accumulate the contributions to compute the final answer.
4. Return the accumulated sum.

This greedy approach works because selecting higher initial happiness earlier minimizes the reduction impact.

## ğŸ’» Code 

```python
from typing import List

class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        ans = 0
        happiness.sort(reverse = True)
        i = 0
        while(i < k):

            ans += max(0, happiness[i] - i)
            i += 1
        
        return ans
```

## â± Complexity Analysis

* Time complexity: **O(n log n)** due to sorting.
* Space complexity: **O(1)** extra space (sorting in place).

## ğŸ§ª Edge Cases

* `k = 0` â†’ returns `0`.
* All happiness values become non-positive after reductions â†’ only positive contributions counted.
* `k` equals length of `happiness` â†’ evaluates all elements safely.
* Single-element list â†’ returns `max(0, happiness[0])`.
* Large `k` with small happiness values â†’ negatives correctly ignored.

```
```
