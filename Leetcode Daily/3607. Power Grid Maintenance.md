# Process Connectivity Queries with Offline Marks (DSU + per-component min-heaps)

ðŸ“œ **Problem Statement**  
You have `c` nodes (numbered `1..c`) and a list of undirected `connections` that form components. You will receive a sequence of `queries` of two types:

- Type `2 x`: mark node `x` as **offline** (unavailable).
- Type `1 x`: query for a node to return:
  - return `x` itself if `x` is currently **online**,
  - otherwise return the smallest-numbered **online** node that belongs to the same DSU component as `x`,
  - if no such online node exists in the component, return `-1`.

Design an algorithm that builds components from `connections` and answers the queries online.

ðŸ” **Example**  
```

c = 5
connections = [[1,2],[2,3],[4,5]]
queries = [[1,1],[2,1],[1,1],[2,2],[1,3],[1,4]]

````
- Query 1 (1,1): node 1 is online â†’ return 1  
- Query 2 (2,1): mark 1 offline  
- Query 3 (1,1): 1 is offline; smallest online in component {1,2,3} is 2 â†’ return 2  
- Query 4 (2,2): mark 2 offline  
- Query 5 (1,3): nodes 1,2 are offline; in component {1,2,3} only 3 is online â†’ return 3  
- Query 6 (1,4): node 4 is online â†’ return 4

ðŸ§  **Approach (step-by-step)**  
1. **Build DSU (union-find)** for nodes `1..c` using the `connections`. Use union-by-size/rank and path compression for near-constant-time `find` and `unite`.  
2. After all unions, compute each nodeâ€™s component representative `r = find(i)` and collect nodes per component in a min-heap (or sorted list). We use `heapq` so we can efficiently pop smallest elements that have been marked offline.  
3. Maintain an `offline` boolean array (size `c+1`) initialized to `False`. When processing queries:
   - For `t == 2` (mark offline): set `offline[x] = True`.
   - For `t == 1` (answer query):
     - If `offline[x]` is `False`, return `x`.
     - Else find the representative `r = find(x)`, get its heap `h = heaps.get(r, [])` and lazily pop any elements from `h` that have already been marked offline (while `h` and `offline[h[0]]: heappop(h)`).
     - If `h` is non-empty after cleanup, `h[0]` is the smallest online node in the component; return it. Otherwise return `-1`.
4. The heaps are maintained per representative and are mutated in-place during query processing (so popping updates the underlying dict).

This design answers queries in near O(log D) per relevant heap operation (D = distinct nodes in a component) and uses O(c) memory.

ðŸ’» **Code (copy-paste ready)**  
```python
from typing import List
import heapq
from collections import defaultdict

class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        # DSU with path compression + union by size
        parent = list(range(c + 1))
        size = [1] * (c + 1)

        def find(x: int) -> int:
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def unite(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]

        # build components
        for u, v in connections:
            unite(u, v)

        # collect nodes per component into heaps (min-heaps)
        heaps = defaultdict(list)
        for i in range(1, c + 1):
            r = find(i)
            heaps[r].append(i)
        for r in list(heaps.keys()):
            heapq.heapify(heaps[r])

        offline = [False] * (c + 1)
        ans = []

        # process queries
        for t, x in queries:
            if t == 2:
                # mark node x offline
                if 1 <= x <= c:
                    offline[x] = True
            else:  # t == 1, query
                if not (1 <= x <= c):
                    ans.append(-1)
                    continue

                if not offline[x]:
                    # x itself is online
                    ans.append(x)
                else:
                    # find smallest online node in x's component (if any)
                    r = find(x)
                    h = heaps.get(r, [])
                    # lazily remove offline nodes from heap top
                    while h and offline[h[0]]:
                        heapq.heappop(h)
                    ans.append(h[0] if h else -1)

        return ans
````

â± **Complexity Analysis**

* Let `n = c` (number of nodes), `m = len(connections)`, and `q = len(queries)`.
* **DSU build:** roughly `O(m Î±(n))`.
* **Heaps build:** O(n) to collect + O(sum D_i) heapify where D_i are component sizes; total heapify cost is `O(n)`.
* **Query processing:** each `t==2` is `O(1)`. Each `t==1` may do a few `heappop` operations overall amortized `O(n log n)` across all queries because each node is popped at most once. Each heap operation is `O(log D)` where `D` is the component size. So amortized complexity ~ `O(q log n)` in worst case.
* **Space:** `O(n)` for DSU arrays, heaps, and offline flags.

ðŸ§ª **Edge cases & notes**

* The code assumes queries reference valid nodes in `1..c`. It defensively returns `-1` for out-of-range queries.
* If `connections` is empty, every node is its own component â€” heaps are single-element heaps, and the logic still works.
* Marking a node offline does not remove it from the heap immediately; lazy popping on queries avoids O(log n) work at offline-time and keeps deletions amortized.
* If many marks are issued and few queries ask the component, popping cost is paid only when needed.
* If you need to support **re-activating** nodes (marking back online), you must also push them back into their component heap â€” that requires keeping track of the component representative at time of reactivation (and possibly re-heapifying/inserting with `heappush`). The current code only supports one-way offline marks.

If you want, I can:

* (A) adapt this to handle node reactivation (online â†’ offline â†’ online),
* (B) provide a variant without external `defaultdict` (explicit dict usage), or
* (C) add small optimizations to reduce `find()` calls (cache representatives for nodes since components are static here). Which would you prefer?

```
```
