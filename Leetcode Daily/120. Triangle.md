# Triangle Minimum Path Sum

üìú **Problem Statement**  
Given a triangle represented as a list of lists `tri`, where `tri[i][j]` is the value at row `i` and column `j` (0-indexed), compute the minimum path sum from the top to the bottom. At each step you may move to adjacent numbers on the row below (from `tri[i][j]` you may move to `tri[i+1][j]` or `tri[i+1][j+1]`). Return the minimum possible total.

üîç **Example Input/Output**  
**Input**
    tri = [
        [2],
        [3,4],
        [6,5,7],
        [4,1,8,3]
    ]

**Output**
    11

**Explanation**
One minimum path is 2 ‚Üí 3 ‚Üí 5 ‚Üí 1, sum = 11.

üß† **Approach (step-by-step)**  
1. Use bottom-up dynamic programming in-place: start from the second-last row and move upward to the top.  
2. For each element `tri[i][j]` replace it with `tri[i][j] + min(tri[i+1][j], tri[i+1][j+1])`. That way each entry becomes the minimum sum from that position to the bottom.  
3. After processing all rows, `tri[0][0]` holds the minimum total from top to bottom.  
4. This modifies the input triangle in-place and uses O(1) extra space (ignoring input storage).

üíª **Code**  

    from typing import List

    class Solution:
        def minimumTotal(self, tri: List[List[int]]) -> int:
            # Start from the second-last row and propagate minimum sums upward
            for i in range(len(tri) - 2, -1, -1):
                for j in range(len(tri[i])):
                    tri[i][j] += min(tri[i + 1][j], tri[i + 1][j + 1])
            return tri[0][0]

‚è± **Complexity Analysis**  
- Let `r` be the number of rows in the triangle. Total number of elements is `N = r(r+1)/2`.  
- **Time:** You visit each element (except the bottom row) once and perform O(1) work: **O(N)** which is also **O(r¬≤)** in terms of rows.  
- **Space:** O(1) extra space (in-place modification). If in-place modification is not allowed, an alternative uses an extra 1D array of length `r` giving O(r) extra space.

üß™ **Edge Cases**  
- Empty triangle (`tri == []`) ‚Äî current code will error; you may want to handle this by returning `0` or raising depending on specification.  
- Single-row triangle ‚Äî returns that single element.  
- Negative values are allowed; algorithm still works.  
- Very large triangle ‚Äî algorithm is O(N) time and uses constant extra space; be mindful of integer overflow in other languages (Python handles big ints).  
- If you must preserve the input, copy bottom row into a separate list and perform DP on that array instead of in-place updates.
