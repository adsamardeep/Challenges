# Avoid Flood in The City (Repairing with Dry Days)

📜 **Problem Statement**  
Given an array `rain` of length `n` where:
- `rain[i] > 0` means on day `i` lake `rain[i]` is filled (it rains on that lake),
- `rain[i] == 0` means day `i` is sunny and you may choose one lake to dry that day.

You must return an array `ans` of length `n` such that:
- `ans[i] == -1` if it rains on day `i`,
- `ans[i] == x > 0` if day `i` is sunny and you choose to dry lake `x` that day,
and you must avoid ever having a lake fill twice without being dried in-between. If it's impossible, return `[]`.

🔍 **Example**  
Input:
    rain = [1,2,0,1,2]
One valid output:
    [-1,-1,2,-1,-1]
Explanation: dry lake 2 on day 2 (index 2) before it rains again on day 4.

🧠 **Approach (step-by-step, using a Union-Find "next available day" structure)**  
- We want, for any time we see a rain on lake `L` that was previously filled on day `prev`, to find a sunny day strictly after `prev` and strictly before the current day `i` to dry lake `L`.  
- Maintain a dictionary `last_filled[lake] = day_index` for the last day that lake was filled and not yet dried.  
- Maintain a structure that can quickly return the **first unused sunny day `d >= x`** (or report none). After using a sunny day `d`, it becomes unavailable for future drying. This is exactly the problem of maintaining the "next available index" — we implement it with a Union-Find (disjoint set) where `find(i)` gives the smallest unused day ≥ `i`. When a day `d` is used, we `unite(d)` to point it to `find(d+1)`.  
- Iterate days `i` from `0..n-1`:
  - If `rain[i] == 0` it's a sunny day — initially we leave `ans[i] = 1` (any arbitrary valid drying value). It remains available until (and unless) we actually assign it to dry a lake; when used we mark it via `unite(day)`.
  - If `rain[i] == L > 0`: set `ans[i] = -1` (rain). If `L` was previously filled at day `prev = last_filled[L]`, we must find `dry = find(prev + 1)`. If `dry >= i` or `dry == n` (no available day before `i`), impossible → return `[]`. Otherwise set `ans[dry] = L` and mark `dry` used with `unite(dry)`. Finally update `last_filled[L] = i`. If `L` was not previously filled, simply record `last_filled[L] = i` and continue.
- To prevent using rainy days as drying days, when we see a rain at day `i` we should mark day `i` as unavailable immediately by `unite(i)`.

This yields an O(n α(n)) algorithm (α is inverse-Ackermann, effectively constant).

💻 **Code**  

    from typing import List

    class UnionFind:
        def __init__(self, n: int):
            # parent[i] = next candidate index >= i that is still unused
            # we keep parent array of length n+1 so find(n) == n acts as sentinel "no day"
            self.parent = list(range(n + 1))

        def find(self, i: int) -> int:
            # path compression
            if self.parent[i] != i:
                self.parent[i] = self.find(self.parent[i])
            return self.parent[i]

        def unite(self, i: int) -> None:
            # mark index i as used by linking it to find(i+1)
            self.parent[i] = self.find(i + 1)

    class Solution:
        def avoidFlood(self, rain: List[int]) -> List[int]:
            n = len(rain)
            uf = UnionFind(n)          # supports indices 0..n, where n is sentinel (no day)
            last_filled = {}           # lake -> last day it was filled and not yet dried
            ans = [1] * n              # default drying value for sunny days is 1 (will be replaced if used)

            for i, lake in enumerate(rain):
                if lake == 0:
                    # sunny day: keep ans[i] = 1 as placeholder; actual lake to dry may be assigned later
                    continue
                # raining day: cannot be used as a dry day => mark it unavailable
                ans[i] = -1
                uf.unite(i)

                if lake in last_filled:
                    prev_day = last_filled[lake]
                    # find first available sunny day after prev_day
                    dry_day = uf.find(prev_day + 1)
                    # if no such day or the earliest available day is >= current rain day, impossible
                    if dry_day >= i or dry_day == n:
                        return []
                    # assign that dry day to dry this lake, and mark dry_day used
                    ans[dry_day] = lake
                    uf.unite(dry_day)
                # record this rain as the last filled day for this lake
                last_filled[lake] = i

            return ans

⏱ **Complexity Analysis**  
- Let `n = len(rain)`.  
- Each day is `find`/`unite`d at most a constant number of times. Union-Find operations are amortized almost O(1).  
- **Time:** O(n α(n)) ≈ O(n).  
- **Space:** O(n) for `parent` array and O(k) for `last_filled` where `k` is #distinct lakes (≤ n).

🧪 **Edge Cases**  
- No sunny days (all `rain[i] > 0`) — if any lake appears twice, impossible. Algorithm returns `[]`.  
- Many sunny days — extra sunny days that are never assigned remain `1` in the output (that's valid).  
- Lakes with immediate re-rain on next day (no sunny day in between) → impossible (detected because `find(prev+1) >= i`).  
- Input constraints where `n` is small/large — algorithm scales linearly.

