# Maximum `k` for Two Non-overlapping Increasing Subarrays

ğŸ“œ **Problem Statement**  
Given an integer array `nums`, find the maximum integer `k` such that there exist **two non-overlapping** strictly increasing contiguous subarrays of length `k`. Subarrays may be adjacent (the end of the first can be immediately before the start of the second) but must not overlap.

ğŸ” **Example Input / Output**  
**Input**
    nums = [1,2,3,4,5]
**Output**
    2
**Explanation**
You can take [1,2] and [3,4] (or many other choices). The maximum `k` for which two non-overlapping increasing subarrays of length `k` exist is 2 (because a single strictly increasing run of length 5 can be split into two length-2 runs, but not two length-3 runs that don't overlap).

**Input**
    nums = [1,2,1,2,1]
**Output**
    1
**Explanation**
There are multiple increasing subarrays of length 1 (any single element), but you cannot get two non-overlapping increasing subarrays both of length 2.

ğŸ§  **Approach (step-by-step)**  
1. Scan the array once leftâ†’right and keep track of the length `up` of the current strictly increasing run (counts elements). When `nums[i] > nums[i-1]` increment `up`, otherwise set `preUp = up` and reset `up = 1`.  
2. At each step consider two ways to obtain two non-overlapping increasing subarrays ending around the current break/position:
   - A **single long run** (current `up`) may be splittable into two adjacent length-`k` runs. A run of length `L` can be split into two non-overlapping subarrays of length `k` if `k <= L // 2`. So this possibility contributes `up // 2`.
   - Two **consecutive runs** (previous run length `preUp` and current run length `up`) can form two non-overlapping subarrays if both runs have length â‰¥ `k`. That gives `min(preUp, up)`.  
3. The best candidate `k` available at the current point is `max(up // 2, min(preUp, up))`. Track the global maximum of that candidate throughout the pass.  
4. Return the tracked maximum `res` at the end. This is an O(n) single-pass solution using O(1) extra space.

ğŸ’» **Code**  

    from typing import List

    class Solution:
        def maxIncreasingSubarrays(self, nums: list[int]) -> int:
            n = len(nums)
            if n == 0:
                return 0

            up, preUp, res = 1, 0, 0
            for i in range(1, n):
                if nums[i] > nums[i - 1]:
                    up += 1
                else:
                    preUp = up
                    up = 1

                # possibility 1: split a single long run into two -> up // 2
                half = up >> 1
                # possibility 2: use previous and current runs -> min(preUp, up)
                m = min(preUp, up)
                candidate = max(half, m)
                if candidate > res:
                    res = candidate
            return res

â± **Complexity Analysis**  
- **Time:** O(n) â€” single pass through the array.  
- **Space:** O(1) extra space (only a few integer variables).

ğŸ§ª **Edge Cases**  
- Empty array â†’ returns `0`.  
- Very short arrays: if `len(nums) < 2` the function returns `0` (no two non-overlapping subarrays possible).  
- Strictly increasing array of length `L`: result = `L // 2` (best split into two adjacent blocks).  
- Multiple separate increasing runs: function handles both adjacent-run and single-run-split cases by taking the maximum candidate during the scan.  
- Adjacent runs separated by a single non-increasing element are considered via `preUp` and `up` (they can still form two subarrays if both lengths â‰¥ k).  
