# ðŸ·  Maximum profit with strategy-based gains and a fixed modification window

## ðŸ“œ Problem Statement
Given a list of stock `prices`, a corresponding `strategy` array (with values like `-1`, `0`, or `1` indicating how each day contributes to profit), and an even integer `k`, compute the maximum achievable profit. You are allowed to apply a special modification over any contiguous window of length `k`, where the first `k/2` days are removed from strategy influence and replaced by raw price gains from the latter half of the window.

## ðŸ” Example Input/Output
**Input:**
```python
prices = [3, 2, 5, 1, 6]
strategy = [1, -1, 1, 0, 1]
k = 4
````

**Output:**

```python
11
```

**Explanation:**

* Base profit is computed using `strategy[i] * prices[i]`.
* By choosing an optimal window of length `k`, part of the strategy impact is replaced by direct price additions, yielding a higher total profit.

## ðŸ§  Approach

1. Let `k2 = k // 2`. The modification window contributes the sum of prices from its second half.
2. Compute a prefix sum `Sum` over `strategy[i] * prices[i]` to quickly get base profit over any range.
3. Initialize `modify` as the sum of prices in the interval `[k2, k)`.
4. Compute the initial profit assuming the modification window starts at index `0`.
5. Slide the window across the array:

   * Update `modify` by adding the new entering price and removing the exiting one.
   * For each position, compute total profit as:

     ```
     modify + (base profit outside the window)
     ```

     which is efficiently obtained using the prefix sums.
6. Track and return the maximum profit encountered.

## ðŸ’» Code 

```python
from typing import List
from itertools import accumulate

class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        n, k2 = len(prices), k // 2
        Sum = list(accumulate((strategy[i] * prices[i] for i in range(n)), initial=0))
        modify = sum(prices[k2:k])
        profit = max(Sum[n], modify + Sum[n] - Sum[k])

        for i in range(1, n + 1 - k):
            modify += prices[i + k - 1] - prices[i + k2 - 1]
            profit = max(profit, modify + Sum[n] - Sum[i + k] + Sum[i])
        return profit
```

## â± Complexity Analysis

* Time complexity: **O(n)** â€” prefix sum computation and a single sliding-window pass.
* Space complexity: **O(n)** â€” for the prefix sum array.

## ðŸ§ª Edge Cases

* `k = 0`: no modification window; result equals base strategy profit.
* `k > n`: modification window cannot be applied; base profit is returned.
* All strategy values are zero: profit comes only from the modification window.
* Negative prices or negative strategy values: handled naturally via arithmetic.
* `k` not even: behavior depends on problem guarantees (code assumes `k` is even).
