# ðŸ· Separate Squares (Horizontal Cut with Equal Area)

## ðŸ“œ Problem Statement
You are given a list of axis-aligned squares on a 2D plane.  
Each square is represented as `[x, y, l]`, where:
- `(x, y)` is the bottom-left corner
- `l` is the side length of the square

Find the **y-coordinate of a horizontal line** such that the total area of square parts **below the line** is equal to the total area **above the line**.

Return the y-coordinate as a floating-point number.  
Answers within `1e-5` precision are acceptable.

## ðŸ” Example Input/Output
**Input:**
```python
squares = [[0,0,2],[1,1,2]]
````

**Output (one possible):**

```python
1.5
```

*(Exact value depends on square placement)*

## ðŸ§  Approach

This is a **binary search on the y-axis** problem.

### Key Observations:

* The area below a horizontal line `y = mid` is **monotonic** as `mid` increases.
* We can binary search for the `y` where:

  ```
  area_below(mid) = total_area / 2
  ```

### Steps:

1. Compute the **total area** of all squares.
2. Set binary search bounds:

   * `low` = minimum bottom y of all squares
   * `high` = maximum top y of all squares
3. For a given `mid`, compute how much area lies **below** it:

   * For each square, the contributing height is:

     ```
     clamp(mid - y, 0, l)
     ```
   * Area contribution = `l * height`
4. Adjust binary search based on comparison with `target_area`.
5. Repeat ~60 iterations for sufficient precision.

## ðŸ’» Code 

```python
from typing import List

class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        low, high, total_area = float('inf'), float('-inf'), 0

        for x, y, l in squares:
            total_area += l * l
            low = min(low, y)
            high = max(high, y + l)

        target_area = total_area / 2.0

        for _ in range(60):  # binary search for precision
            mid = (low + high) / 2.0
            curr_area = 0

            for _, y, l in squares:
                height = max(0, min(l, mid - y))
                curr_area += l * height

            if curr_area < target_area:
                low = mid
            else:
                high = mid

        return (low + high) / 2.0
```

## â± Complexity Analysis

* **Time Complexity:** `O(60 Ã— n)` â‰ˆ `O(n)`
* **Space Complexity:** `O(1)`

## ðŸ§ª Edge Cases

* Single square
* All squares stacked vertically
* Squares fully above or below the cut
* Very large coordinate values
* Overlapping squares

```
```
