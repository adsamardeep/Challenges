# ðŸ· Minimum Operations to Make Array Elements Equal to 1 (using GCD subarray)

# ðŸ“œ Problem Statement
Given an integer array `nums`, return the minimum number of operations needed to make every element equal to `1`.  
In one operation you may replace any element with the greatest common divisor (gcd) of that element and one of its neighbors; equivalently, the known optimal strategy is to either use existing `1`s or create a `1` by reducing a subarray whose gcd becomes `1`, then spread that `1` to the rest.

# ðŸ” Example Input/Output
Input:
```

nums = [2, 6, 1, 4]

```
Output:
```

3

```
Explanation: There's already one `1`, so we need `n - ones = 4 - 1 = 3` operations to change the other elements to `1`.

Another example:
Input:
```

nums = [2, 6, 3, 4]

```
Output:
```

4

````
Explanation: No `1`s exist. The shortest subarray with gcd 1 might be `[6,3]` (length 2 â†’ cost `j-i = 1`), so total = `res + n - 1 = 1 + 4 - 1 = 4`.

# ðŸ§  Approach
1. If the array already contains one or more `1`s, each non-1 element can be converted to `1` in one operation, so answer = `n - count(1)`.  
2. If there are no `1`s, search for the shortest subarray whose gcd equals `1`. For every start index `i`, compute the running gcd `g` with subsequent elements `j` until `g == 1` or the array ends. If `g == 1` at `j`, the cost to produce the first `1` from that subarray is `(j - i)`.  
3. If no subarray has gcd `1`, it's impossible â†’ return `-1`.  
4. Otherwise, the total operations = `(shortest_subarray_length - 1) + (n - 1)` which simplifies to `res + n - 1`, because it takes `res` operations to create a `1` inside the array and then `n-1` operations to spread that `1` to all other elements.

# ðŸ’» Code 
```python
from typing import List
from math import gcd
from math import inf

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        # check if there is 1 in `nums`
        ones = nums.count(1)
        # if so, we can make all the other elements equal to 1 with one operation each
        # e.g. [2,6,1,4] -> [2,1,1,4] -> [1,1,1,4] -> [1,1,1,1]
        # the number of operation to make all equal to 1 is simply n - number of 1s
        if ones:
            return n - ones

        res = inf
        # try finding the shortest subarray with a gcd equal to 1.
        for i in range(n):
            # subarray starting from i
            g = nums[i]
            # try each element after i
            for j in range(i + 1, n):
                # to calculate gcd
                g = gcd(g, nums[j])
                # if the gcd is 1
                if g == 1:
                    # then we calculate the min ops (j - i is number of operations to make a 1 in that window)
                    res = min(res, j - i)
                    break  # shortest for this i found, no need to extend j further

        # no result -> return -1
        if res == inf:
            return -1
        # otherwise, return res + n - 1
        # i.e. the min ops to turn the shortest subarray to 1 + 
        #      use that 1 to convert n - 1 elements to 1
        return res + n - 1
````

# â± Complexity Analysis

* **Time:** `O(n^2 * logV)` worst-case, where `n = len(nums)` and `logV` is the cost of gcd on integers (gcd is fast, typically considered O(log value)). In practice we break early when gcd becomes `1`.
* **Space:** `O(1)` extra space (ignoring input).

# ðŸ§ª Edge Cases

* `nums` already contains one or more `1`s â†’ returns `n - ones`.
* All elements share a gcd > 1 (no subarray with gcd 1) â†’ returns `-1`.
* Single-element array:

  * If `nums = [1]` â†’ `0`.
  * If `nums = [x>1]` â†’ impossible to change (no neighbors) so `-1`.
* Large arrays with small values â†’ many short gcds become `1` quickly; early breaks help performance.
* Repeated identical values (e.g., all even numbers) â†’ quickly detected as impossible if gcd never reaches `1`.

```
```
