# Swim In Rising Water

📜 **Problem Statement**  
Given an `n x n` grid `grid` where `grid[i][j]` is the elevation at cell `(i,j)`, you start at `(0,0)` and want to reach `(n-1,n-1)`. At time `t` you can step onto any cell whose elevation is `<= t`. Find the minimum time `t` such that there exists a path from start to target moving 4-directionally (up/down/left/right) only through cells with elevation `<= t`.

🔍 **Example Input/Output**  
**Input**
    grid = [
      [0, 2],
      [1, 3]
    ]
**Output**
    3

**Explanation**
You need to wait until time `t = 3` so you can traverse a path 0 → 1 → 3 (all <= 3). At smaller times no complete path exists.

🧠 **Approach (step-by-step)**  
1. The answer `t` is in range `[min_elev, max_elev]`. A common solution is **binary search on time** `t`: for a candidate time `mid`, check whether there's a path from `(0,0)` to `(n-1,n-1)` visiting only cells with `elevation <= mid`.  
2. To check reachability for a given `t`, use BFS/DFS from `(0,0)` but only step into neighbors whose `grid` value ≤ `t`. If `(0,0)` itself exceeds `t` then it's impossible for that `t`.  
3. Binary-search the minimum `t` for which reachability holds. This yields `O(log R)` reachability checks where `R` is elevation range (or `n*n` distinct values), and each check costs `O(n^2)` worst-case.  
4. Implementation note: prefer iterative BFS (using `collections.deque`) to avoid recursion depth issues on large `n`.

💻 **Code**  

    from typing import List
    from collections import deque

    class Solution:
        def swimInWater(self, grid: List[List[int]]) -> int:
            n = len(grid)
            if n == 0:
                return 0

            # 4-directional moves
            dirs = [(0,1),(0,-1),(1,0),(-1,0)]

            def can_reach(t: int) -> bool:
                # If start is not available at time t, can't start
                if grid[0][0] > t:
                    return False
                visited = [[False]*n for _ in range(n)]
                dq = deque()
                dq.append((0,0))
                visited[0][0] = True
                while dq:
                    x, y = dq.popleft()
                    if x == n-1 and y == n-1:
                        return True
                    for dx, dy in dirs:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] <= t:
                            visited[nx][ny] = True
                            dq.append((nx, ny))
                return False

            # Binary search on time
            low, high = max(grid[0][0], 0), max(max(row) for row in grid)
            ans = high
            while low <= high:
                mid = (low + high) // 2
                if can_reach(mid):
                    ans = mid
                    high = mid - 1
                else:
                    low = mid + 1
            return ans

⏱ **Complexity Analysis**  
- Let `n` be grid side length.  
- Each reachability check (BFS) is `O(n^2)` in time and `O(n^2)` space for visited.  
- Binary search does `O(log R)` checks where `R = max_elevation - min_elevation + 1` (or you can view it as `O(log(max(grid)))`).  
- **Overall time:** `O(n^2 * log R)`.  
- **Space:** `O(n^2)` for visited and queue.

🧪 **Edge Cases**  
- Single cell (`n = 1`): return `grid[0][0]`.  
- Start cell higher than many candidate `t` values — handled by the immediate check in `can_reach`.  
- Very large `n` — iterative BFS avoids recursion limits.  
- If elevations have a small set of distinct values, you can also binary-search over the sorted unique elevations (reducing `log R`), or use a Dijkstra-like approach (min-heap) that finds the minimum maximum elevation along a path in `O(n^2 log n)` without binary search. Both are common alternatives.  

