# Count Valid Selections (Prefix-Sum Based)

üìú **Problem Statement**  
You are given an integer list `nums`. A **valid selection** is defined based on the following conditions:  
- For every index `i` where `nums[i] == 0`, you can choose it as a ‚Äúsplit point.‚Äù  
- Define:
  - `left_sum = sum(nums[0:i])` (sum of elements to the left)
  - `right_sum = sum(nums[i+1:])` (sum of elements to the right)
- The selection at index `i` is considered **valid** if:
  1. `left_sum == right_sum` ‚Üí contributes `2` valid selections  
  2. `|left_sum - right_sum| == 1` ‚Üí contributes `1` valid selection  

Return the total count of valid selections across all indices.

üîç **Example Input / Output**  
**Input**  
    nums = [1, 0, 1]  

**Output**  
    2  

**Explanation**  
At index `1` (`nums[1]=0`):  
- Left sum = 1, Right sum = 1 ‚Üí equal ‚Üí +2 valid selections  
Total = 2  

üß† **Approach (step-by-step)**  
1. Compute **prefix sums** (`left[i]`) and **suffix sums** (`right[i]`):
   - `left[i]` = sum of all elements before `i`  
   - `right[i]` = sum of all elements after `i`  
2. Iterate over all indices `i`:  
   - Skip if `nums[i] != 0` (only check zeros).  
   - Compare `left[i]` and `right[i]`:
     - If equal ‚Üí add 2 to result.  
     - If absolute difference = 1 ‚Üí add 1.  
3. Return total count.

üíª **Code**  

    from typing import List

    class Solution:
        def countValidSelections(self, nums: List[int]) -> int:
            n = len(nums)
            res = 0
            left = [0] * n
            right = [0] * n

            # Compute prefix (left) and suffix (right) sums
            for i in range(1, n):
                left[i] = left[i - 1] + nums[i - 1]
                right[n - i - 1] = right[n - i] + nums[n - i]

            # Check valid split conditions
            for i in range(n):
                if nums[i] != 0:
                    continue
                if left[i] == right[i]:
                    res += 2
                elif abs(left[i] - right[i]) == 1:
                    res += 1

            return res

‚è± **Complexity Analysis**  
- **Time:** O(n) (single pass for prefix/suffix sums and validation)  
- **Space:** O(n) for `left` and `right` arrays (can be reduced to O(1) if computed dynamically).

üß™ **Edge Cases**  
- All non-zero numbers ‚Üí returns 0.  
- All zeros ‚Üí computed based on prefix/suffix equality per position.  
- Single-element list `[0]` ‚Üí left and right both 0 ‚Üí +2 ‚Üí result = 2.  
- Large arrays handled efficiently (linear complexity).

‚úÖ **Example Walkthrough**
| Index | nums[i] | left[i] | right[i] | Condition | Contribution |
|--------|----------|----------|-----------|-------------|---------------|
| 0 | 1 | 0 | 1 | not zero | 0 |
| 1 | 0 | 1 | 1 | equal | +2 |
| 2 | 1 | - | - | not zero | 0 |

‚úÖ **Final Answer:** 2
