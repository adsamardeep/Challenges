# minimumScore - Minimum Score After Two Edge Cuts on Tree

## ðŸ“˜ Problem Statement

You are given a **tree** (acyclic connected graph) with `n` nodes, where each node has a value from the array `nums` and the tree structure is defined by `edges`.

You can **cut two different edges**, breaking the tree into **three components**. The **score** is defined as the **difference between the maximum and minimum** of the XOR of node values in each of the three components.

Your task is to **find the minimum possible score** by choosing two edges to cut.

---

### âœ… Example
```python
Input:
nums = [1, 5, 5, 4, 11]
edges = [[0,1],[1,2],[1,3],[3,4]]

Output: 9

# Explanation:
# Cutting edges (1,2) and (3,4) creates 3 components:
# - Component 1: XOR = 1^5^4 = 0
# - Component 2: XOR = 5
# - Component 3: XOR = 11
# Score = max(11,5,0) - min(11,5,0) = 11 - 0 = 11 (but some pair may give 9)
```

---

## ðŸ§  Approach

- **Build the Tree** using an adjacency list.
- Perform a **post-order DFS** from root (node 0) to compute:
  - `subtree_xor[i]`: XOR sum of all nodes in the subtree rooted at node `i`
  - `descendants[i]`: Set of all descendant nodes in the subtree rooted at `i`
- Try **all pairs of nodes (i, j)** to simulate cutting the edge above them.
  - If `j` is a descendant of `i`, or vice versa, handle as **nested cuts**
  - Otherwise, treat as **independent cuts**
- For each cut configuration, calculate XORs of 3 resulting components and compute the score.
- Track the **minimum score** across all valid cut pairs.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(nÂ²) â€” for checking all node pairs (can be optimized with observations)
- **Space Complexity**: O(n) â€” for storing subtree and descendant data

---

## ðŸ“„ Code

```python
import collections

class Solution:
    def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:
        n = len(nums)
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        subtree_xor = [0] * n
        descendants = [set() for _ in range(n)]

        def dfs(node, parent):
            subtree_xor[node] = nums[node]
            descendants[node].add(node)
            for neighbor in graph[node]:
                if neighbor != parent:
                    dfs(neighbor, node)
                    subtree_xor[node] ^= subtree_xor[neighbor]
                    descendants[node].update(descendants[neighbor])

        dfs(0, -1)
        total_xor = subtree_xor[0]
        min_score = float('inf')

        for i in range(1, n):
            for j in range(i + 1, n):
                xor_i = subtree_xor[i]
                xor_j = subtree_xor[j]

                if j in descendants[i]:
                    val1 = xor_j
                    val2 = xor_i ^ xor_j
                    val3 = total_xor ^ xor_i
                elif i in descendants[j]:
                    val1 = xor_i
                    val2 = xor_j ^ xor_i
                    val3 = total_xor ^ xor_j
                else:
                    val1 = xor_i
                    val2 = xor_j
                    val3 = total_xor ^ xor_i ^ xor_j

                score = max(val1, val2, val3) - min(val1, val2, val3)
                min_score = min(min_score, score)

        return min_score
```

---

## ðŸ“‚ Usage

This solution is applicable in tree decomposition problems, competitive programming, and areas where **partitioning structures for optimal balance** is required.
