# ğŸ”¤ Minimum Deletions to Make String Balanced

## ğŸ“œ Problem Statement
You are given a string `s` consisting only of characters `'a'` and `'b'`.

A string is considered **balanced** if there is no index `i < j` such that:
- `s[i] == 'b'` and `s[j] == 'a'`

In other words, **all `'a'` characters must appear before any `'b'` characters**.

Return the **minimum number of deletions** required to make the string balanced.

---

## ğŸ” Example Input/Output
**Input**
```text
s = "aababbab"
````

**Output**

```text
2
```

**Explanation**
One optimal way is to delete the `'b'` at index 2 and the `'a'` at index 5, resulting in `"aaabbb"`.

---

## ğŸ§  Approach

This solution uses a **single pass greedy strategy**.

### Key Insight

At every split point in the string:

* All `'b'` characters on the **left** are invalid
* All `'a'` characters on the **right** are invalid

We want to minimize:

```
(# of 'b' on the left) + (# of 'a' on the right)
```

### How it works

1. Count total `'a'` characters (`a`)
2. Traverse the string:

   * When we pass an `'a'`, reduce remaining `'a'` count
   * When we pass a `'b'`, increase left-side `'b'` count
3. At each position, compute deletions = `a + b`
4. Track the minimum

---

## ğŸ’» Code 

```python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        res = len(s)
        a = 0
        b = 0

        for c in s:
            a += (c == 'a')

        for c in s:
            a -= (c == 'a')
            res = min(res, a + b)
            b += (c == 'b')

        return res
```

---

## â± Complexity Analysis

* **Time Complexity:** `O(n)` â€” single pass over the string
* **Space Complexity:** `O(1)` â€” constant extra space

---

## ğŸ§ª Edge Cases

* `"aaaa"` â†’ `0` deletions
* `"bbbb"` â†’ `0` deletions
* `"ba"` â†’ `1` deletion
* Empty string â†’ `0` deletions

---

