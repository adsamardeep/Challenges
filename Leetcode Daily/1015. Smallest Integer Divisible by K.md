# ğŸ· Smallest Repunit Divisible by K

# ğŸ“œ Problem Statement  
A *repunit* is a positive integer consisting only of the digit `1`, such as `1`, `11`, `111`, etc.  
Given an integer `k`, return the length of the smallest repunit that is divisible by `k`.  
If no such repunit exists, return `-1`.

# ğŸ” Example Input/Output  
Input:
```

k = 3

```
Output:
```

3

```
Explanation: The smallest repunit divisible by 3 is `111`, which has length 3.

# ğŸ§  Approach  
1. If `k` is divisible by `2` or `5`, no repunit can be divisible by `k` (repunit numbers end with digit `1`), so return `-1`.  
2. Maintain the remainder `rem` of the current repunit modulo `k`.  
3. Start with `rem = 1 % k` and length `len = 1`.  
4. Repeatedly append a `1` to the current repunit by doing:
```

rem = (rem * 10 + 1) % k

````
5. If at any point `rem == 0`, the repunit is divisible â€” return the current length.  
6. The pigeonhole principle guarantees a repeat of remainders after at most `k` steps; if length exceeds `k`, no solution exists â†’ return `-1`.

# ğŸ’» Code 
```python
class Solution:
 def smallestRepunitDivByK(self, k: int) -> int:
     if k % 2 == 0 or k % 5 == 0: 
         return -1
     rem = 1 % k 
     len = 1
     while rem > 0:
         rem = (rem * 10 + 1) % k
         len += 1
         if len > k:
             return -1
     return len
````

# â± Complexity Analysis

* **Time:** O(k) â€” at most `k` iterations before a remainder repeats
* **Space:** O(1) â€” constant memory usage

# ğŸ§ª Edge Cases

* `k` divisible by 2 or 5 â†’ immediately return `-1`
* `k = 1` â†’ smallest repunit is `1`, return `1`
* Large `k` (up to 10âµ or more) still works within time due to O(k) bound
* Ensures no infinite loop due to the `len > k` safeguard

```
```
