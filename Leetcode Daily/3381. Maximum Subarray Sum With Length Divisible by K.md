# üè∑ Maximum Subarray Sum With Modulo-k Prefix Grouping

# üìú Problem Statement  
Given an integer array `nums` and an integer `k`, find the **maximum subarray sum** such that the subarray‚Äôs length modulo `k` matches a valid prefix-based condition.  
This solution uses prefix sums grouped by index mod `k` to efficiently track the best minimal prefix for each remainder bucket.

# üîç Example Input/Output  
Input:
```

nums = [3, -2, 5, -1], k = 2

```
Output:
```

6

````
Explanation: The max subarray is `[3, -2, 5]` with sum = 6.

# üß† Approach  
1. Maintain cumulative prefix sum `prefSum`.  
2. For each index `i`, we want the best earlier prefix sum with the **same index mod k**:
   - This ensures the subarray `(j+1 ‚Ä¶ i)` satisfies `(i - j) % k == 0`.  
3. Keep `minSoFar[r]`: the minimum prefix sum seen so far in bucket `r = i % k`.  
4. For each index:
   - Compute candidate max subarray sum:  
     ```
     prefSum - minSoFar[i % k]
     ```
   - Update the bucket's minimum prefix sum.  
5. The answer is the maximum of all candidates.

# üíª Code 
```python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        prefSum = 0
        subMax = -sys.maxsize
        minSoFar = [sys.maxsize] * k

        # treat an empty prefix as belonging to bucket (k-1)%k, value = 0
        minSoFar[(k - 1) % k] = 0

        for i, v in enumerate(nums):
            prefSum += v
            subMax = max(subMax, prefSum - minSoFar[i % k])
            minSoFar[i % k] = min(minSoFar[i % k], prefSum)

        return subMax
````

# ‚è± Complexity Analysis

* **Time:** O(n)
* **Space:** O(k)

# üß™ Edge Cases

* Single element array.
* Very large negative numbers ‚Äî handled via `-sys.maxsize`.
* `k = 1` ‚Üí equivalent to classic Kadane using prefix sums.
* All negative numbers ‚Üí returns the maximum element (via prefix logic).

```
```
