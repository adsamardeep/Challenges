# üî§ Longest Balanced Substring (1, 2, or 3 Letters)

## üìú Problem Statement

Given a string `s` consisting only of characters:

```

'a', 'b', 'c'

```

Return the length of the longest substring that is **balanced**.

A substring is balanced if:

- All characters in it appear the same number of times  
  (for 1, 2, or all 3 distinct letters)

---

## üß† Key Insight

If a substring is balanced, then:

- For 1 letter ‚Üí all characters identical
- For 2 letters ‚Üí counts are equal
- For 3 letters ‚Üí counts are equal

We use **prefix count differences** to detect this efficiently in `O(n)` time.

---

# üöÄ Strategy Breakdown

We maintain running counts:

```

A = count of 'a'
B = count of 'b'
C = count of 'c'

```

Balanced conditions translate to:

### ‚úÖ 3-letter balance:
```

A = B = C

```
Equivalent to:
```

(B - A, C - A) same at two indices

```

---

### ‚úÖ 2-letter balance:

For `a & b`:
```

A = B

```
Track:
```

(A - B, C)

```

For `b & c`:
```

B = C

```
Track:
```

(B - C, A)

```

For `c & a`:
```

C = A

```
Track:
```

(C - A, B)

````

---

### ‚úÖ 1-letter balance:
Handled separately by counting consecutive identical characters.

---

# üíª Code 

```python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)

        # 1-letter balance
        ans, length = 1, 1
        for c0, c1 in pairwise(s):
            if c0 == c1:
                length += 1
            else:
                ans = max(ans, length)
                length = 1
        ans = max(ans, length)

        ab, bc, ca, abc = {}, {}, {}, {}

        # base state before string starts
        abc[(0, 0)] = ab[(0, 0)] = bc[(0, 0)] = ca[(0, 0)] = -1

        cnt = [0, 0, 0]

        for i, c in enumerate(s):
            cnt[ord(c) - 97] += 1
            A, B, C = cnt

            # 3-letter balance
            key = (B - A, C - A)
            if key in abc:
                ans = max(ans, i - abc[key])
            else:
                abc[key] = i

            # 2-letter balances
            key = (A - B, C)
            if key in ab:
                ans = max(ans, i - ab[key])
            else:
                ab[key] = i

            key = (B - C, A)
            if key in bc:
                ans = max(ans, i - bc[key])
            else:
                bc[key] = i

            key = (C - A, B)
            if key in ca:
                ans = max(ans, i - ca[key])
            else:
                ca[key] = i

        return ans
````

---

# ‚è± Complexity

* **Time:** `O(n)`
* **Space:** `O(n)` (hashmaps store prefix states)

---

# üîé Example

### Input

```
s = "abcabcbb"
```

### Explanation

For `"abcabc"`:

```
A = 2
B = 2
C = 2
```

Balanced across all 3 letters ‚Üí length = 6

---

# üß† Why This Is Efficient

Instead of checking every substring (`O(n¬≤)`),
we convert equality conditions into **prefix difference invariants**.

If two prefixes share the same difference key:

```
prefix[j] - prefix[i] satisfies balance
```

We get substring length instantly.

---

# üèÜ This Is an Optimal O(n) Solution

It handles:

* 1-letter balance
* 2-letter balance
* 3-letter balance

All in a single pass.

---

