# Trapping Rain Water II (3D / Matrix Version)

📜 **Problem Statement**  
Given an `m x n` height map `height` (non-negative integers), compute how much water can be trapped after raining. Water can be trapped in interior cells bounded by higher boundary cells; water cannot flow outside the matrix. Return the total volume of trapped water.

🔍 **Example Input / Output**  
**Input**
    height = [
      [1,4,3,1,3,2],
      [3,2,1,3,2,4],
      [2,3,3,2,3,1]
    ]

**Output**
    4

**Explanation**  
Water is trapped in some interior low cells; total trapped amount is 4.

🧠 **Approach (step-by-step)**  
1. This is the classical BFS + min-heap approach that starts from the boundary and works inward: treat boundary cells as initial "barriers" and always expand from the lowest barrier inward.  
2. Push all boundary cells into a min-heap keyed by height. Mark them visited. Maintain a global `water_level` equal to the maximum of heights popped so far. When you pop the smallest boundary height `h`, any neighbor cell with height `nh` that is lower than the current `water_level` can hold `water_level - nh` water. After visiting a neighbor, push it into the heap with effective height `max(nh, water_level)` (this represents the new barrier height at that position).  
3. Repeat until the heap is empty. The algorithm ensures water flows from the globally lowest available boundary inward, so trapped amounts are computed correctly.  
4. Use a visited marker (or mutate `height`) to avoid revisiting cells.

💻 **Code**  

    from typing import List
    from heapq import heapify, heappop, heappush

    class Solution:
        def trapRainWater(self, height: List[List[int]]) -> int:
            if not height or not height[0]:
                return 0

            m, n = len(height), len(height[0])
            # Small grids can't trap water
            if m <= 2 or n <= 2:
                return 0

            # Directions for 4-neighbors
            dirs = (0, 1, 0, -1, 0)

            # boundary heap will store tuples (effective_height, i, j)
            boundary = []
            # mark visited by setting a separate visited matrix (safer than sentinel values)
            visited = [[False] * n for _ in range(m)]

            # Push all boundary cells into heap and mark visited
            for i in range(m):
                boundary.append((height[i][0], i, 0))
                visited[i][0] = True
                boundary.append((height[i][n - 1], i, n - 1))
                visited[i][n - 1] = True

            for j in range(1, n - 1):
                boundary.append((height[0][j], 0, j))
                visited[0][j] = True
                boundary.append((height[m - 1][j], m - 1, j))
                visited[m - 1][j] = True

            heapify(boundary)

            ans = 0
            water_level = 0

            # Process cells starting from the lowest boundary
            while boundary:
                h, i, j = heappop(boundary)
                # maintain the current water level (max of popped heights so far)
                if h > water_level:
                    water_level = h

                # explore 4-neighbors
                for k in range(4):
                    ni, nj = i + dirs[k], j + dirs[k + 1]
                    if ni < 0 or ni >= m or nj < 0 or nj >= n or visited[ni][nj]:
                        continue
                    visited[ni][nj] = True
                    nh = height[ni][nj]
                    # If neighbor is lower than current water level, it traps water
                    if nh < water_level:
                        ans += (water_level - nh)
                    # Push neighbor with effective height = max(nh, water_level)
                    # so it acts as a barrier at least as high as water_level
                    heappush(boundary, (max(nh, water_level), ni, nj))

            return ans

⏱ **Complexity Analysis**  
- Let `N = m * n`.  
- Each cell is pushed/popped from the heap at most once. Heap operations cost `O(log N)`.  
- **Time:** `O(N log N)`.  
- **Space:** `O(N)` for the heap and visited matrix.

🧪 **Edge Cases & Notes**  
- Very small grids (`m <= 2` or `n <= 2`) cannot trap water — return `0`.  
- The corrected code pushes neighbors with `max(nh, water_level)` into the heap. This is important: it models the fact that once water level reaches some height, that level becomes the new effective boundary for further inward expansion. Pushing only `nh` (the raw height) may still work if you track `water_level` separately and visit each cell once, but using `max(nh, water_level)` is the standard, robust approach and makes reasoning simpler.  
- We use an explicit `visited` matrix rather than mutating the `height` array to `-1`; this avoids colliding with legitimate height values and keeps the input intact if you need it later.  
- If input heights can be extremely large, Python handles large ints; performance depends on `m*n`.  
- For in-place memory savings you could reuse `height` to mark visited (as your earlier version did), but be careful choosing a sentinel that cannot appear as a valid height.

If you'd like, I can also provide a version that mutates `height` in-place (using a sentinel) or one that uses fewer imported names — or run a quick dry-run on a specific test case you have.
