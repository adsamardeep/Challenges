# Router Packet Buffer with Time-Window Counts

ðŸ“œ **Problem Statement**  
Design a router buffer that stores at most `memoryLimit` unique packets. Each packet is defined by `(source, destination, timestamp)` and is uniquely encoded. The router supports:
- `addPacket(source, destination, timestamp) -> bool`: add a new packet if not duplicate; if buffer full, forward (evict) the oldest packet first. Return `False` for duplicates, `True` when added (after possibly forwarding one).
- `forwardPacket() -> packet`: remove and return the oldest packet (FIFO).
- `getCount(destination, startTime, endTime) -> int`: return how many packets for a destination have timestamps within `[startTime, endTime]`.

The implementation must maintain ability to (1) quickly detect duplicates, (2) keep FIFO eviction order, and (3) query counts per destination in a time range.

ðŸ” **Example Input/Output**  
```
Initialise:
    router = Router(memoryLimit=2)

Sequence:
    router.addPacket(1, 10, 100)   -> True   # stored
    router.addPacket(2, 20, 110)   -> True   # stored
    router.addPacket(1, 10, 100)   -> False  # duplicate
    router.addPacket(3, 10, 120)   -> True   # buffer full -> forward oldest (1,10,100), then store (3,10,120)
    router.getCount(10, 90, 130)   -> 1      # only (3,10,120) remains for dest=10 in range
```

ðŸ§  **Approach (step-by-step / explanation of given design)**  
1. `packets` dictionary maps a unique encoded key -> `[source, destination, timestamp]`. This gives O(1) duplicate detection and O(1) lookup for forwarding/removal.  
2. `queue` (a `deque`) stores keys in arrival/FIFO order so `forwardPacket` can pop the oldest key in O(1).  
3. `counts` is a mapping `destination -> list of timestamps` that keeps timestamps appended in arrival order (so list is non-decreasing if arrivals for that destination are non-decreasing in time). `getCount` uses `bisect_left`/`bisect_right` to count timestamps inside `[startTime, endTime]` in O(log m) where `m` is number of timestamps for that destination.  
4. When adding a packet:
   - Encode key and check `packets` for duplicates.
   - If memory full (len(packets) >= size) call `forwardPacket()` to evict the oldest packet (remove from `packets`, `queue`, and its timestamp from `counts`).
   - Insert the new packet into `packets`, append key to `queue`, append timestamp to `counts[destination]`.
5. `forwardPacket` pops the oldest key from `queue`, removes from `packets`, and removes the earliest timestamp from `counts[destination]` (currently done by `pop(0)`).

ðŸ’» **Code**  

    import bisect
    from collections import defaultdict, deque

    class Router:
        def __init__(self, memoryLimit: int):
            self.size = memoryLimit
            self.packets = {}              # key -> [source, destination, timestamp]
            self.counts = defaultdict(list)  # destination -> sorted list of timestamps (arrival order)
            self.queue = deque()           # FIFO order of keys

        def addPacket(self, source: int, destination: int, timestamp: int) -> bool:
            key = self._encode(source, destination, timestamp)

            # Duplicate check
            if key in self.packets:
                return False

            # If memory full, forward oldest packet
            if len(self.packets) >= self.size:
                self.forwardPacket()

            # Add packet
            self.packets[key] = [source, destination, timestamp]
            self.queue.append(key)
            # Assumes timestamps for the same destination are appended in non-decreasing order.
            self.counts[destination].append(timestamp)

            return True

        def forwardPacket(self):
            if not self.packets:
                return []

            key = self.queue.popleft()
            packet = self.packets.pop(key)

            dest = packet[1]
            # Remove the earliest timestamp for that destination.
            # Current implementation uses pop(0) which is O(m) for list.
            if self.counts[dest]:
                self.counts[dest].pop(0)

            return packet

        def getCount(self, destination: int, startTime: int, endTime: int) -> int:
            timestamps = self.counts.get(destination, [])
            if not timestamps:
                return 0

            # Binary search for inclusive range [startTime, endTime]
            left = bisect.bisect_left(timestamps, startTime)
            right = bisect.bisect_right(timestamps, endTime)

            return right - left

        def _encode(self, source: int, destination: int, timestamp: int) -> int:
            # Encode uniquely into one integer (bit-packing).
            # Assumes timestamp < 2^20 and destination < 2^20; adjust shifts if ranges differ.
            return (source << 40) | (destination << 20) | timestamp

â± **Complexity Analysis**  
- Let `N` be current number of stored packets, `m_d` be number of timestamps for a given destination `d`.  
- `addPacket`: average O(1) for duplicate check and deque append; appending timestamp O(1). However if `forwardPacket` is triggered, see below.  
- `forwardPacket`: `popleft()` and `pop` from `packets` are O(1). But `counts[dest].pop(0)` is O(m_d) because removing from start of a Python list shifts elements â€” worst-case O(N). If many forwards occur, this can be costly.  
- `getCount`: O(log m_d) due to binary search on the timestamp list.  
- **Space:** O(N) for `packets`, O(N) aggregated across all `counts` lists, and O(N) for `queue`.

ðŸ§ª **Edge Cases & Important Notes**  
- **Timestamps not strictly increasing per destination:** The `counts[destination]` list is appended in arrival order. If timestamps for a given destination can arrive out-of-order, the list may not be sorted and `bisect` results will be incorrect. If out-of-order arrivals are possible, you must insert timestamps into the sorted position (O(m) per insert) or maintain a sorted structure.  
- **Costly pop(0):** Removing the earliest timestamp via `pop(0)` is O(m_d). For high-throughput or large counts, this will be a bottleneck. Consider alternatives (see improvements).  
- **Encoding assumptions:** `_encode` packs source/destination/timestamp into one int â€” be sure the chosen bit-widths (20/20 bits here) are sufficient for real ranges; otherwise keys may collide.  
- **Duplicate detection uses full triple:** Two packets with same `(source,destination,timestamp)` are considered duplicates. If duplicates should be allowed, remove that check.  
- **Empty forward:** `forwardPacket` returns `[]` when there is nothing to forward; callers should handle that.  
- **Memory limit zero or negative:** Not handled explicitly â€” `memoryLimit` should be > 0.

ðŸ”§ **Possible Improvements (recommendations)**  
1. **Avoid O(m) removals from front of list**  
   - Replace per-destination `list` with a `deque` (fast popleft) but `bisect` needs random access â€” so you lose binary-search ability.  
   - Use both a `deque` for FIFO removal and a balanced BST / `bisect`-backed structure for range queries (e.g., `sortedcontainers.SortedList`) so both removal and range count are efficient: `SortedList` supports O(log n) add/remove and O(log n) for bisect counts.  
   - Alternatively maintain `counts[destination]` as a deque **plus** an auxiliary `SortedList` or `Counter` keyed by timestamp to support fast range queries.  
2. **Lazy cleanup with heap or index pointers**  
   - Keep timestamps in a `list` and maintain a pointer/index of how many earliest timestamps have been removed (an offset). Instead of `pop(0)`, increment offset; periodically trim the list to reclaim memory. For bisect, you have to account for offset in indices (e.g., bisect on the list slice or use the underlying list with adjusted indices).  
3. **Use `sortedcontainers.SortedList`** (third-party)  
   - `SortedList` gives `bisect_left/right`, `add`, and `discard` in O(log n), making `getCount` O(log n) and removals O(log n) â€” ideal if third-party libs allowed.  
4. **Robust encoding**  
   - Make `_encode` use tuple keys `(source, destination, timestamp)` instead of bit-packing unless extreme memory efficiency is required; tuples are safe and clear and avoid bit-width bugs.


