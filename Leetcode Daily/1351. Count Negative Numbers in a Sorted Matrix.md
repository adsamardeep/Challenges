# ğŸ· Count Negative Numbers in a Sorted Matrix

## ğŸ“œ Problem Statement
You are given a 2D grid `grid` of size `m x n` where:
- Each row is sorted in **non-increasing** order.
- Each column is sorted in **non-increasing** order.

Return the **total number of negative numbers** in the grid.

## ğŸ” Example Input/Output
**Input:**
```python
grid = [
  [4, 3, 2, -1],
  [3, 2, 1, -1],
  [1, 1, -1, -2],
  [-1, -1, -2, -3]
]
````

**Output:**

```python
8
```

## ğŸ§  Approach

1. Start from the **bottom-left corner** of the matrix.
2. Use two pointers:

   * `i` for rows (starting from the last row).
   * `j` for columns (starting from the first column).
3. At each step:

   * If `grid[i][j] < 0`, then **all elements to the right** of `(i, j)` in that row are also negative.

     * Add `n - j` to the result.
     * Move **up** (`i -= 1`).
   * Otherwise, move **right** (`j += 1`).
4. Continue until pointers go out of bounds.

This leverages the sorted property to avoid checking every cell.

## ğŸ’» Code 

```python
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        i = m - 1
        j = 0
        res = 0

        while i >= 0 and j < n:
            if grid[i][j] < 0:
                res += n - j
                i -= 1
            else:
                j += 1

        return res
```

## â± Complexity Analysis

* **Time Complexity:** `O(m + n)`
  Each row and column is visited at most once.
* **Space Complexity:** `O(1)`
  Only constant extra space is used.

## ğŸ§ª Edge Cases

* Grid with **no negative numbers** â†’ returns `0`
* Grid with **all negative numbers** â†’ returns `m * n`
* Single row or single column
* Minimum size grid (`1 x 1`)

```
```
