# ğŸ· Check if an Array is Trionic

## ğŸ“œ Problem Statement
An array is called **Trionic** if it has **three consecutive segments**:
1. A **strictly increasing** segment
2. Followed by a **strictly decreasing** segment
3. Followed by a **strictly increasing** segment

Each segment must be **non-empty**.

Given an integer array `nums`, return `True` if it is trionic, otherwise return `False`.

## ğŸ” Example Input/Output
**Input**
```python
nums = [1, 3, 5, 4, 2, 6, 8]
````

**Output**

```python
True
```

**Explanation**

* Increasing: `1 â†’ 3 â†’ 5`
* Decreasing: `5 â†’ 4 â†’ 2`
* Increasing: `2 â†’ 6 â†’ 8`

---

**Input**

```python
nums = [1, 2, 3, 4]
```

**Output**

```python
False
```

(No decreasing segment)

## ğŸ§  Approach

The solution works by identifying **two turning points**:

* **Peak**: the first index where increasing stops (left â†’ right)
* **Valley**: the first index where increasing stops (right â†’ left)

### Steps

1. Scan from the left to find the first non-increasing position â†’ `peak`
2. Scan from the right to find the first non-decreasing position â†’ `valley`
3. Ensure:

   * `peak < valley`
   * Middle segment is **strictly decreasing**
   * Peak is not at index `0`
   * Valley is not at the last index
4. Validate the decreasing segment using a helper function

This guarantees all **three required segments exist and are strict**.

## ğŸ’» Code 

```python
class Solution:
    def isTrionic(self, nums: List[int]) -> bool:
        n = len(nums)
        peak = n - 1
        valley = 0

        for i in range(n - 1):
            if peak == n - 1 and nums[i] >= nums[i + 1]:
                peak = i
            if valley == 0 and nums[-1 - i] <= nums[-2 - i]:
                valley = n - 1 - i
            if peak < valley:
                return self.isDecreasing(nums, peak, valley)

        return False

    def isDecreasing(self, A: List[int], a: int, b: int) -> bool:
        if a == 0 or b == len(A) - 1:
            return False
        for i in range(a, b):
            if A[i] <= A[i + 1]:
                return False
        return True
```

## â± Complexity Analysis

* **Time Complexity:** `O(n)`

  * Single pass to find peak and valley
  * One pass to verify decreasing segment
* **Space Complexity:** `O(1)`

  * No extra data structures used

## ğŸ§ª Edge Cases

* Array length < 3 â†’ âŒ Not trionic
* Peak at index `0` â†’ âŒ No initial increasing segment
* Valley at last index â†’ âŒ No final increasing segment
* Equal adjacent elements â†’ âŒ Strict monotonicity violated

```
