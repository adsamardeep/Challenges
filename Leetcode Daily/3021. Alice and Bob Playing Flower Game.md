# ğŸŸ© Problem: Flower Game

## ğŸ“œ Problem Statement
Alice and Bob are playing a game with two numbers:

- Alice chooses an integer `x` between `1` and `n`.
- Bob chooses an integer `y` between `1` and `m`.

They both win if the sum `x + y` is **odd**.

Return the total number of winning pairs `(x, y)`.

---

## ğŸ” Example

**Input**
    n = 3, m = 4

**Output**
    6

**Explanation**
- All possible pairs `(x, y)` are from `[1..3] Ã— [1..4]` = 12 pairs.
- Odd-sum pairs: `(1,2), (1,4), (2,1), (2,3), (3,2), (3,4)` â†’ total = **6**.

---

## ğŸ§  Approach
1. A sum `x + y` is odd when **one is even and the other is odd**.
2. Count odds and evens in `[1..n]` and `[1..m]`:
   - `odd_n = (n + 1) // 2`, `even_n = n // 2`
   - `odd_m = (m + 1) // 2`, `even_m = m // 2`
3. The total winning pairs are:
   - `odd_n * even_m + even_n * odd_m`
4. This simplifies to `n * m // 2` (since exactly half of all pairs have odd sum).

---

## ğŸ’» Code Implementation

    # Explicit formula (clear)
    class Solution:
        def flowerGame(self, n: int, m: int) -> int:
            odd_n, even_n = (n + 1) // 2, n // 2
            odd_m, even_m = (m + 1) // 2, m // 2
            return odd_n * even_m + even_n * odd_m

    # Optimized shortcut (works because half of pairs sum to odd)
    class Solution:
        def flowerGame(self, n: int, m: int) -> int:
            return n * m // 2

---

## â± Complexity Analysis
- **Time Complexity:** O(1) â€” constant-time arithmetic.
- **Space Complexity:** O(1) â€” constant extra space.

---

## ğŸ§ª Edge Cases
- `n = 1, m = 1` â†’ only `(1,1)` (sum even) â†’ result = `0`.
- `n = 2, m = 2` â†’ 4 pairs total, 2 with odd sum â†’ result = `2`.
- Large `n, m` â†’ works efficiently due to constant-time formula.
