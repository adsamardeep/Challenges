# üè∑ Maximum stock trading profit with up to k transactions

## üìú Problem Statement
Given a list of daily stock `prices` and an integer `k`, compute the maximum profit achievable using **at most k transactions**. A transaction consists of one buy followed by one sell, and you cannot hold more than one stock at a time.

## üîç Example Input/Output
**Input:**
```python
prices = [3, 2, 6, 5, 0, 3]
k = 2
````

**Output:**

```python
7
```

**Explanation:**

* Buy at price 2, sell at price 6 ‚Üí profit = 4
* Buy at price 0, sell at price 3 ‚Üí profit = 3
* Total profit = 7

## üß† Approach

1. Use dynamic programming with a 2D array `dp` of size `(k+1) √ó 3`, where for each transaction count:

   * `dp[t][0]`: max profit with `t` transactions completed and **no stock held**,
   * `dp[t][1]`: max profit with `t` transactions completed and **holding a stock bought via a buy action**,
   * `dp[t][2]`: max profit with `t` transactions completed and **holding a stock via an alternate mirrored state** (used to unify transitions).
2. Initialize all states using the first day's price.
3. Iterate through each day and update states **backwards** over transaction counts to avoid overwriting needed previous values.
4. For each transaction count:

   * Update the no-stock state by either doing nothing, selling from a buy state, or selling from the alternate state.
   * Update buy/hold states using the profit from one fewer completed transaction.
5. The final answer is the maximum profit with exactly `k` transactions and no stock held.

## üíª Code 

```python
from typing import List

class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        first_price = prices[0]
        dp = [[0, -first_price, first_price] for _ in range(k + 1)]
        n = len(prices)
        
        for day in range(1, n):
            curr_price = prices[day]
            for trans in range(k, 0, -1):
                prev_profit = dp[trans - 1][0]
                dp[trans][0] = max(
                    dp[trans][0],
                    dp[trans][1] + curr_price,
                    dp[trans][2] - curr_price
                )
                dp[trans][1] = max(dp[trans][1], prev_profit - curr_price)
                dp[trans][2] = max(dp[trans][2], prev_profit + curr_price)
        
        return dp[k][0]
```

## ‚è± Complexity Analysis

* Time complexity: **O(n ¬∑ k)**, where `n` is the number of days.
* Space complexity: **O(k)**, since only `k+1` transaction states are maintained.

## üß™ Edge Cases

* `k = 0`: no transactions allowed ‚Üí profit is `0`.
* Prices always decreasing: best action is no trades ‚Üí profit `0`.
* `k` greater than `n // 2`: still handled correctly by DP (though a greedy shortcut could exist).
* Single-day price list: profit is `0`.
* Very large `k`: space remains linear in `k`, time scales accordingly.

```
```
