
# ðŸ· Ones and Zeroes â€” Maximum Formable Strings (2D knapsack via map)

# ðŸ“œ Problem Statement
Given a list of binary strings `strs` and two integers `m` and `n` (limits on how many `'0'` and `'1'` characters you can use), return the maximum number of strings you can form without exceeding the limits. Each string consumes a number of zeros and ones equal to its character counts and can be chosen at most once.

# ðŸ” Example Input/Output
Input:
```

strs = ["10","0001","111001","1","0"]
m = 5
n = 3

```
Output:
```

4

````
(You can form 4 strings such as "10","0001","1","0" within limits.)

# ðŸ§  Approach
1. This is a 0/1 knapsack with two resources (zeros and ones). For each string, compute its `(zeroes, ones)` cost.
2. Use a dictionary `dp` keyed by `(used_zeroes, used_ones)` with value = max strings formed for that usage. Initialize `dp[(0,0)] = 0`.
3. For each string, iterate existing `dp` states and try to form a new state by adding the string's cost. If the new resource usage stays within `(m, n)`, record in a `newdp` the improved count for that state.
4. After considering the string, update `dp` with `newdp` (merging better states). This avoids overwriting states needed for the current string's transitions.
5. Final answer is the maximum value among all `dp` states.
6. (Note) A typical optimization is using a 2D array dp of size `(m+1) x (n+1)` and iterating backwards to achieve `O(L*m*n)` time and `O(m*n)` space; the dictionary method may be sparser in practice.

# ðŸ’» Code 
```python
from typing import List

class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = {(0, 0): 0}

        for s in strs:
            ones = 0
            zeroes = 0
            for ch in s:
                if ch == "0":
                    zeroes += 1
                else:
                    ones += 1
            newdp = {}

            for k, v in dp.items():
                prevzeroes, prevones = k
                newzeroes, newones = prevzeroes + zeroes, prevones + ones
                if newzeroes <= m and newones <= n:
                    if (newzeroes, newones) not in dp:
                        newdp[(newzeroes, newones)] = v + 1

                    elif dp[(newzeroes, newones)] < v + 1:
                        newdp[(newzeroes, newones)] = v + 1
            dp.update(newdp)
        return max(dp.values())
````

# â± Complexity Analysis

* Time: In the worst case the dictionary can grow to `O(m * n)` states and for each of the `L = len(strs)` strings we iterate all states â†’ `O(L * m * n)` worst-case time.
* Space: `O(m * n)` worst-case to store `dp` states.

# ðŸ§ª Edge Cases

* `strs` is empty â†’ returns `0`.
* `m = 0` or `n = 0` â†’ only strings consisting exclusively of the allowed character can be chosen.
* Strings whose zero/one counts individually exceed `(m, n)` are simply never taken.
* Large `m,n` with many strings â†’ dictionary may approach full `(m+1)*(n+1)` state space; consider switching to a 2D list DP for predictable memory/time.
* Duplicate strings: handled normally (each string is considered once).

```
```
