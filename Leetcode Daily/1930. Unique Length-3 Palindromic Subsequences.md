# ðŸ· Count Unique Palindromic Subsequences of Length 3 (a_x_a)

# ðŸ“œ Problem Statement
Given a lowercase string `s`, count how many distinct palindromic subsequences of length 3 exist of the form `a x a` where `a` and `x` are characters (they may be the same). Each distinct subsequence is determined by the trio of characters `(a, x, a)` â€” count how many different middle characters `x` appear between the first and last occurrence of the same outer character `a`.

# ðŸ” Example Input/Output
Input:
```

s = "abcba"

```
Output:
```

3

````
Explanation: The palindromic subsequences of form `a_x_a` are: `a b a`, `a c a`, and `b c b` â†’ 3 distinct ones.

# ðŸ§  Approach
1. For each letter `a` (26 lowercase letters), record the index of its first and last occurrence in `s`.
2. If a letter's first and last occurrences are at least two indices apart, there is room for a middle character.
3. For the substring strictly between those two occurrences, mark which characters appear; each distinct middle character `x` yields a unique palindrome `a x a`.
4. Sum these unique middle-character counts across all outer letters `a`. Because the alphabet size is constant (26), the algorithm runs in linear time relative to `len(s)`.

# ðŸ’» Code 
```python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        n = len(s)
        first = [n] * 26
        last = [-1] * 26

        # find first & last
        for i, ch in enumerate(s):
            idx = ord(ch) - ord('a')
            first[idx] = min(first[idx], i)
            last[idx] = i

        res = 0

        for c in range(26):
            L, R = first[c], last[c]
            if R - L < 2:
                continue

            seen = [False] * 26

            for i in range(L + 1, R):
                idx = ord(s[i]) - ord('a')
                if not seen[idx]:
                    seen[idx] = True
                    res += 1

        return res
````

# â± Complexity Analysis

* **Time:** `O(n + 26 * n)` which simplifies to `O(n)` since 26 is constant; you scan the string once to gather first/last and then at most scan inner segments up to `n` for each letter but the constant factor is bounded.
* **Space:** `O(1)` extra space (arrays of fixed size 26 and a few scalars).

# ðŸ§ª Edge Cases

* Empty string `s = ""` â†’ returns `0`.
* No character appears twice â†’ returns `0`.
* Repeated single character `s = "aaaa"` â†’ middle characters are only `'a'`, so returns `1` (`a a a`).
* Long strings with many repeats â€” algorithm remains efficient because alphabet size is constant.
* Non-lowercase input is outside assumed constraints (function assumes lowercase `a`â€“`z`).

```
```
