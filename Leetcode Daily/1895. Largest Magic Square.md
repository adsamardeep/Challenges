# üè∑ Largest Magic Square in a Grid

## üìú Problem Statement
Given a 2D grid of integers, find the **largest magic square** within the grid.  
A magic square is a square subgrid where **all row sums, column sums, and both diagonal sums are equal**.  
Return the **size (side length)** of the largest such magic square.

## üîç Example Input/Output
**Input**
```python
grid = [
    [7, 1, 4, 5, 6],
    [2, 5, 1, 6, 4],
    [1, 5, 4, 3, 2],
    [1, 2, 7, 3, 4]
]
````

**Output**

```python
3
```

**Explanation**
There exists a `3 √ó 3` subgrid where all rows, columns, and diagonals sum to the same value.

## üß† Approach

### Key Ideas

* Precompute **prefix sums** for:

  * Rows
  * Columns (via transpose)
  * Main diagonals
  * Anti-diagonals
* This allows constant-time sum queries for any sub-square.
* Check square sizes from **largest to smallest** (greedy optimization).

### Steps

1. Build row-wise and column-wise prefix sums.
2. Build diagonal and anti-diagonal prefix sum matrices.
3. For a given size `k`, check every `k √ó k` subgrid:

   * Compare main diagonal sum and anti-diagonal sum.
   * Verify all row sums and column sums match.
4. Return the largest `k` that satisfies magic square conditions.
5. If none found, return `1` (every single cell is trivially magic).

## üíª Code 

```python
from itertools import accumulate
from typing import List

class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        r, c = len(grid), len(grid[0])

        rowSum = [list(accumulate(row, initial=0)) for row in grid]
        colSum = [list(accumulate(col, initial=0)) for col in zip(*grid)]

        diag, antidiag = ([[0] * (c + 1) for _ in range(r + 1)] for _ in range(2))

        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                diag[i + 1][j + 1] = diag[i][j] + x
                antidiag[i + 1][j] = antidiag[i][j + 1] + x

        def isMagic(k: int) -> bool:
            for i in range(r - k + 1):
                for j in range(c - k + 1):
                    Sum = diag[i + k][j + k] - diag[i][j]
                    antiD = antidiag[i + k][j] - antidiag[i][j + k]
                    if Sum != antiD:
                        continue

                    for m in range(k):
                        if (
                            rowSum[i + m][j + k] - rowSum[i + m][j] != Sum or
                            colSum[j + m][i + k] - colSum[j + m][i] != Sum
                        ):
                            break
                    else:
                        return True
            return False

        for k in range(min(r, c), 1, -1):
            if isMagic(k):
                return k
        return 1
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(min(r, c) √ó r √ó c)`
* **Space Complexity:** `O(r √ó c)` for prefix sum matrices

## üß™ Edge Cases

* Grid of size `1 √ó 1` ‚Üí return `1`
* No magic square larger than size `1`
* Rectangular (non-square) grids
* Multiple magic squares ‚Üí return the largest size

```
```
