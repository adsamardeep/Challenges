# üè∑ Count Trapezoids Using Pairwise Vectors and Line Hashing

# üìú Problem Statement
Given a set of 2D integer points, count the number of trapezoids that can be formed where the two bases are segments lying on two distinct parallel lines. The solution enumerates all point-pairs (segments), groups them by slope and by exact vector, and uses combinatorics to count valid trapezoid configurations while removing overcounts coming from parallelograms.

# üîç Example Input/Output
Input:
```

points = [[0,0],[1,0],[0,1],[1,1],[2,0]]

```
Output (conceptual):
```

number of trapezoids formed by pairs of parallel horizontal or other-slope segments

```
(Exact numeric output depends on the set; the code returns the integer count.)

# üß† Approach
1. Iterate over all unordered pairs of points `(i, j)` to obtain the segment vector `dx = x2-x1`, `dy = y2-y1`.
2. Normalize the vector direction to a canonical slope `(ux, uy)` by dividing by `g = gcd(dx, dy)` and ensuring a unique sign convention (so `(1,1)` and `(-1,-1)` map consistently).
3. Compute a `line_id` for the infinite line that goes through the first point with that normalized direction: `line_id = ux*y1 - uy*x1`. This scalar uniquely identifies the translated line among lines with the same slope.
4. Maintain two nested maps (dictionaries):
   - `by_slope[slope_key][line_id]` ‚Äî counts how many segments (point-pairs) lie on the same geometric line grouped by slope. This is used to count pairs of segments that lie on different parallel lines (candidate trapezoid bases).
   - `by_vector[vector_key][line_id]` ‚Äî counts how many segments with the **same exact vector** (same dx,dy, i.e., same length and direction) lie on the same line grouping. This helps identify parallelograms which are special cases that produce overcounts in the trapezoid counting and must be corrected for.
   (A small `SHIFT` and `encode_pair` are used to encode 2D integer pairs into single integer keys for dict lookup.)
5. For each outer grouping (either slopes or vectors), compute the number of ordered pairs of segments that lie on distinct lines but share the grouping key. If `counts` are the per-line counts, the formula
```

## (sum counts)^2 - sum(counts^2)

```
             2
```

````
yields the number of unordered pairs of segments that come from different lines but share the grouping key.
6. `with_parallel = count_pairs(by_slope)` counts candidate trapezoid base-pairs formed by segments on different parallel lines.
7. `parallelogram_twice = count_pairs(by_vector)` counts parallelogram-forming pairs twice (since parallelograms have both pairs of opposite sides equal vectors). Subtract half of this value to remove parallelograms from the trapezoid count.
8. Final result = `with_parallel - parallelogram_twice // 2`.

This yields the number of trapezoids whose two bases are formed by two segments on two different parallel lines while avoiding counting parallelograms as trapezoids twice.

# üíª Code 
```python
from typing import List
from collections import defaultdict
from math import gcd

class Solution:
 def countTrapezoids(self, points: List[List[int]]) -> int:
     n = len(points)
     SHIFT = 3000
     
     def encode_pair(a: int, b: int) -> int:
         return ((a + SHIFT) << 13) ^ (b + SHIFT)
     
     by_slope = defaultdict(lambda: defaultdict(int))
     by_vector = defaultdict(lambda: defaultdict(int))
     
     for i in range(n):
         x1, y1 = points[i]
         for j in range(i + 1, n):
             x2, y2 = points[j]
             dx = x2 - x1
             dy = y2 - y1
             
             if dx < 0 or (dx == 0 and dy < 0):
                 dx = -dx
                 dy = -dy
             
             g = gcd(dx, dy)
             ux = dx // g
             uy = dy // g
             
             line_id = ux * y1 - uy * x1
             
             slope_key = encode_pair(ux, uy)
             vector_key = encode_pair(dx, dy)
             
             by_slope[slope_key][line_id] += 1
             by_vector[vector_key][line_id] += 1
     
     def count_pairs(mp) -> int:
         ans = 0
         for inner in mp.values():
             counts = inner.values()
             s = sum(counts)
             sum_sq = sum(c * c for c in counts)
             ans += (s * s - sum_sq) // 2
         return ans
     
     with_parallel = count_pairs(by_slope)
     parallelogram_twice = count_pairs(by_vector)
     
     return with_parallel - parallelogram_twice // 2
````

# ‚è± Complexity Analysis

* **Time:** `O(n^2)` to enumerate all point pairs and compute keys, plus additional overhead to aggregate counts. Counting combinations iterates over grouped entries; overall dominated by `O(n^2)`.
* **Space:** `O(n^2)` in the worst case for the dictionaries that store counts for many different segment keys (though practically much smaller when many points share slopes or vectors).

# üß™ Edge Cases

* Duplicate points: if input contains identical points, pairs with zero vector should be considered carefully (gcd/division and sign normalization may need attention). This implementation assumes distinct point pairs but will process duplicates ‚Äî zero-length vectors may cause division by zero unless avoided by problem constraints.
* Collinear many points: many pairs will belong to the same line; counts grow but formula handles combinatorics.
* Large coordinates: `SHIFT` and bit-encoding expect coordinates within a range that avoids collisions; if coordinates can be outside expected bounds, increase SHIFT/bit-width or use tuple keys instead of encoded integers.
* Very small n (`n < 4`): there are no trapezoids ‚Äî result will be `0`.
* Parallelogram handling: the subtraction `parallelogram_twice // 2` assumes each parallelogram is counted exactly twice in `parallelogram_twice`; this is true under the current counting scheme where equal vectors on opposite sides appear in two vector-groups.

```
```
