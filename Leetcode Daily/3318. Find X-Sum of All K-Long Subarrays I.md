# Sliding-Window Top-X Frequency Sum

ðŸ“œ **Problem Statement**  
Given an integer array `nums`, a window size `k`, and an integer `x`, compute for every contiguous subarray (window) of length `k` the sum of the **top `x` numbers ordered by frequency** inside that window, where each chosen number contributes `number * frequency` to the sum.  
- If fewer than `x` distinct numbers appear in the window, take as many as available.  
- When frequencies tie, this implementation breaks ties by taking the larger numeric value first (so among equal frequencies, the larger number is preferred).

Return a list `ans` of length `len(nums) - k + 1` where `ans[i]` is the described sum for the window `nums[i : i+k]`.

ðŸ” **Example Input / Output**  
**Input**
nums = [1,2,2,3,3,3]
k = 4
x = 2


**Windows and reasoning**

* Window 0: [1,2,2,3] â†’ freqs {(2:2),(3:1),(1:1)} â†’ top2 = (2 with f=2) and (3 with f=1) â†’ sum = 2*2 + 3*1 = 7
* Window 1: [2,2,3,3] â†’ freqs {(2:2),(3:2)} â†’ tie on frequency â†’ pick larger number first â†’ top2 = (3,f=2) and (2,f=2) â†’ sum = 3*2 + 2*2 = 10
* Window 2: [2,3,3,3] â†’ freqs {(3:3),(2:1)} â†’ top2 = (3,f=3) and (2,f=1) â†’ sum = 3*3 + 2*1 = 11

**Output**

```py
[7, 10, 11]
```

ðŸ§  **Approach (step-by-step)**

1. Use a frequency table for values in `nums`. If values are known to be small (e.g. `0..50`) you can keep a fixed-size array `freq` where `freq[v] = [count, value]`.
2. Initialize frequencies using the first window of length `k`.
3. For each window:

   * Compute the top `x` entries by sorting the frequency table descending by `(count, value)` and summing `value * count` for the first `x` non-zero counts.
   * Slide the window by decrementing the frequency of the outgoing element and incrementing the incoming one, then recompute the top-x sum for the next window.
4. Return the list of sums.

> Note: This implementation recomputes the top-x by sorting the (small) frequency table for each window. If the value-range is small (as in problems with values â‰¤ 50) this is fine. For large value ranges you should use a different data structure (multiset / heap / balanced tree or maintain buckets of counts) to achieve better performance.

ðŸ’» **Code**

```python
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        # Helper: compute the x-sum from the frequency table
        def x_sum(freq):
            # freq is a list of [count, value]; sort by count desc, then value desc
            freq2 = sorted(freq, reverse=True)
            total = 0
            taken = 0
            for cnt, val in freq2:
                if cnt == 0:
                    break
                total += val * cnt
                taken += 1
                if taken == x:
                    break
            return total

        n = len(nums)
        sz = n - k + 1
        if sz <= 0:
            return []

        # Assuming nums contain values in 0..50 (adjust size if value range differs)
        MAXV = 50
        freq = [[0, v] for v in range(MAXV + 1)]

        # build initial window frequency
        for z in nums[:k]:
            freq[z][0] += 1

        ans = [0] * sz
        ans[0] = x_sum(freq)

        # slide window
        for l in range(1, sz):
            L, R = nums[l - 1], nums[l + k - 1]
            freq[L][0] -= 1
            freq[R][0] += 1
            ans[l] = x_sum(freq)

        return ans
```

â± **Complexity Analysis**

* Let `V` be the size of the value domain (here `V = 51` for values `0..50`).
* For each window we sort `V` items: `O(V log V)` per window. There are `O(n)` windows â†’ total time `O(n * V log V)`.
* Space is `O(V)` for the frequency table plus `O(n)` for the output.

If `V` is small (like â‰¤ 100), this is practical. If `V` is large (values up to 10âµ or unbounded), prefer:

* a balanced tree / heap of nonzero frequencies, or
* maintain buckets keyed by frequency and update them on slide (to get near `O(n + V)`), or
* use a partial selection algorithm (like maintaining a small max-heap of size `x`) to avoid full sorts.

ðŸ§ª **Edge Cases**

* `k > len(nums)` â†’ returns `[]`.
* `x = 0` â†’ result is all zeros (no numbers to pick).
* If numbers exceed assumed range (0..50) update `MAXV` or use a `defaultdict(int)` frequency map and an appropriate selection method.
* When fewer than `x` distinct values exist in a window, the code sums as many distinct values as present.
* Tie-breaking: among equal counts this implementation prefers larger numeric values because sorting of `[count, value]` in reverse order orders by count then value.

```
```
