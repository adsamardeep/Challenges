# ðŸ· Minimum Pair Removals to Make Array Non-Decreasing

## ðŸ“œ Problem Statement
Given an array of integers, repeatedly remove **one adjacent pair** by replacing it with their sum until the array becomes **non-decreasing**.  
In each step, you must choose the adjacent pair with the **minimum sum**.  
Return the **minimum number of such operations** required.

## ðŸ” Example Input/Output
**Input**
```python
nums = [3, 2, 1]
````

**Output**

```python
2
```

**Explanation**

* Step 1: pairs â†’ (3,2)=5, (2,1)=3 â†’ pick (2,1)
  â†’ array becomes `[3, 3]`
* Step 2: array is still not non-decreasing
  â†’ merge (3,3)=6
  â†’ array becomes `[6]`
* Total operations = `2`

## ðŸ§  Approach

1. Repeatedly check whether the array is non-decreasing.
2. If not sorted:

   * Find the adjacent pair with the **smallest sum**.
   * Replace the left element of the pair with the sum.
   * Shift elements left to remove the right element.
3. Reduce the effective array size by 1.
4. Count how many such operations are needed until the array becomes sorted.

This is a **greedy simulation** approach that strictly follows the problemâ€™s rules.

## ðŸ’» Code 

```python
class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        def isSorted(nums, n) -> bool:
            for i in range(1, n):
                if nums[i] < nums[i - 1]:
                    return False
            return True

        ans, n = 0, len(nums)

        while not isSorted(nums, n):
            ans += 1
            min_sum, pos = float('inf'), -1

            for i in range(1, n):
                sum = nums[i - 1] + nums[i]
                if sum < min_sum:
                    min_sum = sum
                    pos = i

            nums[pos - 1] = min_sum
            for i in range(pos, n - 1):
                nums[i] = nums[i + 1]
            n -= 1

        return ans
```

## â± Complexity Analysis

* **Time Complexity:** `O(nÂ³)` in the worst case

  * Sorting check: `O(n)`
  * Pair scan: `O(n)`
  * Up to `n` merge operations
* **Space Complexity:** `O(1)` (in-place modification)

## ðŸ§ª Edge Cases

* Already sorted array â†’ `0` operations
* Single-element array
* All elements equal
* Strictly decreasing array
* Large values causing large merged sums

```
```
