# Minimum Score Triangulation of Polygon

📜 **Problem Statement**  
Given an array `values` where `values[i]` is the value at the i-th vertex of a convex polygon (n ≥ 3), triangulate the polygon into `n-2` triangles. The score of a triangle with vertices `(i, j, k)` is `values[i] * values[j] * values[k]`. Return the minimum total score possible across all triangulations.

🔍 **Example Input/Output**  
**Input**
    values = [1, 2, 3]
**Output**
    6
**Explanation**
    Only one triangle: 1*2*3 = 6

**Input**
    values = [3, 7, 4, 5]
**Output**
    144
**Explanation**
    One optimal triangulation gives total 144.

🧠 **Approach (step-by-step)**  
1. This is a classic interval DP problem. Let `dp[l][r]` be the minimum triangulation score for the polygonal chain from vertex `l` to `r` (inclusive). We only consider `r - l >= 2` (a valid triangle or larger).  
2. Base case: if `r - l < 2` (less than 3 vertices), there is no triangle and cost is `0`.  
3. For `r - l >= 2`, try every possible `k` with `l < k < r` as the middle vertex of a triangle `(l, k, r)`. The cost for that choice is:
      dp[l][k] + values[l] * values[k] * values[r] + dp[k][r]
   Take the minimum across all `k`.  
4. Use memoization (top-down) or bottom-up DP. The straightforward implementation is top-down recursion with a `dp` table of size `n x n`. Time complexity is `O(n^3)` (three nested loops: l, r, k) and space `O(n^2)`.

💻 **Code**  

    from typing import List

    class Solution:
        def minScoreTriangulation(self, values: List[int]) -> int:
            n = len(values)
            if n < 3:
                return 0

            # dp[l][r] = min score to triangulate polygon from l..r (inclusive)
            dp = [[0] * n for _ in range(n)]

            # Iterate lengths from 3 up to n
            for length in range(3, n + 1):  # length = number of vertices in the interval
                for l in range(0, n - length + 1):
                    r = l + length - 1
                    best = float('inf')
                    # choose k between l and r as the triangle (l, k, r) partition
                    for k in range(l + 1, r):
                        cost = dp[l][k] + values[l] * values[k] * values[r] + dp[k][r]
                        if cost < best:
                            best = cost
                    dp[l][r] = 0 if best == float('inf') else best

            return dp[0][n - 1]

⏱ **Complexity Analysis**  
- Let `n = len(values)`.  
- **Time:** `O(n^3)` — for each interval `(l, r)` we iterate all possible `k` between them.  
- **Space:** `O(n^2)` for the `dp` table.

🧪 **Edge Cases**  
- `len(values) < 3` → return `0` (no triangle).  
- All values equal — algorithm still produces correct minimal product sum.  
- Very large `n` — `O(n^3)` may be too slow if `n` is large (but typical constraints for this problem keep `n` small, e.g., ≤ 50).  
- Preserve input — this implementation does not mutate `values`.  
