# Largest Triangle Area (Convex Hull + Rotating Calipers)

üìú **Problem Statement**  
Given a list of 2D integer points, find the largest area of any triangle that can be formed by choosing any three of the points. The algorithm should be efficient enough for moderately large point sets.

üîç **Example Input / Output**  
**Input**
    points = [[0,0],[0,1],[1,0],[0,2],[2,0]]

**Output**
    2.0

**Explanation**
One maximum triangle is formed by points (0,2), (2,0), (0,0) which has area 2.

üß† **Approach (step-by-step)**  
1. **Compute Convex Hull (Monotone Chain / Andrew's algorithm)**  
   - Sort points by x then y.  
   - Build lower and upper hulls by scanning points and using a cross-product orientation test to maintain convexity.  
   - Concatenate `lower[:-1] + upper[:-1]` to get the hull (unique vertices in CCW order).  
   - Any triangle of maximum area has its vertices on the convex hull, so interior points can be ignored.

2. **Maximize Triangle Area on the Hull (rotating-calipers-like search)**  
   - Let `h` be the number of points on the hull. If `h < 3`, return `0`.  
   - For each ordered pair of hull indices `(i, j)` with `i < j`, find an index `k` that maximizes `area(hull[i], hull[j], hull[k])`.  
   - Move `k` forward as long as the area increases (this is the rotating-calipers idea; since the hull is convex, the best `k` for `(i, j+1)` is at or after the best `k` for `(i, j)` so the pointer advances amortized efficiently).  
   - Track the maximum area encountered.  
   - Return the maximum area.

3. **Geometric helpers**
   - `cross(o, a, b)` gives signed area * 2 (orientation), used for hull building.
   - `area(p1, p2, p3)` computes absolute triangle area using the shoelace formula.

This combination reduces the candidate set (to hull vertices) and then efficiently searches for the max-area triangle among hull vertices.

üíª **Code**  

    from typing import List

    class Solution:
        def largestTriangleArea(self, points: List[List[int]]) -> float:
            def cross(o, a, b):
                return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

            # Build convex hull (monotone chain)
            points = sorted(points)
            lower = []
            for p in points:
                while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
                    lower.pop()
                lower.append(p)
            upper = []
            for p in reversed(points):
                while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
                    upper.pop()
                upper.append(p)
            hull = lower[:-1] + upper[:-1]

            # Area of triangle via shoelace formula
            def area(p1, p2, p3):
                return abs(0.5 * (p1[0] * (p2[1] - p3[1]) +
                                  p2[0] * (p3[1] - p1[1]) +
                                  p3[0] * (p1[1] - p2[1])))

            n = len(hull)
            if n < 3:
                return 0.0

            max_area = 0.0
            # Rotating-calipers-like scanning for max triangle area
            for i in range(n):
                k = i + 2
                for j in range(i + 1, n):
                    # advance k while next point increases area
                    while k < n and area(hull[i], hull[j], hull[k]) < area(hull[i], hull[j], hull[(k + 1) % n]):
                        k += 1
                    max_area = max(max_area, area(hull[i], hull[j], hull[k % n]))

            return max_area

‚è± **Complexity Analysis**  
- Let `m = len(points)` and `h = len(hull)` (# of hull vertices).  
- **Convex hull construction:** sorting `O(m log m)` and single-pass hull building `O(m)`.  
- **Searching max-area triangle:** the nested loops over hull vertices plus advancing `k` lead to worst-case `O(h^2)` area computations (amortized better in many practical cases but can be quadratic in pathological hulls).  
- **Total time:** `O(m log m + h^2)`.  
- **Space:** `O(m)` for sorting and hull storage (plus O(1) extra).

üß™ **Edge Cases**  
- Fewer than 3 distinct points ‚Üí return `0.0`.  
- Collinear points ‚Üí hull has `h <= 2`, return `0.0`.  
- Duplicate points in input ‚Üí sorting + hull building handles duplicates (they don't affect hull vertices).  
- Numerical stability / precision ‚Üí areas are computed as `float`; for integer coordinates this is exact up to float rounding for reasonably sized coordinates. If exact rational arithmetic is required, compute doubled area as integer (omit `0.5`) and divide/format at the end.  
- If you expect very large hull sizes and need guaranteed better-than-quadratic performance, further optimizations / specialized rotating calipers implementations exist that can reduce constant factors or exploit geometry to prune pairs; however for typical constraints this approach is standard and effective.

