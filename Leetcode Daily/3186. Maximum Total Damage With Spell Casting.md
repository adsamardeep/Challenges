# Maximum Total Damage (Delete-and-Earn variant with gap 2)

üìú **Problem Statement**  
Given a list `power` (integers), choosing all elements of value `x` yields `x * count(x)` damage, but when you take value `x` you cannot take any values `y` where `|y - x| ‚â§ 2`. Return the maximum total damage obtainable by selecting an optimal subset of distinct values (you either take all occurrences of a chosen value or skip that value).

üîç **Example Input/Output**  
**Input**
    power = [1,2,2,3,5,5,6]

**Explanation (conceptual)**  
- Counts: 1‚Üí1, 2‚Üí2, 3‚Üí1, 5‚Üí2, 6‚Üí1  
- If you pick value 5 (damage 10), you cannot pick 3,4,6. If you pick 2 (damage 4), you cannot pick 0,1,3,4.  
One optimal choice may be {2,5} -> damage = 4 + 10 = 14 (depending on available values).  
**Output**
    14  (for this illustrative input)

üß† **Approach (step-by-step)**  
This is analogous to the classic ‚ÄúDelete and Earn‚Äù / ‚ÄúHouse Robber‚Äù style DP but with a blocking radius of 2 instead of 1. Steps:

1. Build a frequency map `freq` of values in `power`. Let `keys` be the sorted list of distinct values.  
2. Let `val[i] = freq[keys[i]] * keys[i]` be the total damage gained by taking value `keys[i]`.  
3. Use DP over the sorted distinct keys: define `dp[i]` = maximum damage using keys up to index `i`.  
   - If you take `keys[i]`, you must skip any key `keys[t]` with `keys[t] >= keys[i] - 2`. So find the largest index `ans` < `i` such that `keys[ans] <= keys[i] - 3` ‚Äî that is the rightmost key you are allowed to combine with `keys[i]`.  
   - Then `take = val[i] + (dp[ans] if ans >= 0 else 0)`.  
   - `dp[i] = max(dp[i-1], take)` (either skip `keys[i]` or take it).  
4. Return `dp[-1]`.

A binary search over `keys` is used to find `ans` efficiently for each `i`, giving overall `O(n log n)` dominated by sorting + binary searches, where `n` is number of distinct keys.

üíª **Code**  

    from typing import List
    from collections import Counter

    class Solution:
        def maximumTotalDamage(self, power: List[int]) -> int:
            # Frequency of each power value
            freq = Counter(power)
            # Sorted distinct power values
            keys = sorted(freq)
            n = len(keys)
            if n == 0:
                return 0

            # dp[i] = max damage using keys[0..i]
            dp = [0] * n
            # base case: take the smallest key's full damage
            dp[0] = freq[keys[0]] * keys[0]

            for i in range(1, n):
                # damage if we take all occurrences of keys[i]
                take = freq[keys[i]] * keys[i]

                # binary search for the rightmost index ans < i with keys[ans] <= keys[i] - 3
                l, r, ans = 0, i - 1, -1
                while l <= r:
                    mid = (l + r) // 2
                    if keys[mid] <= keys[i] - 3:
                        ans = mid
                        l = mid + 1
                    else:
                        r = mid - 1

                if ans >= 0:
                    take += dp[ans]

                # either skip current key (dp[i-1]) or take it (take)
                dp[i] = max(dp[i - 1], take)

            return dp[-1]

‚è± **Complexity Analysis**  
- Let `m` be the number of distinct values (i.e., `len(keys)`).  
- Sorting `keys`: O(m log m) (dominant).  
- For each `i` we do a binary search O(log m), so total DP + searches: O(m log m).  
- Building the Counter is O(len(power)).  
- **Overall time:** O(len(power) + m log m).  
- **Space:** O(m) for `freq`, `keys`, and `dp`.

üß™ **Edge Cases**  
- Empty `power` ‚Üí return `0`.  
- All values identical ‚Üí simply return `value * count`.  
- Values spaced by ‚â• 3 ‚Üí you can take all values (no conflicts).  
- Values with many duplicates ‚Üí accounted for by `freq[key] * key`.  
- Very large power values but few distinct keys ‚Üí algorithm still efficient because it works on distinct keys only.  

