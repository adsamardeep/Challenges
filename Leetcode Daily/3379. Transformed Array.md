\# ğŸ· Construct Transformed Array Using Circular Indexing



\## ğŸ“œ Problem Statement

You are given an integer array `A`.  

For each index `i`, the value `A\[i]` indicates how far you should move (forward or backward) from index `i` in a \*\*circular manner\*\*.  

Your task is to construct a new array where each element is taken from the shifted index:

```



new\[i] = A\[(i + A\[i]) % len(A)]



````



Return the transformed array.



---



\## ğŸ” Example Input/Output

\*\*Input\*\*

```python

A = \[3, -2, 1, 1]

````



\*\*Output\*\*



```python

\[1, 3, -2, 1]

```



\*\*Explanation\*\*



\* i = 0 â†’ (0 + 3) % 4 = 3 â†’ A\[3] = 1

\* i = 1 â†’ (1 - 2) % 4 = 3 â†’ A\[3] = 1

\* i = 2 â†’ (2 + 1) % 4 = 3 â†’ A\[3] = 1

\* i = 3 â†’ (3 + 1) % 4 = 0 â†’ A\[0] = 3



---



\## ğŸ§  Approach



\* Iterate over the array using `enumerate`

\* For each index `i` and value `v`, compute the new index as:



&nbsp; ```

&nbsp; (i + v) % n

&nbsp; ```

\* Pythonâ€™s modulo operator naturally handles negative indices

\* Directly build the result using a list comprehension



This keeps the solution \*\*clean, fast, and readable\*\*.



---



\## ğŸ’» Code 



```python

class Solution:

&nbsp;   def constructTransformedArray(self, A: List\[int]) -> List\[int]:

&nbsp;       return \[A\[(i + v) % len(A)] for i, v in enumerate(A)]

```



---



\## â± Complexity Analysis



\* \*\*Time Complexity:\*\* `O(n)`

\* \*\*Space Complexity:\*\* `O(n)` (for the result array)



---



\## ğŸ§ª Edge Cases



\* Single-element array â†’ always returns the same element

\* Negative shifts â†’ safely handled by modulo

\* Large positive shifts â†’ wrapped correctly using `% len(A)`



---



