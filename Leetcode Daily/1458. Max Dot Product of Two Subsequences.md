# üè∑ Maximum Dot Product of Two Subsequences

## üìú Problem Statement
Given two integer arrays `nums1` and `nums2`, find the maximum dot product between **non-empty subsequences** of the two arrays. A subsequence preserves order but does not need to be contiguous.

## üîç Example Input/Output
**Input:**
```python
nums1 = [2, 1, -2, 5]
nums2 = [3, 0, -6]
````

**Output:**

```python
18
```

**Explanation:**
Choose subsequences `[2, -2, 5]` and `[3, 0, -6]` ‚Üí `2*3 + (-2)*0 + 5*(-6) = 6 + 0 - 30 = -24` (not optimal).
Best choice is `[2, 1]` and `[3, 0]` ‚Üí `2*3 + 1*0 = 6`.
Even better: `[2, 5]` and `[3, -6]` ‚Üí `2*3 + 5*(-6) = 6 - 30 = -24`.
Optimal here is `[2]` and `[3]` ‚Üí `6`, but with full DP the correct maximum is `18`.

## üß† Approach

1. Ensure `nums2` is the shorter array to reduce space usage.
2. Use **dynamic programming** where `dp[j]` represents the maximum dot product considering:

   * First `i` elements of `nums1`
   * First `j` elements of `nums2`
3. For each pair `(i, j)`:

   * Either start a new subsequence with `nums1[i-1] * nums2[j-1]`
   * Or extend a previous subsequence (`prev_diag`)
   * Or skip an element from either array
4. Use a rolling 1D DP array to achieve space optimization.
5. The answer is stored in `dp[m]`.

## üíª Code 

```python
from typing import List

class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        
        if m > n:
            return self.maxDotProduct(nums2, nums1)
            
        dp = [float('-inf')] * (m + 1)
        
        for i in range(1, n + 1):
            prev_diag = float('-inf')
            
            for j in range(1, m + 1):
                curr_product = nums1[i-1] * nums2[j-1]
                
                temp = dp[j]
                
                dp[j] = max(
                    curr_product,              # start new subsequence
                    curr_product + prev_diag,  # extend previous subsequence
                    dp[j],                     # skip nums1[i-1]
                    dp[j-1]                    # skip nums2[j-1]
                )
                
                prev_diag = temp

        return dp[m]
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(n √ó m)`
  Every pair of indices is processed once.
* **Space Complexity:** `O(m)`
  Optimized from 2D DP to a single array.

## üß™ Edge Cases

* All numbers are negative
* One array has length 1
* Best result comes from a single pair (subsequence of length 1)
* Large magnitude positive and negative values

```
```
