# üí° Problem: Number of Ways to Express `n` as Sum of Unique Powers

## üìú Problem Statement
Given:
- An integer `n`
- An integer `x`

You must determine **the number of distinct ways** to represent `n` as the **sum of unique integers raised to the power `x`**.  
Two sums are considered different if they contain different integers, regardless of order.

Return the answer modulo **10^9 + 7**.

---

## üîç Example 1
**Input**
```
n = 10
x = 2
```

**Step-by-step**
```
Powers of 2 ‚â§ 10: [1, 4, 9]

Possible sums:
- 1¬≤ + 3¬≤ = 1 + 9 = 10
- 10 itself not possible since 10 is not a perfect square

Answer: 1
```

**Output**
```
1
```

---

## üîç Example 2
**Input**
```
n = 100
x = 2
```

**Step-by-step**
```
Powers of 2 ‚â§ 100: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

Example combinations:
- 10¬≤ = 100
- 8¬≤ + 6¬≤ = 64 + 36 = 100
- 1¬≤ + 9¬≤ + 6¬≤ = 1 + 81 + 36 = 118 ‚ùå (too large)
- etc.

Final count (after checking all combinations) ‚Üí 3
```

**Output**
```
3
```

---

## üß† Approach
1. **Precompute Powers**  
   - Generate all numbers of the form `i^x` that are ‚â§ `n`.

2. **Dynamic Programming (Subset Sum Variant)**  
   - Use a **1D DP array** where `dp[s]` = number of ways to get sum `s` using unique powers.
   - Iterate through each power `p` and update the dp array in reverse to ensure uniqueness.

3. **Modulo Handling**  
   - Since the number of ways can be large, take results modulo `10^9 + 7` at each update.

---

## üíª Code Implementation
```python
MOD = 1_000_000_007

class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        # Precompute valid powers of the form i^x
        powers = []
        i = 1
        while True:
            p = pow(i, x)
            if p > n:
                break
            powers.append(p)
            i += 1

        # DP array where dp[s] = ways to get sum s
        dp = [0] * (n + 1)
        dp[0] = 1  # 1 way to make sum 0: choose nothing

        # Process each power for subset sum
        for p in powers:
            for s in range(n, p - 1, -1):
                dp[s] = (dp[s] + dp[s - p]) % MOD

        return dp[n]
```

---

## ‚è± Complexity Analysis
- **Time Complexity:** O(k √ó n)  
  - k = number of powers ‚â§ n
- **Space Complexity:** O(n) for the dp array

---

## üß™ Edge Cases
- `n = 1`, `x = 1` ‚Üí only one way: 1
- Large `n` where `x` is large ‚Üí very few powers to consider
- `n` is itself a perfect power ‚Üí single-element sum possible
