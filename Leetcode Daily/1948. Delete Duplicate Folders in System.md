# ðŸ“‚ Delete Duplicate Folders in the Filesystem

This repository contains a Python implementation to solve the problem of identifying and removing **duplicate folders** from a virtual filesystem represented as a list of paths.

---

## ðŸ“˜ Problem Overview

You're given a list of folder paths (where each path is a list of folder names). Your task is to remove all **duplicate folders**. A folder is considered duplicate if there exists **another folder with the exact same subfolder structure and content**.

The result should only contain **non-duplicate** folder paths.

---

## ðŸ’¡ Example

```python
Input:
paths = [
    ["a"],
    ["c"],
    ["a", "b"],
    ["c", "b"],
    ["a", "b", "x"],
    ["c", "b", "x"],
    ["a", "b", "x", "y"],
    ["c", "b", "x", "y"]
]

Output:
[
    ["a"],
    ["c"]
]
```

Explanation:
- The folders `["a", "b"]` and `["c", "b"]` have the same structure (both contain `b/x/y`)
- Hence, both `b` folders (and their subfolders) are deleted.

---

## ðŸš€ Approach

### Step 1: Build Tree

Construct a trie/tree from the folder structure.

### Step 2: Generate Signatures

Use DFS to assign a **unique string signature** to each subtree, representing its structure:
```
signature = folderName(childSignature1 + childSignature2 + ...)
```

### Step 3: Count Duplicates

Count how many times each signature appears using a dictionary.

### Step 4: Prune Duplicates

Run another DFS to **reconstruct only non-duplicate paths** by skipping nodes with duplicate signatures.

---

## ðŸ’» Code Example

```python
from collections import defaultdict

class Node:
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.signature = ""

class Solution:
    def deleteDuplicateFolder(self, paths):
        root = Node("")
        for path in paths:
            node = root
            for folder in path:
                if folder not in node.children:
                    node.children[folder] = Node(folder)
                node = node.children[folder]
        
        signature_count = defaultdict(int)
        
        def dfs(node):
            if not node.children:
                node.signature = ""
                return ""
            child_signatures = []
            for name, child in sorted(node.children.items()):
                child_signature = dfs(child)
                child_signatures.append(f"{name}({child_signature})")
            node.signature = "".join(child_signatures)
            signature_count[node.signature] += 1
            return node.signature
        
        dfs(root)
        
        result = []
        current_path = []
        
        def dfs2(node):
            if node.children and signature_count[node.signature] >= 2:
                return
            current_path.append(node.name)
            result.append(current_path.copy())
            for name, child in sorted(node.children.items()):
                dfs2(child)
            current_path.pop()
        
        for name, child in sorted(root.children.items()):
            dfs2(child)
        
        return result
```

---

## âœ… Key Concepts

- Tree/Trie Construction
- Subtree Signature Hashing
- Duplicate Detection via Map
- DFS for Reconstruction

This solution runs in **O(n log n)** due to sorting children for canonical signature generation and uses **O(n)** space.

---