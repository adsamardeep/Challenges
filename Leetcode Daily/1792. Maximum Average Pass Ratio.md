# 🟩 Problem: Maximum Average Pass Ratio After Adding Extra Students

## 📜 Problem Statement
You are given `classes`, a list where each element is `[passes, total_students]` for a class.  
You are also given `extraStudents`, the number of additional students you can assign (each extra student increases both the number of passed students and the total students in whichever class they are assigned to).  

Each class's pass ratio is `passes / total_students`. After distributing all extra students optimally, return the **maximum possible average pass ratio** across all classes.

---

## 🔍 Example

**Input**
    classes = [[1,2],[3,5],[2,2]]
    extraStudents = 2

**Output**
    0.78333...   # approximately

**Explanation**
- Best distribution (one optimal choice) is to add one extra student to class [1,2] → becomes [2,3], and one to [2,2] → becomes [3,3].
- Final ratios: [2/3, 3/5, 3/3] → average ≈ (0.6667 + 0.6 + 1.0) / 3 ≈ 0.7556  
- (Exact optimum depends on tie-breaking; heap-based greedy yields correct maximum average in general.)

---

## 🧠 Approach
1. **Greedy insight:**  
   Adding one extra student to a class `(p, t)` increases its pass ratio by:
   \[
   \Delta(p,t) = \frac{p+1}{t+1} - \frac{p}{t}
   \]
   We should always assign an extra student to the class that yields the largest immediate increase `Δ`.

2. **Use a max-heap (priority queue):**  
   - Compute the current gain for every class and push `(-gain, p, t)` into a heap (negative because Python's `heapq` is a min-heap).
   - Pop the class with the largest gain, increment `p` and `t` by 1, recompute its gain, and push it back.
   - Repeat for `extraStudents` iterations.

3. **Result:**  
   After all extra students are placed, compute the average of `p / t` over all classes.

4. **Why greedy works:**  
   The incremental gain `Δ(p,t)` decreases as you add more students to the same class (diminishing returns). Selecting the local best gain each time yields the global optimum for this problem.

---

## 💻 Code (copy-paste ready; indented to keep entire content in one markdown block)
    import heapq
    from typing import List

    class Solution:
        def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
            # helper: marginal gain of adding one extra student to (p, t)
            def gain(p: int, t: int) -> float:
                return (p + 1) / (t + 1) - p / t

            # build max-heap using negative gains
            pq = [(-gain(p, t), p, t) for p, t in classes]
            heapq.heapify(pq)

            # distribute extra students greedily
            for _ in range(extraStudents):
                neg_g, p, t = heapq.heappop(pq)
                p += 1
                t += 1
                heapq.heappush(pq, (-gain(p, t), p, t))

            # compute final average ratio
            total = sum(p / t for _, p, t in pq)
            return total / len(classes)

---

## ⏱ Complexity Analysis
- **Time Complexity:**  
  - Building heap: O(k) where `k = len(classes)`.  
  - For each of `extraStudents` iterations we do one `heappop` and one `heappush`: each O(log k).  
  - Total: O(k + extraStudents × log k).

- **Space Complexity:** O(k) for the heap.

---

## 🧪 Edge Cases
- `extraStudents = 0` → just return average of initial ratios.
- Very large `extraStudents` relative to classes → heap operations still handle it; one class may absorb many students.
- Classes where `p == t` (100% pass) → gain of adding another student is `0`, heap will push these back with zero gain.
- Floating-point precision → use `float`; final result usually returned to required precision (problem constraints typically accept small EPS).
