# maximumUniqueSubarray - Maximum Sum of Unique Elements Subarray

## ðŸ“˜ Problem Statement

Given an array of integers `nums`, return the **maximum possible sum of a subarray** that contains only **unique elements**. The subarray must be contiguous.

### âœ… Example
```python
Input:  nums = [4, 2, 4, 5, 6]
Output: 17
# Explanation: The subarray [2, 4, 5, 6] has all unique elements and a sum of 17.
```

---

## ðŸ§  Approach

The solution uses a **sliding window** technique with a **set** to track unique elements in the current window:
- Start with two pointers, `left` and `right`.
- Slide `right` forward, adding elements to the window and the running sum.
- If a duplicate is encountered, shrink the window from the left until the duplicate is removed.
- Update the maximum sum encountered during the process.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n) â€” Each element is added and removed from the window at most once.
- **Space Complexity**: O(n) â€” In the worst case, all elements are unique and stored in the set.

---

## ðŸ“„ Code

```python
from typing import List

class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        seen = set()             # To track unique elements
        left = 0
        current_sum = 0
        max_sum = 0

        for right in range(len(nums)):
            # If duplicate, shrink window from the left
            while nums[right] in seen:
                current_sum -= nums[left]
                seen.remove(nums[left])
                left += 1

            # Add current number to window
            current_sum += nums[right]
            seen.add(nums[right])

            # Update max sum
            max_sum = max(max_sum, current_sum)

        return max_sum
```

---

## ðŸ“‚ Usage

This algorithm is useful in scenarios where you need to find the **maximum aggregate value** from a set of **non-repeating elements** in a contiguous blockâ€”such as optimizing a sliding window for performance without repeated data.
