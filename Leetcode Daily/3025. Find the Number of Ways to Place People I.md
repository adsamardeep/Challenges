# 🟩 Problem: Count Pairs of Points with Non-increasing Y after Sorting by X

## 📜 Problem Statement
Given a list of 2D integer points `points = [[x1, y1], [x2, y2], ...]`, we want to count how many ordered pairs `(i, j)` with `i < j` satisfy the following relationship after sorting the points by `x` (ascending) and by `y` (descending for equal `x`):

- `x_i <= x_j` and `y_i >= y_j`,  
and the counting is done so that for a fixed `i` we only count subsequent points `j` whose `y` lies strictly above the last counted `y` for that `i` (this avoids double counting overlapping pairs in a single sweep).

The implementation below sorts the points by `(x, -y)` then, for each `i`, scans forward maintaining a `bot` value (the last `y` counted for this `i`) and a `top` value (`y_i`). For each `j > i`, if `bot < y_j <= top` we count it and update `bot = y_j`. If `bot` reaches `top` we can stop early for this `i`.

---

## 🔍 Example

**Input**
    points = [[1,5], [2,3], [2,4], [3,3], [4,5]]

**Process**
- After sorting by x asc, y desc:  
  `[[1,5], [2,4], [2,3], [3,3], [4,5]]`
- i = 0 (top = 5): we scan j = 1..4 and count y values `<= 5` and `> bot` in order:
  - j=1 y=4 → (bot < 4 <= 5) count → bot = 4
  - j=2 y=3 → (4 < 3) false (not > bot)
  - j=3 y=3 → still false
  - j=4 y=5 → (4 < 5 <= 5) count → bot = 5, equals top → break
  → counts for i=0: 2
- i = 1 (top = 4): scan j=2..4:
  - j=2 y=3 → (bot=-inf < 3 <= 4) count → bot=3
  - j=3 y=3 → (3 < 3) false
  - j=4 y=5 → (3 < 5 <= 4) false
  → counts for i=1: 1
- i = 2 (top = 3): j=3..4:
  - j=3 y=3 → (bot=-inf < 3 <= 3) count → bot=3 → equals top → break
  → counts for i=2: 1
- i = 3 (top = 3): j=4:
  - j=4 y=5 → false
  → counts for i=3: 0
- i = 4: no j
Total result = 2 + 1 + 1 + 0 = **4**

**Output**
    4

---

## 🧠 Approach (explanation of the code)
1. **Sort** the points by `x` increasing and for equal `x` by `y` decreasing: `points.sort(key=lambda x: (x[0], -x[1]))`.  
   - Sorting this way ensures that for the same `x` value, a larger `y` appears before a smaller `y`. This ordering is useful to prevent counting pairs where `x` ties cause ambiguous ordering.

2. **Sweep**:
   - For each index `i` from `0` to `n-1`:
     - Set `top = points[i][1]` (the y bound for this i).
     - Set `bot = -inf` (the last `y` we counted for this `i`).
     - For each `j` in `(i+1)` to `n-1`:
       - Let `y = points[j][1]`.
       - If `bot < y <= top`, increment `result` and set `bot = y`.
       - If `bot == top`, break early because you cannot find any further `y` values strictly between `bot` and `top`.
3. **Return** the accumulated `result`.

This is a straightforward quadratic sweep after sorting, using `bot` to ensure we count each qualifying `y` at most once per `i` and to maintain a non-increasing sequence of selected `y`'s for that `i`.

---

## 💻 Code 
    class Solution:
        def numberOfPairs(self, points: list[list[int]]) -> int:
            # Sort by x ascending; for equal x sort by y descending
            points.sort(key=lambda x: (x[0], -x[1]))
            n = len(points)
            result = 0

            for i in range(n):
                top = points[i][1]
                bot = float("-inf")
                for j in range(i + 1, n):
                    y = points[j][1]
                    if bot < y <= top:
                        result += 1
                        bot = y
                        if bot == top:
                            break
            return result

---

## ⏱ Complexity Analysis
- **Time Complexity:** O(n²) in the worst case (sorting is O(n log n), but the nested scan dominates for large n).  
- **Space Complexity:** O(1) extra space (sorting in place, constant additional variables).

---

## 🧪 Edge Cases
- Empty list or single point → returns `0`.
- All points have strictly increasing `y` with increasing `x` → many pairs possible but bounded by O(n²) scan.
- Many duplicate points or identical `x,y` → sorting groups them; the `bot` logic prevents over-counting for a given `i`.
- If you need a different pair definition (e.g., count all pairs with `x_i <= x_j` and `y_i >= y_j` without the `bot` constraint), this algorithm would need to be adapted (e.g., use Fenwick tree / coordinate compression to count all such pairs efficiently).
