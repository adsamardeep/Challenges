# ðŸŽ `maxCollectedFruits` â€“ Maximize Fruits Collected on a Diagonal Grid

## ðŸ“˜ Problem Statement

You are given an `n x n` grid of integers `fruits`, where `fruits[i][j]` represents the number of fruits at cell `(i, j)`.

You need to **maximize the number of fruits collected** with the following rules:

- Start by collecting all fruits on the **main diagonal**: `fruits[i][i]` for all `i`.
- Then:
  - One person walks from the **top-left to top-right corner**, moving only right or down.
  - Another person walks from the **top-left to bottom-left corner**, moving only down or right.
- Both collect additional fruits **along their respective paths**, avoiding the diagonal.

Return the **maximum total fruits collected**.

---

### âœ… Example

```python
Input:
fruits = [
  [3, 2, 1],
  [1, 5, 1],
  [1, 1, 4]
]

Output: 20

# Explanation:
# Diagonal = 3 + 5 + 4 = 12
# Top-right path can collect: 2 + 1 + 1 = 4
# Bottom-left path can collect: 1 + 1 + 2 = 4
# Total = 12 + 4 + 4 = 20
```

---

## ðŸ§  Approach

1. **Diagonal Collection:**
   - First, collect all `fruits[i][i]` along the diagonal.

2. **Right Path (Top-left to Top-right):**
   - Starting at `fruits[0][n-1]`, move one step down or left.
   - Track maximum fruit collection using a sliding window approach.

3. **Bottom Path (Top-left to Bottom-left):**
   - Starting at `fruits[n-1][0]`, move one step up or right.
   - Similarly use a window to compute max path collection.

4. Use dynamic programming with two rolling arrays (`right_path` and `bottom_path`) that update possible max values step-by-step from borders to center.

5. Adjust the window size dynamically to simulate the growing/shrinking path range as the traveler moves toward the center.

---

## ðŸ“„ Code

```python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        total = sum(fruits[i][i] for i in range(n))

        right_path = [0] * 3
        right_path[0] = fruits[0][n - 1]

        bottom_path = [0] * 3
        bottom_path[0] = fruits[n - 1][0]

        window = 2

        for step in range(1, n - 1):
            new_right = [0] * (window + 2)
            new_bottom = [0] * (window + 2)

            for dist in range(window):
                left = right_path[dist - 1] if dist - 1 >= 0 else 0
                mid = right_path[dist]
                right = right_path[dist + 1] if dist + 1 < len(right_path) else 0
                new_right[dist] = max(left, mid, right) + fruits[step][n - 1 - dist]

                left = bottom_path[dist - 1] if dist - 1 >= 0 else 0
                mid = bottom_path[dist]
                right = bottom_path[dist + 1] if dist + 1 < len(bottom_path) else 0
                new_bottom[dist] = max(left, mid, right) + fruits[n - 1 - dist][step]

            right_path = new_right
            bottom_path = new_bottom

            if window - n + 4 + step <= 1:
                window += 1
            elif window - n + 3 + step > 1:
                window -= 1

        return total + right_path[0] + bottom_path[0]
```

---

## ðŸ•’ Complexity

- **Time:** O(nÂ²)  
  (Each cell on the top-right and bottom-left borders is visited step-by-step.)
  
- **Space:** O(n)  
  (Rolling arrays are used for dynamic programming, not full matrices.)

---

## ðŸ§ª Edge Cases

- `n = 1`: Only one cell, return that cellâ€™s value.
- Grid with all 0s: Output = 0
- Large values on borders vs diagonal: Ensures dynamic choices prioritize max gain.

---
