# üè∑ Minimum Cost with Distance Constraint (Sliding Window + Two Sorted Sets)

## üìú Problem Statement
You are given:
- An integer array `nums`
- An integer `k`
- An integer `dist`

You must choose **k elements** such that:
- The **first element is always `nums[0]`**
- The remaining `k-1` elements are chosen from a window of size `dist + 1`
- The goal is to **minimize the total sum**

Return the minimum possible cost.

## üîç Example Input/Output
**Input**
```python
nums = [1, 3, 2, 6, 4, 2]
k = 3
dist = 2
````

**Output**

```python
5
```

**Explanation**

* Always include `nums[0] = 1`
* Choose the smallest `k-1 = 2` elements within distance `dist`
* Minimum valid sum = `1 + 2 + 2 = 5`

## üß† Approach

This solution uses a **sliding window** combined with **two balanced sorted sets**:

### Key Ideas

* `left_set`: keeps the **k-1 smallest elements** in the current window
* `right_set`: holds the remaining larger elements
* `current_sum`: tracks the sum of `nums[0]` and elements in `left_set`

### Steps

1. Fix `nums[0]` and reduce `k` by 1
2. Initialize the window with `dist + 1` elements
3. Maintain exactly `k-1` smallest values in `left_set`
4. Slide the window:

   * Remove outgoing element
   * Insert incoming element
   * Rebalance sets to preserve size invariant
5. Track the minimum sum seen

This guarantees optimal performance without recomputing sums.

## üíª Code 

```python
class Solution:
    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        
        def move_from_left_to_right():
            nonlocal current_sum
            element = left_set.pop()
            current_sum -= element 
            right_set.add(element)

        def move_from_right_to_left():
            nonlocal current_sum
            element = right_set.pop(0)
            left_set.add(element)
            current_sum += element 

        k -= 1

        current_sum = sum(nums[:dist + 2])
        left_set = SortedList(nums[1:dist + 2])
        right_set = SortedList()

        while len(left_set) > k:
            move_from_left_to_right()

        min_cost = current_sum 

        for i in range(dist + 2, len(nums)):
            outgoing_element = nums[i - dist - 1]
            if outgoing_element in left_set:
                left_set.remove(outgoing_element)
                current_sum -= outgoing_element
            else:
                right_set.remove(outgoing_element)

            incoming_element = nums[i]
            if left_set and incoming_element < left_set[-1]:
                left_set.add(incoming_element)
                current_sum += incoming_element
            else:
                right_set.add(incoming_element)

            while len(left_set) < k:
                move_from_right_to_left()
            while len(left_set) > k:
                move_from_left_to_right()

            min_cost = min(min_cost, current_sum)

        return min_cost
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(n log n)`

  * Each insertion/removal from `SortedList` costs `log n`
* **Space Complexity:** `O(dist)`

  * Storage for sliding window elements

## üß™ Edge Cases

* `k = 1` ‚Üí result is always `nums[0]`
* All elements equal
* Strictly increasing or decreasing arrays
* Very small `dist` values

```
