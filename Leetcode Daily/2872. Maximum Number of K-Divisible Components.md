# ğŸ· Count Subtrees with Sum Divisible by k (DFS on Tree)

# ğŸ“œ Problem Statement
Given `n` nodes (0..n-1), an edge list describing an undirected tree, a list `values` of node values, and an integer `k`, compute how many connected subtrees (rooted at DFS time) have a total sum divisible by `k`. The implementation performs a DFS from node 0, computes the subtree sum for each node, and increments a counter when a subtree's sum is divisible by `k`.

# ğŸ” Example Input/Output
Input:
```

n = 5
edges = [[0,1],[1,2],[1,3],[3,4]]
values = [2, 1, 3, 4, 2]
k = 3

```
Output (one possible result):
```

3

````
Explanation (one interpretation): subtree sums divisible by 3 could be at nodes whose subtree sums are 3, 6, 9, ... â€” the DFS counts each node whose subtree sum % 3 == 0.

# ğŸ§  Approach
1. Build an adjacency list for the undirected graph. The code assumes the edges form a connected tree and runs a DFS rooted at node `0`.
2. The DFS function `dfs(u, prev)`:
   - Starts with the node's own value `treeSum = values[u]`.
   - Recursively accumulates sums from child subtrees (`for v in graph[u]` skipping the parent).
   - After processing children, if `treeSum % k == 0`, increment the global counter `ans`.
   - Return `treeSum` so parent can include it in its subtree sum.
3. After building the graph, call `dfs(0, -1)` and return `ans`.
4. This effectively counts how many node-rooted subtrees (in the rooted-at-0 sense) have total sum divisible by `k`.

# ğŸ’» Code 
```python
class Solution:
  def maxKDivisibleComponents(
      self,
      n: int,
      edges: list[list[int]],
      values: list[int],
      k: int,
  ) -> int:
    ans = 0
    graph = [[] for _ in range(n)]

    def dfs(u: int, prev: int) -> int:
      nonlocal ans
      treeSum = values[u]

      for v in graph[u]:
        if v != prev:
          treeSum += dfs(v, u)

      if treeSum % k == 0:
        ans += 1
      return treeSum

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    dfs(0, -1)
    return ans
````

# â± Complexity Analysis

* **Time:** `O(n)` â€” each node and edge is visited once during the DFS.
* **Space:** `O(n)` â€” adjacency list and recursion stack (depth up to `n` in worst case).

# ğŸ§ª Edge Cases

* The code assumes the input graph is connected (a tree). If the graph has multiple components, only the component containing node `0` is explored â€” other components are ignored.
* Single-node tree (`n = 1`) â€” returns `1` if `values[0] % k == 0`, else `0`.
* Negative values: modulo behavior `treeSum % k` still works in Python but be mindful of negative sums and the intended definition of divisibility.
* Very deep trees may hit recursion limits â€” consider converting to iterative DFS or increasing recursion limit for very large `n`.
* If the problem intent is to count removable edges that partition the tree into components with sum divisible by `k`, additional logic would be needed (e.g., counting edges where child-subtree sum % k == 0 and potentially returning `ans - 1` depending on convention). This implementation counts subtree roots whose subtree sum is divisible by `k`.

```
```
