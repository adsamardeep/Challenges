# ğŸ· Maximum Sum Trionic Subarray

## ğŸ“œ Problem Statement
A **trionic subarray** consists of **three consecutive non-empty parts**:
1. A **strictly increasing** segment  
2. Followed by a **strictly decreasing** segment  
3. Followed by a **strictly increasing** segment  

Given an integer array `nums`, return the **maximum possible sum** of any trionic subarray.  
If no trionic subarray exists, return `0`.

---

## ğŸ” Example Input/Output
**Input**
```python
nums = [1, 3, 5, 4, 2, 6, 8]
````

**Output**

```python
29
```

**Explanation**

* Increasing: `1 â†’ 3 â†’ 5` (sum contribution optimized from left)
* Decreasing: `5 â†’ 4 â†’ 2`
* Increasing: `2 â†’ 6 â†’ 8`
* Best trionic sum = `29`

---

**Input**

```python
nums = [1, 2, 3]
```

**Output**

```python
0
```

(No decreasing segment â†’ not trionic)

---

## ğŸ§  Approach

This solution uses a **greedy expansion strategy** around a valid decreasing middle segment.

### High-level idea

1. Iterate through the array assuming index `i` lies in the **middle decreasing segment**
2. Expand rightward to capture the full **strictly decreasing** segment â†’ `net`
3. From the left boundary:

   * Expand leftward while values strictly increase
   * Track the **maximum prefix sum** (`lx`)
4. From the right boundary:

   * Expand rightward while values strictly increase
   * Track the **maximum suffix sum** (`rx`)
5. Combine:

   ```
   total trionic sum = lx + net + rx
   ```
6. Skip invalid configurations early for efficiency

This ensures:

* All three segments are **non-empty**
* Monotonicity is **strict**
* Sum is **maximized**

---

## ğŸ’» Code 

```python
class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        res = -float('inf')
        i = 1

        while i < n - 2:
            a = b = i
            net = nums[a]

            # strictly decreasing middle
            while b + 1 < n and nums[b + 1] < nums[b]:
                net += nums[b + 1]
                b += 1
            if b == a:
                i += 1
                continue

            c = b
            left = right = 0
            lx = rx = -float('inf')

            # strictly increasing left
            while a - 1 >= 0 and nums[a - 1] < nums[a]:
                left += nums[a - 1]
                lx = max(lx, left)
                a -= 1
            if a == i:
                i += 1
                continue

            # strictly increasing right
            while b + 1 < n and nums[b + 1] > nums[b]:
                right += nums[b + 1]
                rx = max(rx, right)
                b += 1
            if b == c:
                i += 1
                continue

            res = max(res, lx + rx + net)
            i = b

        return res if res != -float('inf') else 0
```

---

## â± Complexity Analysis

* **Time Complexity:** `O(n)`

  * Each index is visited a constant number of times due to pointer jumps
* **Space Complexity:** `O(1)`

  * Only scalar variables used

---

## ğŸ§ª Edge Cases

* No decreasing segment â†’ return `0`
* Flat elements (`nums[i] == nums[i+1]`) â†’ invalid (strict condition fails)
* Minimal length arrays (`n < 4`) â†’ cannot form trionic
* Multiple possible trionic segments â†’ best sum chosen

---
