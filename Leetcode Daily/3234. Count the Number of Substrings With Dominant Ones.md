# ðŸ· Count Substrings with Ones â‰¥ (Zeros)Â² (optimized zero-group scanning)

# ðŸ“œ Problem Statement
Given a binary string `s`, count the number of substrings where the number of `'1'` characters is **at least** the square of the number of `'0'` characters in that substring (i.e. `ones >= zeros * zeros`). The implementation avoids examining all O(nÂ²) substrings by grouping around zero positions and limiting how many zeros are considered per end index.

# ðŸ” Example Input/Output
Input:
```

s = "11010"

```
Output (example):
```

5

````
(There are 5 substrings whose count of '1's is â‰¥ (count of '0's)Â².)

# ðŸ§  Approach
1. Precompute `pre` where `pre[i]` stores an index to quickly jump to the previous "zero-start" boundary for substrings ending at positions up to `i-1`. This lets us iterate substrings grouped by how many zeros they include without scanning character-by-character for each substring.
2. For each end index `i` (1-based in the code), consider substrings that end at `i-1`. Start counting zeros `cnt0` from 1 if the character at `i-1` is `'0'` (otherwise 0), and move leftwards by jumping from one zero-boundary to the previous one using `pre[j]`.
3. Stop exploring larger zero-count candidates once `cnt0 * cnt0 > n` because you cannot have `ones >= zerosÂ²` if `zerosÂ²` already exceeds the whole string length.
4. For each candidate group (fixed end `i` and a left boundary group represented by `j`), compute the number of ones in that substring (`cnt1`) and check `cnt1 >= cnt0*cnt0`. If valid, add the number of distinct starting positions in that group that satisfy the inequality (computed with `min(j - pre[j], cnt1 - cnt0*cnt0 + 1)`).
5. Summing these contributions for every end index yields the final count.

# ðŸ’» Code
```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        pre = [-1] * (n + 1)
        for i in range(n):
            if i == 0 or s[i - 1] == "0":
                pre[i + 1] = i
            else:
                pre[i + 1] = pre[i]

        res = 0
        for i in range(1, n + 1):
            cnt0 = 1 if s[i - 1] == "0" else 0
            j = i
            while j > 0 and cnt0 * cnt0 <= n:
                cnt1 = (i - pre[j]) - cnt0
                if cnt0 * cnt0 <= cnt1:
                    res += min(j - pre[j], cnt1 - cnt0 * cnt0 + 1)
                j = pre[j]
                cnt0 += 1
        return res
````

# â± Complexity Analysis

* **Time Complexity:** `O(n * sqrt(n))` in practice. For each end index `i` we iterate over possible `cnt0` until `cnt0*cnt0 > n`, so inner loop is bounded by `O(âˆšn)`. Computing `pre` is `O(n)`.
* **Space Complexity:** `O(n)` for the `pre` array and a few scalars.

# ðŸ§ª Edge Cases

* Empty string `s = ""` â†’ returns `0`.
* All `'1'`s â†’ every substring has `zeros = 0`, and since `0Â² = 0`, all substrings count; result = `n*(n+1)/2`.
* All `'0'`s â†’ only substrings with `ones >= zerosÂ²` could be counted; with all zeros, `ones = 0`, so only substrings with `zeros = 0` (none) satisfy; result = `0`.
* Short strings where `n` is small â€” algorithm still correct and fast.
* Large `n` â€” the `cnt0` loop is limited by `cnt0*cnt0 <= n`, so it remains efficient compared to naive O(nÂ²) enumeration.

```
```
