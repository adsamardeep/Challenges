# Successful Pairs of Spells and Potions

üìú **Problem Statement**  
Given two arrays `spells` and `potions` and an integer `success`, for each spell `s` you must count how many potions `p` satisfy `s * p >= success`. Return a list `res` where `res[i]` is the number of potions that form a successful pair with `spells[i]`.

üîç **Example Input/Output**  
**Input**
    spells = [5,1,3]
    potions = [1,2,3,4,5]
    success = 7

**Output**
    [4,0,3]

**Explanation**
- For spell 5: need potions with `p >= ceil(7/5) = 2` ‚Üí potions {2,3,4,5} ‚Üí 4 pairs.
- For spell 1: need `p >= 7` ‚Üí none ‚Üí 0.
- For spell 3: need `p >= ceil(7/3) = 3` ‚Üí potions {3,4,5} ‚Üí 3 pairs.

üß† **Approach (step-by-step)**  
The provided solution builds a frequency prefix array of potion values (histogram + prefix sums) to allow O(1) queries for "how many potions ‚â• k":

1. Count frequencies of each potion value using `Counter`.
2. Let `pMax` be the maximum potion value present. Build an array `F` of length `pMax + 1` where `F[v]` = count of potions equal to `v`.
3. Turn `F` into prefix-sum `freq` (cumulative counts): after `freq = list(accumulate(F))`, `freq[v]` equals number of potions with value `‚â§ v`.
4. For each spell `x`, compute the minimal required potion `k = ceil(success / x) = (success + x - 1) // x`.
   - If `k > pMax` then there are `0` successful potions.
   - Otherwise the count of potions with value ‚â• `k` is `m - freq[k-1]`, where `m = len(potions)`.
5. Return the result list.

This trades off time for queries (O(1) per spell) at the cost of an array of size `pMax + 1`. It is very fast when `pMax` is not huge.

üíª **Code**  

    from typing import List
    from collections import Counter
    from itertools import accumulate

    class Solution:
        def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
            # Frequency map of potion values
            freq = Counter(potions)
            # maximum potion value present
            pMax = max(freq)  # assumes potions is non-empty per problem constraints
            # build histogram array indexed by potion value
            F = [0] * (1 + pMax)
            for p, f in freq.items():
                F[p] = f
            # prefix sums: freq[v] = number of potions with value <= v
            freq_prefix = list(accumulate(F))

            m = len(potions)
            res = [0] * len(spells)
            for i, x in enumerate(spells):
                # minimal potion value needed (ceil division)
                k = (success + x - 1) // x
                if k <= 0:
                    # every potion works (k <= 0 means success <= 0), so all m potions count
                    res[i] = m
                elif k <= pMax:
                    # potions with value >= k = total m - potions with value <= (k-1)
                    res[i] = m - freq_prefix[k - 1]
                else:
                    # k > pMax -> no potion is large enough
                    res[i] = 0
            return res

‚è± **Complexity Analysis**  
- Let `n = len(spells)`, `m = len(potions)`, and `P = pMax` (maximum potion value).
- **Time:**  
  - Building `Counter`: O(m).  
  - Building histogram `F` and prefix sums: O(P).  
  - Querying all spells: O(n) (each query O(1)).  
  - **Total:** O(m + P + n).
- **Space:** O(P) for the histogram/prefix array plus O(m) for the counter (aggregate O(P + m)).

üß™ **Edge Cases**  
- **Empty `potions`**: `max(freq)` will raise ‚Äî problem constraints usually guarantee non-empty potions; if not, handle explicitly by returning all zeros.  
- **Very large `pMax`**: If the maximum potion value is huge (e.g., up to 10‚Åπ), allocating `O(pMax)` memory is infeasible. In that case prefer an alternative:
  - **Sort + binary search:** sort `potions` O(m log m), then for each spell compute `k` and use `bisect_left` to find first index ‚â• `k` ‚Üí count = `m - idx`. This is O(m log m + n log m) time and O(1) extra space, and is robust for large potion values.
- **`success <= 0`**: every potion works; the code handles `k <= 0` by returning all potions.
- **Duplicates in `potions`**: handled efficiently by the frequency approach (and also by sorting method).
- **Non-positive `spells` or `potions`**: problem typically assumes positive integers; if zeros/negatives appear, treat `k` accordingly (ceil division logic above), but verify problem constraints.
