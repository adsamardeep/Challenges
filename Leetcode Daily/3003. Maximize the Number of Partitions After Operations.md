# Max Partitions After Operations (at-most-`k` distinct letters per group)

üìú **Problem Statement**  
Given a lowercase string `s` and an integer `k`, you want to partition `s` into as many contiguous groups as possible after performing the following grouping rule repeatedly: a group can contain at most `k` distinct letters. When constructing groups from left to right (or right to left), whenever adding the next character would make the group's distinct-letter count exceed `k`, you must start a new group.

The function should return the maximum number of groups (partitions) achievable by choosing an optimal split point that may combine left- and right-side groupings with possibly joining the middle characters into one or more groups, using the heuristic logic in the submitted approach.

üîç **What this code does (summary)**  
1. It encodes each character into a bit (26-bit mask).  
2. It scans left‚Üíright and computes, for every prefix length `L`,  
   - `prefix_count[L]`: how many *completed groups* were forced before (or at) that prefix when greedily forming groups left-to-right, and  
   - `prefix_mask[L]`: the bitmask of distinct letters in the *current (unfinished)* group at that prefix.  
   (Both arrays have length `n+1`, with index `0` representing the empty prefix.)  
3. It also scans right‚Üíleft and builds corresponding `suffix_count` / `suffix_mask` indexed by suffix length `R` (0..n).  
4. For each possible split after index `i` (i.e. left has length `L = i+1`, right has length `R = n-L`), it inspects:
   - how many groups were already completed on the left and right,
   - how many distinct letters are in the unfinished left group and the unfinished right group,
   - the combined distinct-letter mask if those two unfinished groups were merged,
   and then uses the same decision rules as the original to estimate how many extra groups the two unfinished pieces would contribute (1, 2, or 3), producing a candidate total partition count.  
5. The algorithm returns the maximum candidate over all splits.

üß† **Approach (explanation / reasoning)**  
- Greedy grouping (left‚Üíright) yields two pieces of information for any prefix: the number of groups already finalized (which cannot be increased by any later change) and the distinct-letter set of the currently open group. The same applies symmetrically for suffixes.  
- When combining the leftover (open) left-group and open right-group around a split, there are 3 possible outcomes for how many additional groups they create:
  1. They can merge into **one** valid group if the union of their distinct letters (plus optionally one more letter) still fits ‚â§ `k`.  
  2. They remain as **two** groups if merging would exceed `k` but neither individually forces more splits.  
  3. In some situations (the heuristic used here), they may contribute **three** groups (for example, when each side is already saturated at `k` distinct letters and merging produces a fresh split pattern).  
- This heuristic-based merging decision is captured by the `if/elif/else` branch in the code: it first checks if union fits `k` (yield 1 extra group), else if both sides are exactly saturated and union still has capacity to create more than two groups it yields 3, otherwise 2.

üíª **Code**  

    from typing import List

    class Solution:
        def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
            n = len(s)
            if n == 0:
                return 0
            if k <= 0:
                return 0

            # bit_mask for each character
            bit_masks = [1 << (ord(c) - 97) for c in s]

            # build prefix info: prefix_count[L], prefix_mask[L] for prefix of length L (0..n)
            def build_prefix_info(arr: List[int]):
                prefix_count = [0] * (n + 1)
                prefix_mask = [0] * (n + 1)
                mask = 0
                groups = 0
                for i in range(n):
                    mask |= arr[i]
                    if mask.bit_count() > k:
                        groups += 1
                        mask = arr[i]
                    prefix_count[i + 1] = groups
                    prefix_mask[i + 1] = mask
                return prefix_count, prefix_mask

            # build suffix info: suffix_count[R], suffix_mask[R] for suffix of length R (0..n)
            def build_suffix_info(arr: List[int]):
                suffix_count = [0] * (n + 1)
                suffix_mask = [0] * (n + 1)
                mask = 0
                groups = 0
                # iterate from right to left, length increases from 1..n
                for idx in range(n - 1, -1, -1):
                    mask |= arr[idx]
                    if mask.bit_count() > k:
                        groups += 1
                        mask = arr[idx]
                    length = n - idx
                    suffix_count[length] = groups
                    suffix_mask[length] = mask
                return suffix_count, suffix_mask

            prefix_count, prefix_mask = build_prefix_info(bit_masks)
            suffix_count, suffix_mask = build_suffix_info(bit_masks)

            res = 0
            # iterate possible split positions:
            # left length L runs from 1..n (split after index i -> L = i+1), right length R = n-L
            for L in range(1, n + 1):
                R = n - L
                left_groups = prefix_count[L]
                right_groups = suffix_count[R]
                left_mask = prefix_mask[L]
                right_mask = suffix_mask[R]
                combined_mask = left_mask | right_mask

                left_bits = left_mask.bit_count()
                right_bits = right_mask.bit_count()
                combined_bits = combined_mask.bit_count()

                # Decide how many extra groups the two open pieces contribute:
                #  - if union fits in k (or can be made to fit by shifting one boundary), they can form 1 group
                #  - else if both sides are saturated and union still not too large, treat heuristically as 3
                #  - otherwise treat as 2 groups
                if min(combined_bits + 1, 26) <= k:
                    extra = 1
                elif left_bits == right_bits == k and combined_bits < 26:
                    extra = 3
                else:
                    extra = 2

                total = left_groups + right_groups + extra
                if total > res:
                    res = total

            return res

‚è± **Complexity Analysis**  
- Let `n = len(s)`.  
- Building prefix and suffix arrays: O(n) time each, each step does a constant-time bit operation.  
- The main loop tries `n` split positions and does O(1) work per split.  
- **Overall time:** O(n).  
- **Space:** O(n) for the prefix/suffix arrays.

üß™ **Edge Cases**  
- `s` empty ‚Üí returns `0`.  
- `k <= 0` ‚Üí no valid groups ‚Üí returns `0`.  
- `k >= 26` (or large) ‚Üí every group can include all letters; result becomes `1` group if greedy merging produces single group, but with splitting logic you may get at most `n` trivial groups depending on implementation (here the greedy grouping will normally yield 1).  
- Very short strings (length 1 or 2) handled correctly by prefix/suffix arrays.  
- The heuristic for deciding `extra` groups around the split is problem-specific; if you need a proof/correctness guarantee for those 1/2/3 outcomes, we should formalize the merge cases more rigorously or replace the heuristic with an exact DP that considers all ways to split the middle zone.

