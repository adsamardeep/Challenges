# smallestSubarrays - Minimum Length Subarrays with Maximum Bitwise OR

## ðŸ“˜ Problem Statement

Given an integer array `nums`, for each index `i`, determine the **length of the smallest subarray** starting at `i` such that the **bitwise OR** of that subarray is **equal to the bitwise OR of the entire suffix starting at `i`**.

Return an array `result` where `result[i]` is the length of that subarray.

---

### âœ… Example

```python
Input:  nums = [1, 0, 2, 1, 3]
Output: [3, 3, 2, 2, 1]

# Explanation:
# Starting from index 0: OR(1,0,2) = 3 â†’ minimal subarray = length 3
# From index 1: OR(0,2,1) = 3 â†’ length 3
# From index 2: OR(2,1) = 3 â†’ length 2
# From index 3: OR(1,3) = 3 â†’ length 2
# From index 4: OR(3) = 3 â†’ length 1
```

---

## ðŸ§  Approach

This solution uses bitwise tracking to determine the farthest index needed for the OR result to be complete.

### Key Ideas:
- Track the **last seen position** of each of the 32 bits (0 to 31).
- Traverse from **right to left**, updating which index last had each bit set.
- For each position `i`, determine the **farthest index** required to include all necessary bits.
- The subarray length is `farthest - i + 1`.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n Ã— 32) = O(n) since 32 is constant (bit width of integers)
- **Space Complexity**: O(n + 32) = O(n)

Efficient for large arrays due to linear traversal and constant-width bit logic.

---

## ðŸ“„ Code

```python
from typing import List

class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n

        # Track the last index each bit was seen set
        latest = [-1] * 32

        # Traverse from right to left
        for i in range(n - 1, -1, -1):
            farthest = i

            # Update latest seen bits for nums[i]
            for b in range(32):
                if (nums[i] >> b) & 1:
                    latest[b] = i
                if latest[b] != -1:
                    farthest = max(farthest, latest[b])

            result[i] = farthest - i + 1

        return result
```

---

## ðŸ“‚ Usage

Useful in problems involving:
- **Bitmask compression**
- **Streaming OR analysis**
- **Suffix-based dynamic OR segment evaluation**

This technique efficiently handles **dynamic bit tracking** with minimal memory.
