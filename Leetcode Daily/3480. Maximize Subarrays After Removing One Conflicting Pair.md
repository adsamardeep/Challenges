# maxSubarrays - Maximize Count of Valid Subarrays with Conflict Pairs

## ðŸ“˜ Problem Statement

You are given:
- An integer `n` representing the length of an array `[1, 2, ..., n]`
- A list of **conflicting pairs** of indices `conflictingPairs`, where each pair `[a, b]` means **elements `a` and `b` cannot appear in the same subarray**

Your task is to compute the **maximum number of valid subarrays** (from index `1` to `n`) such that **no subarray includes both members of any conflict pair**. You are allowed to **remove at most one conflicting pair** to improve the result.

---

### âœ… Example
```python
Input:
n = 5
conflictingPairs = [[1, 3], [2, 4]]

Output: 14

# Explanation:
# Original max valid subarrays: 13
# After removing one conflict (e.g., [1,3]), gain 1 more â†’ total = 14
```

---

## ðŸ§  Approach

### Step-by-Step Strategy:

1. **Group conflict pairs** by their right endpoint:  
   `right[r]` contains all `l` values such that conflict `[l, r]` exists and `l < r`.

2. Use a **sliding window approach**:
   - Keep track of the two largest `l` values that define the current conflict restriction.
   - For each `r` in `1...n`, the number of valid subarrays ending at `r` is `r - left[0]`, where `left[0]` is the maximum forbidden start index due to a conflict.

3. **Compute bonus gain**:
   - For each conflict point, track the extra subarrays you could gain if that specific conflict were removed.
   - Store these potential gains in `bonus[]`.

4. **Final answer** = base score + best possible bonus

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n + m), where `m = len(conflictingPairs)`
- **Space Complexity**: O(n + m), for conflict lists and bonus tracking

---

## ðŸ“„ Code

```python
from typing import List

class Solution:
    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:
        
        # Group all `u` values by their `v` endpoint
        right = [[] for _ in range(n + 1)]
        for a, b in conflictingPairs:
            right[max(a, b)].append(min(a, b))
        
        ans = 0 
        left = [0, 0]  # top1 and top2
        bonus = [0] * (n + 1)
        
        for r in range(1, n + 1):
            for l in right[r]:
                if l > left[0]:
                    left = [l, left[0]]
                elif l > left[1]:
                    left = [left[0], l]
            
            ans += r - left[0]

            if left[0] > 0:
                bonus[left[0]] += left[0] - left[1]
        
        return ans + max(bonus)
```

---

## ðŸ“‚ Usage

This technique is useful for **conflict-aware interval calculations**, such as:
- Scheduling with exclusion constraints
- Maximizing subsequence counts under pairwise conditions
- Game logic involving unlockable paths with rule-breaking choices
