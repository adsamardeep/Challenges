# üè∑ Presence-aware mention counter (handles DIRECT, ALL, and HERE messages)

## üìú Problem Statement
Given `numberOfUsers` and a chronological list of `events` where each event is `[type, time, payload]`, compute for every user the total number of mentions they receive. Events include message events (type `"MESSAGE"`) whose payload can be:
- `"ALL"` ‚Äî a global mention for every user,
- `"HERE"` ‚Äî a mention that should count only for users who are currently present,
- `"ID{n}"` tokens ‚Äî direct mentions of a specific user `n`.
Other event types (any `type != "MESSAGE"`) are presence-change events for a single user: they schedule that user to be considered "absent" after 60 seconds. The function returns a list of mention counts per user.

## üîç Example Input/Output
**Input**
```python
numberOfUsers = 3
events = [
    ["MESSAGE", "1", "ALL"],        # everyone +1
    ["MESSAGE", "2", "ID0 ID2"],    # user0 +1, user2 +1
    ["LEAVE",   "3", "0"],          # user0 will be considered absent at time 63
    ["MESSAGE", "4", "HERE"],       # counts only for users currently present (on_c increments)
    ["MESSAGE", "65", "HERE"]       # by time 65 user0 is absent, so only users 1 & 2 get this HERE
]
````

**Output**

```python
[result_for_user0, result_for_user1, result_for_user2]
# e.g. [?, ?, ?]  (the function returns the integer mention counts per user)
```

(Explanation: `ALL` adds 1 to every user; `ID0 ID2` adds 1 to user0 and user2; `HERE` messages add to currently-present users ‚Äî presence events with a 60s timeout affect which users are counted for subsequent HERE messages.)

## üß† Approach

1. Sort events by time, and for tie-breaking put non-`MESSAGE` events before `"MESSAGE"` events that happen at the same timestamp (implemented by sorting key `(int(time), type == "MESSAGE")`).
2. Maintain:

   * `off`: a `deque` of scheduled "become absent" events stored as tuples `(expiry_time, user_id, l_on)` where `l_on` is the value of `on_c` when the schedule was created.
   * `point_c`: per-user counters for direct `"IDn"` mentions plus adjustments for presence-aware `"HERE"` messages.
   * `all_c`: counter of `"ALL"` messages (applies to every user at the end).
   * `on_c`: a running counter for how many `"HERE"` messages have occurred while a user is considered present.
3. When processing an event at time `t`, first pop any `off` entries whose expiry `<= t` and for each popped entry subtract from that user's `point_c` the number of `"HERE"` messages that happened after they were scheduled to be tracked (`point_c[id] -= on_c - l_on`). This effectively prevents counting HERE messages that occurred after the user was marked absent.
4. For a `"MESSAGE"` event:

   * For each token in the payload:

     * `"HERE"`: increment `on_c` (this global counter will be included in final counts for users still considered present);
     * `"ALL"`: increment `all_c`;
     * `"ID{n}"`: increment `point_c[n]` (direct per-user mention).
5. For a non-`"MESSAGE"` event, treat the payload as a user id and append `(t+60, user_id, on_c)` to `off` ‚Äî scheduling that user to be considered absent after 60 seconds relative to the event time.
6. After all events, process any remaining scheduled `off` entries (same subtraction) and finally build the result for each user as `point_c[i] + all_c + on_c` (each user gets the global `ALL` count and the cumulative `on_c` count of HERE messages that applied to them).
7. Return the per-user results.

## üíª Code 

```python
from typing import List
from collections import deque

class Solution:
    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:
        # sort events by time; if times equal, ensure presence events (non-MESSAGE) come before MESSAGE
        events.sort(key=lambda x: (int(x[1]), x[0] == "MESSAGE"))
        off = deque()                      # (expiry_time, user_id, l_on)
        point_c = [0] * numberOfUsers      # per-user direct counts and adjustments
        all_c = 0                          # count of "ALL" messages
        on_c = 0                           # count of "HERE" messages (global running)
        
        for m, t, ids in events:
            t = int(t)
            # apply scheduled expiries up to current time
            while off and off[0][0] <= t:
                _, uid, l_on = off.popleft()
                # remove the HERE messages that occurred after the user was scheduled to expire
                point_c[uid] -= on_c - l_on

            if m == "MESSAGE":
                # payload can contain multiple tokens separated by spaces
                for token in ids.split(' '):
                    if token == "HERE":
                        on_c += 1
                    elif token == "ALL":
                        all_c += 1
                    else:
                        # expects tokens like "ID{n}" where n is integer index
                        # strip leading non-digits (assumes format "ID<number>")
                        point_c[int(token[2:])] += 1
            else:
                # non-MESSAGE event: schedule this user to be considered absent after 60 seconds
                off.append((t + 60, int(ids), on_c))
        
        # process any remaining scheduled expiries
        while off:
            _, uid, l_on = off.popleft()
            point_c[uid] -= on_c - l_on

        # final result: direct counts + ALL messages + HERE messages that applied to each user
        return [c + all_c + on_c for c in point_c]
```

## ‚è± Complexity Analysis

* Time complexity: O(E + U) where E = number of events and U = number of tokens in message payloads (dominant factor is iterating events and tokens). Sorting events costs O(E log E).
* Space complexity: O(E + N) where N = `numberOfUsers` (for `off` deque in worst-case and `point_c` array).

## üß™ Edge Cases

* Payload token format: the code assumes direct mentions are of the form `"ID{n}"` and slices `token[2:]`; malformed tokens will raise `ValueError`.
* Multiple tokens per MESSAGE: supported by splitting `ids` on spaces.
* Duplicate building of presence schedules for the same user: each schedule is treated independently; overlapping schedules behave according to their expiry times.
* Events with identical timestamps: tie-breaking via sort key ensures presence events are processed before MESSAGEs at the same timestamp.
* Users never present: if a user never has presence scheduled, they still receive `ALL` and (depending on schedule) `HERE` counts as computed by `on_c`.
* Empty `events`: returns a list of zeros (only `all_c`/`on_c` are zero).
* Large times / many events: integer arithmetic is used; ensure `int` parsing of timestamps is valid.

```
```
