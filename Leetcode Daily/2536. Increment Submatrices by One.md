# ğŸ· Range Addition Queries on a 2D Matrix (2D difference array)

# ğŸ“œ Problem Statement
Given an `n x n` zero matrix and a list of rectangular `queries` where each query is `[r1, c1, r2, c2]`, apply +1 to every cell inside each inclusive rectangle. Return the final matrix after processing all queries efficiently.

# ğŸ” Example Input/Output
Input:
```

n = 3
queries = [[0,0,1,1], [1,1,2,2]]

```
Output:
```

[
[1,1,0],
[1,2,1],
[0,1,1]
]

````

# ğŸ§  Approach
1. Use a 2D difference array `diff` sized `(n+1) x (n+1)` so rectangle updates can be applied in `O(1)` per query:
   - For a query `(r1,c1,r2,c2)` do:
     ```
     diff[r1][c1] += 1
     diff[r2+1][c1] -= 1
     diff[r1][c2+1] -= 1
     diff[r2+1][c2+1] += 1
     ```
   This encodes the inclusive 2D range increment.
2. Build the resulting matrix `mat` by converting `diff` back to prefix sums. For each cell `(i,j)`:
````

mat[i][j] = diff[i][j] + mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]

````
(taking care of bounds when `i` or `j` is 0).
3. Return `mat`. Complexity: applying queries is `O(q)` and reconstructing the matrix is `O(n^2)`.

# ğŸ’» Code 
```python
class Solution:
 def rangeAddQueries(self, n: int, queries: list[list[int]]) -> list[list[int]]:
     diff = [[0] * (n + 1) for _ in range(n + 1)]
     
     for r1, c1, r2, c2 in queries:
         diff[r1][c1] += 1
         diff[r2 + 1][c1] -= 1
         diff[r1][c2 + 1] -= 1
         diff[r2 + 1][c2 + 1] += 1
     
     mat = [[0] * n for _ in range(n)]
     for i in range(n):
         for j in range(n):
             above = mat[i - 1][j] if i > 0 else 0
             left = mat[i][j - 1] if j > 0 else 0
             diag = mat[i - 1][j - 1] if i > 0 and j > 0 else 0
             mat[i][j] = diff[i][j] + above + left - diag
     return mat
````

# â± Complexity Analysis

* **Time:** `O(q + n^2)` where `q = len(queries)` (each query applied in O(1), then reconstruct the `n x n` matrix).
* **Space:** `O(n^2)` due to the `(n+1) x (n+1)` difference array and the `n x n` result matrix.

# ğŸ§ª Edge Cases

* `queries` is empty â†’ returns an all-zero `n x n` matrix.
* Queries touching the edges (`r2 == n-1` or `c2 == n-1`) are handled because `diff` is sized `n+1` so `r2+1`/`c2+1` are valid indices.
* Overlapping queries correctly accumulate because the difference array sums contributions.
* Very large `n` may be memory heavy (O(n^2) memory) â€” consider streaming or chunked approaches if memory is constrained.
* Invalid query coordinates (out of bounds or r1>r2/c1>c2) are not handled by this code â€” assume inputs are valid as per problem constraints.

```
```
