# ğŸ· Minimum Size of Set with Every Interval Intersecting by â‰¥2 Points (Greedy)

# ğŸ“œ Problem Statement
Given a list of closed integer intervals `intervals`, find the minimum size of a set `S` such that every interval contains at least two elements from `S`. Return the size of the smallest such set.

# ğŸ” Example Input/Output
Input:
```

intervals = [[1,3], [1,4], [2,5], [3,5]]

```
Output:
```

3

````
Explanation: One minimal set is `{2,3,5}`; each interval contains at least two of these elements.

# ğŸ§  Approach
1. Sort intervals by their right endpoint ascending; if ties, by left endpoint descending. This ordering lets us place points as far to the right as possible while keeping them useful for later intervals.
2. Maintain two variables `a` and `b` which are the two largest elements currently chosen in the set `S` (with `a < b`). Initially set to `-1`.
3. For each interval `[l, r]` in sorted order:
   - If `l > b`: current interval doesn't include either `a` or `b`. We must add two new points â€” choose `r-1` and `r` (the two rightmost points inside the interval). Increment answer by 2 and update `a = r-1, b = r`.
   - Else if `l > a`: interval includes `b` but not `a`. We need one more point â€” choose `r`. Increment answer by 1 and update `a = b, b = r`.
   - Else: interval already contains both `a` and `b`, no action needed.
4. After processing all intervals, `ans` is the minimum size of `S`.

This greedy works because choosing rightmost possible points maximizes reuse for subsequent intervals due to the sorting order.

#ğŸ’» Code 
```python
from typing import List

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[1], -x[0]))

        ans = 0
        a, b = -1, -1

        for l, r in intervals:
            if l > b:
                a = r - 1
                b = r
                ans += 2
            elif l > a:
                a = b
                b = r
                ans += 1

        return ans
````

# â± Complexity Analysis

* **Time:** `O(m log m)` for sorting plus `O(m)` for the scan, where `m = len(intervals)`. Overall `O(m log m)`.
* **Space:** `O(1)` extra space (ignoring input and sort overhead).

# ğŸ§ª Edge Cases

* Intervals that are nested or overlapping: handled by sort (ties broken by longer-left-first) and greedy placement.
* Intervals with width 1 (e.g., `[r, r]`): original problem guarantees feasibility; algorithm assumes it's possible to pick two elements per interval (so inputs should allow a solution).
* Single interval: algorithm picks two rightmost points inside it (if interval length â‰¥ 1).
* Many identical intervals: greedy reuses chosen points efficiently.
* Very large endpoints: algorithm uses only arithmetic on endpoints; no special memory concerns beyond sorting.

```
```
