# ğŸŸ© Problem: Make the Integer Zero

## ğŸ“œ Problem Statement
You are given two integers `num1` and `num2`.  

In one operation, you can subtract `num2` from `num1`. The goal is to determine the minimum number of operations `k` needed so that after exactly `k` subtractions, the remaining value of `num1 - k * num2` can be represented as a sum of **exactly `k` powers of two** (not necessarily distinct).  

If it is impossible, return `-1`.

---

## ğŸ” Example

Input:  
    num1 = 5, num2 = 2  

Process:  
- Try k = 1 â†’ x = 5 - 2*1 = 3.  
  - `x.bit_count() = 2`, but `k = 1 < 2` â†’ not valid.  
- Try k = 2 â†’ x = 5 - 2*2 = 1.  
  - `x.bit_count() = 1`, `k = 2 >= 1`, but `x < k` (1 < 2) â†’ invalid.  
- Try k = 3 â†’ x = 5 - 2*3 = -1 < 0 â†’ stop.  

Output:  
    -1  

---

## ğŸ§  Approach
1. Iterate over possible operation counts `k` from `1` to `60` (sufficient because `num1` fits within 64-bit).  
2. For each `k`, compute `x = num1 - num2 * k`.  
   - If `x < k`, then not possible (because `x` must be split into `k` parts, each â‰¥ 1).  
   - Check if `k >= x.bit_count()`.  
     - `x.bit_count()` gives the minimum number of powers of two required to represent `x`.  
     - If `k` is at least this number, it means we can break down `x` into exactly `k` powers of two.  
   - If valid, return `k`.  
3. If no valid `k` is found up to 60, return `-1`.

---

## ğŸ’» Code (indented inside single markdown block)
    class Solution:
        def makeTheIntegerZero(self, num1: int, num2: int) -> int:
            for k in range(1, 61):
                x = num1 - num2 * k
                if x < k:
                    return -1
                if k >= x.bit_count():
                    return k
            return -1

---

## â± Complexity Analysis
- **Time Complexity:** O(60) â‰ˆ O(1).  
  (Loop runs at most 60 iterations.)  
- **Space Complexity:** O(1).  

---

## ğŸ§ª Edge Cases
- `num1 < num2` â†’ may immediately return `-1` since subtraction overshoots.  
- `num1 = num2` â†’ check if it can be expressed with one power of two.  
- Very large `num1` (up to 10^9 or more) â†’ still works since the loop is capped at 60.  
- Cases where `num1 - num2*k` is negative â†’ skip because invalid.  
