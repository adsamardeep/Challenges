# ğŸ· Minimum One Bit Operations to Make Integers Zero

ğŸ“œ Problem Statement
Given an integer `n`, return the minimum number of operations required to transform it to `0`.  
An operation flips the lowest bit `1` in the binary representation of `n` and all bits to its right.  
The function effectively computes the number of Gray code transitions between `n` and `0`.

# ğŸ” Example Input/Output
Input:
```

n = 6

```
Output:
```

4

````
Explanation:  
Binary `6` (110) â†’ requires 4 bit operations to reach `000`.

# ğŸ§  Approach
1. The key observation is that this problem relates to **Gray code decoding**.
2. The Gray code to binary conversion formula is:  
   `binary = gray ^ (gray >> 1) ^ (gray >> 2) ^ ...`
3. This solution applies that principle in reverse â€” computing the cumulative XOR of `n` and its right shifts.
4. Iteratively XOR `res` with `n` and shift `n` right until `n` becomes 0.
5. The final `res` gives the minimum number of operations.

# ğŸ’» Code 
```python
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        res = 0
        while n:
            res ^= n
            n >>= 1
        return res
````

# â± Complexity Analysis

* **Time Complexity:** `O(log n)` â€” one iteration per bit of `n`.
* **Space Complexity:** `O(1)` â€” constant space used.

# ğŸ§ª Edge Cases

* `n = 0`: returns `0` immediately (no operations needed).
* `n = 1`: returns `1`.
* Large values of `n` (up to 2Â³Â¹ or beyond): handled efficiently since loop runs per bit.
* Powers of two (e.g., `n = 8`) â†’ ensure correctness for binary boundaries.

```
```
