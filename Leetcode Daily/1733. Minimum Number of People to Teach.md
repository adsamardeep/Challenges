# Minimum Number of Teachings

📜 **Problem Statement**  
Given `n` languages (numbered `1..n`), a list `languages` where `languages[i]` is the list of languages person `i+1` knows, and a list of friendship pairs `friendships` (1-based indices), determine the minimum number of people you must teach a **single** language (same language for everyone taught) so that every friendship pair shares at least one common language.

🔍 **Example Input/Output**  
**Input**
    n = 3
    languages = [[1], [2], [3]]        # person1 knows {1}, person2 {2}, person3 {3}
    friendships = [[1,2], [2,3]]      # edges: (1,2) and (2,3)

**Output**
    2

**Explanation:** Any choice of a single language requires teaching two people among the problematic ones to create shared languages across friendships.

🧠 **Approach (step-by-step)**  
1. Convert each person's language list to a `set` for O(1) membership checks.  
2. Iterate friendships and collect the set `need` of people who belong to at least one friendship that currently has **no** shared language. If `need` is empty, return `0`.  
3. Build `candidate_langs` as the union of languages known by people in `need`. Teaching any language not in `candidate_langs` would require teaching all people in `need` (count = `|need|`), so it's safe to only check `candidate_langs`.  
4. For each candidate language, count how many people in `need` **do not** know that language — that's the number you'd need to teach if you pick that language.  
5. Return the minimum count across candidate languages (or `|need|` if `candidate_langs` is empty).

💻 **Code**  
    from typing import List, Set

    class Solution:
        def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
            """
            Return minimum number of people to teach a single language so every friendship
            has at least one language in common.
            """
            # Convert each person's languages to a set for O(1) membership tests
            person_langs: List[Set[int]] = [set(lst) for lst in languages]

            # Find people involved in friendships that lack a common language
            need: Set[int] = set()
            for u, v in friendships:
                u -= 1  # convert to 0-based index
                v -= 1
                if not (person_langs[u].intersection(person_langs[v])):
                    need.add(u)
                    need.add(v)

            # If no problematic friendships, nothing to teach
            if not need:
                return 0

            # Candidate languages: languages known by people in `need`
            candidate_langs: Set[int] = set()
            for p in need:
                candidate_langs.update(person_langs[p])

            # If nobody in `need` knows any language, teaching any language requires teaching all in `need`
            if not candidate_langs:
                return len(need)

            # For each candidate language, count how many in `need` don't know it
            ans = len(need)  # upper bound
            for lang in candidate_langs:
                teach_count = 0
                for p in need:
                    if lang not in person_langs[p]:
                        teach_count += 1
                        if teach_count >= ans:  # early break
                            break
                ans = min(ans, teach_count)

            return ans

⏱ **Complexity Analysis**  
- Let `p = len(languages)` (people), `f = len(friendships)`, `L` = average languages per person, and `k = |need|`.  
- **Time:** O(pL + fL + |candidate_langs|·k).  
- **Space:** O(pL) for sets, O(k) for `need`, O(|candidate_langs|) for candidate languages.

🧪 **Edge Cases**  
- No friendships -> return `0`.  
- All friendships already share some language -> return `0`.  
- Some people have empty language lists.  
- No person in `need` knows any language -> must teach all in `need`.  
- Large `n` but few actual languages used -> optimization by restricting to `candidate_langs`.  
- Duplicate or reversed friendship pairs don’t affect correctness since `need` is a set.  
- Input friendships are 1-based (code adjusts to 0-based).
