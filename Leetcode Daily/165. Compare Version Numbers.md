# Compare Version Numbers

📜 **Problem Statement**  
Given two version strings `v1` and `v2` (dot-separated non-negative integer components, e.g. `"1.0.3"`), compare them and return:
- `1` if `v1` > `v2`
- `-1` if `v1` < `v2`
- `0` if they are equal after ignoring leading zeros and trailing zero components (e.g. `"1.0"` == `"1.0.0"`).

🔍 **Example Input/Output**  
```
    compareVersion("1.01", "1.001") -> 0
    compareVersion("1.0", "1.0.0")  -> 0
    compareVersion("0.1", "1.1")    -> -1
    compareVersion("1.0.1", "1")    -> 1
    compareVersion("7.5.2.4", "7.5.3") -> -1
```

🧠 **Approach (step-by-step)**  
1. Split each version string on `'.'` to get component strings.  
2. Convert each component to `int` to automatically handle leading zeros.  
3. Pad the shorter list of integer components with trailing zeros so both lists have equal length (or iterate up to `max(len1, len2)` using `0` when index is out-of-range).  
4. Compare corresponding integer components from left to right:
   - If at any index `a > b`, return `1`.
   - If `a < b`, return `-1`.
5. If all components are equal, return `0`.

This handles leading zeros (via `int()` conversion) and ignores insignificant trailing zero components by explicit padding/handling.

💻 **Code**  

    class Solution:
        def compareVersion(self, v1: str, v2: str) -> int:
            # Convert components to integer lists
            parts1 = [int(x) for x in v1.split('.')]
            parts2 = [int(x) for x in v2.split('.')]
    
            # Compare up to the longer length, using 0 for missing components
            n = max(len(parts1), len(parts2))
            for i in range(n):
                a = parts1[i] if i < len(parts1) else 0
                b = parts2[i] if i < len(parts2) else 0
                if a < b:
                    return -1
                if a > b:
                    return 1
            return 0

⏱ **Complexity Analysis**  
- Let `n1 =` number of components in `v1`, `n2 =` number in `v2`, and `n = max(n1, n2)`.  
- **Time:** O(n + L) where `L` is total length of the input strings (splitting + converting to int dominates). More simply O(n + total chars).  
- **Space:** O(n) for the lists of integer components.

🧪 **Edge Cases**  
- Leading zeros in components, e.g. `"1.01"` vs `"1.001"` — handled by `int()` conversion.  
- Trailing zero components, e.g. `"1.0"` vs `"1.0.0"` — treated equal.  
- Empty components are not valid per problem statement (assumes well-formed versions like `"1.0"`).  
- Very large component values — Python `int` handles arbitrary precision so comparisons remain correct.  
- One version shorter than the other — padding with zeros (or treating missing as 0) handles this.
