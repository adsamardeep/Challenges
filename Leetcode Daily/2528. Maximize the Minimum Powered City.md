# Title
Maximize Minimum Station Power (binary search + difference array)

##üìú Problem Statement
Given an array `stations` where `stations[i]` is the number of power stations at city `i`, a range `r` (each station contributes to positions within distance `r`), and `k` extra stations you may place anywhere, compute the maximum possible minimum "power" across all cities after placing up to `k` extra stations. Power at a city is the sum of stations within distance `r`.

##üîç Example Input/Output
Input:
```

stations = [1, 2, 4, 5, 0]
r = 1
k = 3

```
Output:
```

5

````

##üß† Approach
1. Convert `stations` into a difference array `df` so that prefix sums of `df` produce the current power at each city (taking the `r`-range into account).
2. Use binary search on the answer `mid` = candidate minimum power. The search range is from the current minimum city power up to a large upper bound.
3. For each `mid`, run a greedy check: iterate cities left‚Üíright maintaining the current running power (`cur`) and a working difference array copy `diff`. If `cur < mid`, place the required extra stations at the current position (increment `cnt` by `mid-cur`) and update `diff` to remove that added effect after its range (`i + 2*r`), since an added station affects up to `r` left and right of its position ‚Äî combined in this prefix-based scheme the effect lasts `2*r + 1` positions from where it's applied.
4. If the total added stations `cnt` exceeds `k`, `mid` is infeasible. Otherwise it's feasible.
5. Binary search to find the largest feasible `mid`.

##üíª Code (copy-paste ready)
```python
from typing import List
from itertools import accumulate

class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        # build difference array for range contributions of original stations
        df = [0] * (n + 5)
        for i, j in enumerate(stations):
            df[max(0, i - r)] += j
            df[min(n - 1, i + r) + 1] -= j

        # current minimum power across cities (prefix sums of df[0:n])
        lo = min(accumulate(df[:n]))
        hi = 2 * 10 ** 10

        def check(mid: int) -> bool:
            # working copy of the difference array (we'll mutate it)
            diff = df[:]  # length n+5 so indexing safe
            cur = 0
            cnt = 0
            for i in range(n):
                cur += diff[i]
                if cur < mid:
                    need = mid - cur
                    cnt += need
                    # place 'need' stations at position i (affects up to i + 2*r in this scheme)
                    end_idx = min(n - 1, i + 2 * r) + 1
                    diff[end_idx] -= need
                    cur = mid
                if cnt > k:
                    return False
            return True

        # binary search highest feasible mid
        while lo < hi:
            mid = (lo + hi + 1) >> 1
            if check(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo
````

##‚è± Complexity Analysis

* Time: `O(n * logW)` where `n = len(stations)` and `W` is the search space for the power (bounded by the chosen `hi`, effectively `log(max_possible_power)`); each feasibility `check` runs in `O(n)`.
* Space: `O(n)` for the difference arrays.

##üß™ Edge Cases

* `r = 0`: each station only affects its own city; algorithm still works (range degenerates).
* `k = 0`: no extra stations allowed ‚Äî returns the current minimum power.
* Very large `k`: result may grow large; binary search `hi` must be sufficiently large (code uses `2e10`).
* Single-city array (`n = 1`): handled correctly.
* All-zero initial stations: adds will be placed greedily; still works.
* Be mindful of integer overflow in other languages (Python handles large ints).

```
```
