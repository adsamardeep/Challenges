# ğŸ· Number of ways to divide a corridor into valid seat sections

## ğŸ“œ Problem Statement
Given a string `corridor` consisting of `'S'` (seats) and `'P'` (plants), determine the number of ways to divide the corridor into sections such that **each section contains exactly two seats**. Dividers can be placed between characters, and the result must be returned modulo `10^9 + 7`.

## ğŸ” Example Input/Output
**Input:**  
```python
corridor = "SSPPSPS"
````

**Output:**

```python
3
```

**Explanation:**
There are three valid ways to place dividers so that every segment contains exactly two `'S'` characters.

**Input:**

```python
corridor = "SPS"
```

**Output:**

```python
0
```

(Explanation: The total number of seats is odd, so itâ€™s impossible to form sections with exactly two seats.)

## ğŸ§  Approach

1. Count the total number of seats in the corridor.

   * If there are no seats or the number of seats is odd, return `0` immediately.
2. Traverse the corridor character by character, keeping track of:

   * `seat`: number of seats encountered in the current segment,
   * `plant`: number of plants after exactly two seats have been seen.
3. Every time a third seat is encountered:

   * It means a new section must start,
   * The number of ways to place a divider before this new section is `(plant + 1)`,
   * Multiply the answer by `(plant + 1)` and reset counters.
4. Continue this process until the end of the corridor.
5. The accumulated product gives the total number of valid ways, taken modulo `10^9 + 7`.

## ğŸ’» Code 

```python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        mod = 10**9 + 7

        total_seats = corridor.count("S")
        if total_seats == 0 or total_seats % 2 == 1:
            return 0

        ans = 1
        seat = 0
        plant = 0

        for c in corridor:
            if c == "S":
                if seat == 2:
                    ans = ans * (plant + 1) % mod
                    plant = 0
                    seat = 0
                seat += 1
            else:  
                if seat == 2:
                    plant += 1

        return ans
```

## â± Complexity Analysis

* Time complexity: **O(n)**, where `n` is the length of the corridor string.
* Space complexity: **O(1)**, using only a few integer counters.

## ğŸ§ª Edge Cases

* No seats in the corridor â†’ returns `0`.
* Odd number of seats â†’ returns `0`.
* Exactly two seats and no plants â†’ returns `1` (only one valid section).
* Large input string â†’ handled efficiently due to linear scan and constant space.
* Multiple plant sequences between seat pairs â†’ correctly counted via `(plant + 1)` multiplier.

```
```
