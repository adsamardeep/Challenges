# Triangular Sum (Binomial Coefficient Method)

📜 **Problem Statement**  
Given an array `nums`, repeatedly replace the array by the array of adjacent sums modulo 10 until only one element remains; return that final element.  
Equivalently, for `m = len(nums)` the result equals the sum `Σ_{k=0..m-1} C(m-1, k) * nums[k]` taken modulo 10. This implementation computes that binomial-weighted sum directly in O(m) time.

🔍 **Example Input/Output**  
**Input**
    nums = [1, 2, 3, 4]
**Output**
    0

**Explanation**  
Iterative reduction: [1,2,3,4] → [3,5,7] → [8,2] → [0].  
Using binomials with n = 3: 1·1 + 3·2 + 3·3 + 1·4 = 20 → 20 % 10 = 0.

🧠 **Approach (step-by-step)**  
1. Let `m = len(nums)` and `n = m - 1`. The final triangular value equals `Σ_{k=0..n} C(n,k) * nums[k]` (binomial coefficients).  
2. Initialize `ans = nums[0]` (accounts for `C(n,0) = 1`) and `A = 1` as the running binomial `C(n,0)`.  
3. For each `k` from `1` to `n`:
   - Update the binomial coefficient with the exact integer formula `A = A * (n - k + 1) // k` which yields `C(n,k)` without floating error.
   - Accumulate `ans = (ans + nums[k] * A) % 10`. Using `% 10` keeps numbers small and matches problem's modulo behavior.
4. Return `ans`. This runs in linear time and constant extra space.

💻 **Code**  

    from typing import List

    class Solution:
        def triangularSum(self, nums: List[int]) -> int:
            n = len(nums) - 1
            ans, A = nums[0], 1
            for k in range(1, n + 1):
                # exact integer update to next binomial coefficient C(n, k)
                A = A * (n - k + 1) // k
                ans = (ans + nums[k] * A) % 10
            return ans

⏱ **Complexity Analysis**  
- Let `m = len(nums)`.  
- **Time:** O(m) — one pass to compute successive binomial coefficients and accumulate the sum.  
- **Space:** O(1) extra space (in-place accumulation, a few integers only).

🧪 **Edge Cases**  
- `m = 0` (empty list): problem typically assumes `m >= 1`. If empty input might occur, handle explicitly (e.g., return `0` or raise).  
- `m = 1`: returns `nums[0] % 10` (the loop body is skipped).  
- Negative numbers in `nums`: final modulo is computed with Python's `% 10`, so negative contributions are converted to the `0..9` range correctly. If you prefer non-negative intermediate sums, apply `% 10` to `nums[k]` when using them.  
- Very large `m`: the intermediate `A` values are exact integers (binomials) and can grow large, but Python handles big integers. If you want to avoid large integers entirely, you can reduce `A` modulo 10 at each step — however, because division by `k` is involved when computing `C(n,k)` iteratively, reducing `A` modulo 10 before the division is not directly possible without modular inverses (and 10 is not prime). The current integer method is safe and simple for typical constraints.
