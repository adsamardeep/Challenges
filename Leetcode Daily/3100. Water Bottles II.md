# Maximum Bottles Drunk with Increasing Exchange Requirement

üìú **Problem Statement**  
You start with `numBottles` full bottles of water. After drinking each bottle, you get an empty one. Initially, you can exchange `numExchange` empty bottles for 1 new full bottle. After each exchange, the number of empty bottles required for the next exchange increases by 1. Return the maximum number of bottles you can drink.

üîç **Example Input/Output**  
**Input**  
    numBottles = 13
    numExchange = 6

**Output**  
    15

**Explanation**  
- Drink 13 bottles ‚Üí 13 empties.  
- Exchange 6 empties for 1 full ‚Üí drink it (total 14 drunk). Now need 7 empties for next exchange. Empties left = 8.  
- Exchange 7 empties for 1 full ‚Üí drink it (total 15 drunk). Now need 8 empties. Empties left = 2.  
- Not enough empties for further exchange.  
Final answer = 15.

üß† **Approach (step-by-step)**  
1. Initialize `bottleDrunk = numBottles` and `emptyBottles = numBottles` since you drink all initially.  
2. While you have at least `numExchange` empty bottles:  
   - Use up `numExchange` empties to get 1 full.  
   - Increment `numExchange` (since each exchange requires one more bottle than the previous).  
   - Drink the new bottle ‚Üí increment `bottleDrunk`.  
   - Add 1 to `emptyBottles` (since drinking produces one empty).  
3. Continue until `emptyBottles < numExchange`.  
4. Return `bottleDrunk`.

üíª **Code**  

    class Solution:
        def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
            bottleDrunk = numBottles
            emptyBottles = numBottles

            while emptyBottles >= numExchange:
                emptyBottles -= numExchange    # use empties for exchange
                numExchange += 1              # next exchange needs more bottles
                bottleDrunk += 1              # drink the new bottle
                emptyBottles += 1             # get 1 empty after drinking

            return bottleDrunk

‚è± **Complexity Analysis**  
- **Time Complexity:** O(k), where `k` is the number of exchanges possible (bounded by `numBottles`).  
- **Space Complexity:** O(1), only a few variables.

üß™ **Edge Cases**  
- `numBottles < numExchange`: no exchanges possible, result = `numBottles`.  
- `numBottles = numExchange`: exactly one exchange possible initially.  
- Large `numBottles` (e.g., 10^9): loop runs at most `numBottles` iterations, but practically much fewer because `numExchange` grows each time.  
- `numExchange = 1` ‚Üí every empty bottle gives 1 new bottle, but requirement increases each time. Still terminates properly.  
