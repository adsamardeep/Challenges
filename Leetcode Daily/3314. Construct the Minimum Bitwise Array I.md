# ğŸ· Minimum Bitwise Array Transformation

## ğŸ“œ Problem Statement
Given an array of integers `nums`, construct a new array where each element is transformed using a specific bitwise rule.  
For each number:
- If it is **even**, the result is `-1`
- If it is **odd**, clear a specific bit to produce the minimum possible value under the rule

Return the transformed array.

## ğŸ” Example Input/Output
**Input**
```python
nums = [1, 3, 4, 7]
````

**Output**

```python
[0, 1, -1, 3]
```

**Explanation**

* `1 (001)` â†’ odd â†’ result `0`
* `3 (011)` â†’ odd â†’ result `1`
* `4 (100)` â†’ even â†’ `-1`
* `7 (111)` â†’ odd â†’ result `3`

## ğŸ§  Approach

### Key Insight

* Even numbers are immediately invalid â†’ return `-1`
* For odd numbers:

  * `(n + 1) & ~n` isolates the **lowest zero bit above trailing ones**
  * Shifting right by 1 gives the bit to be cleared
  * `n & ~bit` clears that bit, yielding the minimum valid value

### Steps

1. Iterate through each number in `nums`
2. If the number is even, append `-1`
3. If the number is odd:

   * Compute the target bit using bitwise operations
   * Clear it and append the result
4. Return the resulting list

## ğŸ’» Code 

```python
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            if n & 1:
                res.append(n & ~(((n + 1) & ~n) >> 1))
            else:
                res.append(-1)
        return res
```

## â± Complexity Analysis

* **Time Complexity:** `O(n)` where `n` is the length of `nums`
* **Space Complexity:** `O(n)` for the result array

## ğŸ§ª Edge Cases

* All numbers even â†’ result is all `-1`
* Single-element array
* Large odd numbers with many trailing `1` bits
* `n = 1` (smallest odd number)

```
```
