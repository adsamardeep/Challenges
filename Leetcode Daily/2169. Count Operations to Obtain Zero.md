# ðŸ· Count Operations to Make Two Integers Zero (Recursive Euclidean Approach)

# ðŸ“œ Problem Statement
Given two non-negative integers `x` and `y`, repeatedly perform the operation `x, y = y, x % y` while adding `x // y` to a counter each time, until one of the numbers becomes zero.  
Return the total number of operations performed. This is conceptually similar to counting the steps in the Euclidean algorithm for finding the GCD, but counting the number of division-based reductions.

# ðŸ” Example Input/Output
Input:
```

x = 10
y = 6

```
Output:
```

3

````
Explanation:  
- Step 1: (10,6) â†’ 10//6 = 1  
- Step 2: (6,4) â†’ 6//4 = 1  
- Step 3: (4,2) â†’ 4//2 = 2  
Total = 1 + 1 + 2 = 4 operations.

# ðŸ§  Approach
1. Base case: if `y == 0`, no more operations can be done â†’ return `0`.
2. Otherwise, at each step add `x // y` (how many times `y` fits into `x`) to the result.
3. Recursively call the function with swapped arguments `(y, x % y)`, mimicking the Euclidean GCD reduction process.
4. The recursion naturally terminates when `y` becomes 0.

# ðŸ’» Code 
```python
class Solution:
    def countOperations(self, x: int, y: int) -> int:
        return 0 if y == 0 else x // y + self.countOperations(y, x % y)
````

# â± Complexity Analysis

* **Time Complexity:** `O(log(min(x, y)))` â€” same as the Euclidean algorithm for GCD.
* **Space Complexity:** `O(log(min(x, y)))` â€” due to recursive call stack.

# ðŸ§ª Edge Cases

* `x = 0, y = 0`: returns `0` (no operations).
* `x = 0, y > 0`: returns `0` (since division by zero avoided).
* `x < y`: still valid; `x // y` = 0 for the first call, recursion swaps values.
* Large `x, y`: recursion depth remains small (logarithmic).

```
```
