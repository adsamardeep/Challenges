# ğŸŒ³ Balanced Binary Tree Check

## ğŸ“œ Problem Statement
Given the root of a binary tree, determine if it is **height-balanced**.

A binary tree is balanced if:
> For every node, the height difference between its left and right subtrees is **at most 1**.

Return `True` if the tree is balanced, otherwise return `False`.

---

## ğŸ” Example Input/Output
**Input**
```

```
3
```

/ 
9  20
/ 
15  7

````

**Output**
```python
True
````

**Input**

```
    1
   /
  2
 /
3
```

**Output**

```python
False
```

---

## ğŸ§  Approach

This solution uses **post-order DFS** with early termination.

### Key Idea

* Instead of computing height separately, return:

  * **height** if subtree is balanced
  * **-1** if subtree is unbalanced
* The `-1` value propagates upward immediately, avoiding unnecessary work.

### Steps

1. Recursively compute left subtree height
2. If left is unbalanced â†’ return `-1`
3. Recursively compute right subtree height
4. If right is unbalanced â†’ return `-1`
5. If height difference > 1 â†’ return `-1`
6. Otherwise return `1 + max(left, right)`

---

## ğŸ’» Code 

```python
# py3
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(node):
            if not node:
                return 0
            
            left = dfs(node.left)
            if left == -1:
                return -1
            
            right = dfs(node.right)
            if right == -1:
                return -1
            
            if abs(left - right) > 1:
                return -1
            
            return 1 + max(left, right)
        
        return dfs(root) != -1
```

---

## â± Complexity Analysis

* **Time Complexity:** `O(n)` â€” each node is visited once
* **Space Complexity:** `O(h)` â€” recursion stack, where `h` is tree height

---

## ğŸ§ª Edge Cases

* Empty tree â†’ balanced
* Single node â†’ balanced
* Skewed tree â†’ unbalanced
* Large tree with early imbalance â†’ fast exit ğŸš€

---

