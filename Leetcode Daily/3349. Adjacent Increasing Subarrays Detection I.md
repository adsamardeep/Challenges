# Check for Two Non-overlapping Increasing Subarrays of Length k

ğŸ“œ **Problem Statement**  
Given an integer array `nums` and integer `k`, determine whether it is possible to pick **two non-overlapping** strictly increasing contiguous subarrays **each of length `k`**. Subarrays may be adjacent (the end of the first can be immediately before the start of the second) but must not overlap.

This algorithm returns `True` when such a pair exists, otherwise `False`.

ğŸ” **Example Input / Output**  
**Example 1**
    nums = [1,2,3,4,5], k = 2
**Output**
    True
**Why:** You can pick [1,2] and [3,4] (or many other pairs).

**Example 2**
    nums = [1,2,1,2,1], k = 2
**Output**
    False
**Why:** There are increasing runs of length 2 but none allow two non-overlapping increasing subarrays of length 2 (no two runs of length â‰¥2 adjacent or a single run of length â‰¥4).

ğŸ§  **Approach (step-by-step)**  
1. Scan the array leftâ†’right, maintaining the length `inc` of the current strictly increasing run (number of elements in the current run).  
2. When the run breaks (`nums[i] <= nums[i-1]`) save the previous run length in `prevInc` and reset `inc = 1`. Otherwise increment `inc`.  
3. After each step compute the best possibility at this boundary/index:
   - If a single run is long enough that it can be split into two disjoint length-`k` increasing subarrays, then `inc // 2 >= k` is sufficient (a run of length `2k` contains two back-to-back subarrays of length `k`).  
   - If there are two consecutive runs (the previous run and the current run) then having both at least `k` gives `min(prevInc, inc) >= k`.  
4. Track the maximum of these two checks as you scan; if at any point it reaches or exceeds `k`, return `True`. If the scan finishes without finding such a configuration, return `False`.

This results in a single pass O(n) solution using O(1) extra space.

ğŸ’» **Code**  

    from typing import List

    class Solution:
        def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
            inc = 1          # current run length (counts elements)
            prevInc = 0      # previous run length when a run breaks
            maxLen = 0       # tracks best possible k achievable so far

            for i in range(1, len(nums)):
                if nums[i] > nums[i - 1]:
                    inc += 1
                else:
                    prevInc = inc
                    inc = 1

                # Two possibilities at any point:
                # 1) single long run can be split into two length-k runs -> inc // 2
                # 2) two adjacent runs both have length >= k -> min(prevInc, inc)
                maxLen = max(maxLen, max(inc >> 1, min(prevInc, inc)))
                if maxLen >= k:
                    return True
            return False

â± **Complexity Analysis**  
- **Time:** O(n) â€” single pass through `nums`.  
- **Space:** O(1) â€” constant extra memory.

ğŸ§ª **Edge Cases**  
- `k <= 0` â€” by problem semantics `k` should be â‰¥ 1; if `k <= 0` you may treat as always `True`.  
- `len(nums) < 2*k` â€” impossible to have two disjoint subarrays of length `k` unless runs overlap; algorithm will correctly return `False`.  
- Strictly increasing long array â€” handled by the `inc // 2` branch (a single long run can yield two subarrays).  
- Adjacent runs separated by a single non-increasing point â€” handled because `prevInc` is recorded at the break and compared to the new `inc`.  
- Repeated numbers or non-increasing sections correctly reset runs.  
