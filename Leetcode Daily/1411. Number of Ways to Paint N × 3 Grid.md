# üè∑ Number of Ways to Paint an n√ó3 Grid with 3 Colors

## üìú Problem Statement
Given an integer `n`, representing the number of rows in a 3-column grid, count the number of ways to paint the grid using 3 colors such that no two adjacent cells (horizontally or vertically) have the same color. Return the result modulo `10^9 + 7`.

## üîç Example Input/Output
**Input:**
```python
n = 1
````

**Output:**

```python
12
```

**Input:**

```python
n = 2
```

**Output:**

```python
54
```

## üß† Approach

1. Observe that each row can be painted in two valid pattern types:

   * **Type X (ABC)**: All three cells have different colors.
   * **Type Y (ABA)**: First and third cells have the same color, middle is different.
2. For the first row:

   * There are `6` ways for Type X.
   * There are `6` ways for Type Y.
3. For each subsequent row:

   * A new **Type X** row can be formed from:

     * `3 * x` ways from previous Type X
     * `2 * y` ways from previous Type Y
   * A new **Type Y** row can be formed from:

     * `2 * x` ways from previous Type X
     * `2 * y` ways from previous Type Y
4. Use dynamic programming to iteratively update counts for each row.
5. The final answer is the sum of both pattern counts after `n` rows.

This reduces the problem to constant-space DP.

## üíª Code 

```python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 1000000007
        x, y = 6, 6
        
        for i in range(2, n + 1):
            new_x = (3 * x + 2 * y) % MOD
            new_y = (2 * x + 2 * y) % MOD
            x, y = new_x, new_y
        
        return (x + y) % MOD
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(n)`
  One iteration per row.
* **Space Complexity:** `O(1)`
  Only constant variables are used.

## üß™ Edge Cases

* `n = 1` (base case with direct initialization)
* Very large `n` (handled via modulo arithmetic)
* Ensures no adjacent cells share the same color

```
```
