# 🟩 Problem: Minimum Sum of Rectangles to Cover All 1’s

## 📜 Problem Statement
You are given a binary matrix `A` of size `n × m`.  
Partition the matrix into **3 rectangles** (by straight horizontal/vertical cuts).  
For each rectangle, consider the **minimum bounding rectangle** that covers all `1`s within that region; its **area** is counted toward the cost.  
Return the **minimum possible sum of areas** over all ways to split into 3 rectangles.  
If a region contains no `1`, its area contributes `0`.

---

## 🔍 Example 1
**Input**
    A = [
      [0,1,0],
      [1,1,1],
      [0,1,0]
    ]

**Explanation**  
One optimal partition is:
- Top rectangle covers the first row.  
- Bottom part is split into two rectangles.  
- Total minimum sum of areas = **9**

**Output**
    9

---

## 🔍 Example 2
**Input**
    A = [
      [1,0,1],
      [1,1,0],
      [0,1,1]
    ]

**Output**
    12

---

## 🧠 Approach
1. We must create **3 non-overlapping rectangles** that cover the whole matrix when combined via two straight cuts.
2. For a fixed orientation, try:
   - First **horizontal** cut at row `i`: region 1 = `A[:i]`.
     - Then split the remaining bottom part either:
       - **Vertically** at each column `j`, or
       - **Horizontally** at each row `i2` (with `i < i2 < n`).
   - For each of the 3 regions formed, compute the **minimum bounding rectangle area** of the `1`s inside that region (0 if none).
   - Track the minimal sum across all splits.
3. To cover symmetric cases, **rotate** the matrix 90° and repeat (total 4 orientations).
4. Return the best (minimum) sum found.

---

## 💻 Code Implementation
    from typing import List

    class Solution:
        def minimumSum(self, A: List[List[int]]) -> int:
            res = float("inf")
            for _ in range(4):  # Try all 4 orientations
                n, m = len(A), len(A[0])
                for i in range(1, n):  # First horizontal cut
                    a1 = self.minimumArea(A[:i])
                    # Split bottom part into 2 vertical rectangles
                    for j in range(1, m):
                        part2 = [row[:j] for row in A[i:]]
                        part3 = [row[j:] for row in A[i:]]
                        a2 = self.minimumArea(part2)
                        a3 = self.minimumArea(part3)
                        res = min(res, a1 + a2 + a3)
                    # Split bottom part into 2 horizontal rectangles
                    for i2 in range(i + 1, n):
                        part2 = A[i:i2]
                        part3 = A[i2:]
                        a2 = self.minimumArea(part2)
                        a3 = self.minimumArea(part3)
                        res = min(res, a1 + a2 + a3)
                A = self.rotate(A)  # Rotate for different orientation
            return res

        def minimumArea(self, A: List[List[int]]) -> int:
            if not A or not A[0]:
                return 0
            n, m = len(A), len(A[0])
            left, top, right, bottom = float("inf"), float("inf"), -1, -1
            for i in range(n):
                for j in range(m):
                    if A[i][j] == 1:
                        left = min(left, j)
                        top = min(top, i)
                        right = max(right, j)
                        bottom = max(bottom, i)
            if right == -1:  # No 1's
                return 0
            return (right - left + 1) * (bottom - top + 1)

        def rotate(self, A: List[List[int]]) -> List[List[int]]:
            n, m = len(A), len(A[0])
            return [[A[i][j] for i in range(n-1, -1, -1)] for j in range(m)]

---

## ⏱ Complexity Analysis
- **Time Complexity:**  
  O(4 × (n² × m + n × m²)) → For each rotation, we try all first cuts and all second cuts in both directions; each area computation scans its region.
- **Space Complexity:** O(n × m) for constructing rotated/partitioned slices (can be optimized with prefix bounds if needed).

---

## 🧪 Edge Cases
- All zeros → answer is `0`.  
- Single `1` anywhere → must appear in one region; area is the bounding box of that region’s `1`s (at least `1`).  
- All ones → optimal is to split the full grid into 3 rectangles; sum depends on cut positions.  
- Very sparse `1`s → some regions may contribute `0` if they contain no `1`s.
