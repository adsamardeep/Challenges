# 💡 Problem: Reordered Power of 2

## 📜 Problem Statement
Given an integer `n`, determine whether its digits can be **rearranged** to form a power of two.  

You may reorder the digits in any way, but all digits must be used exactly once (leading zeros are not allowed).

---

## 🔍 Example 1
**Input**
```
n = 46
```
**Output**
```
True
```
**Explanation**
```
46 → rearrange to 64
64 = 2^6
```

---

## 🔍 Example 2
**Input**
```
n = 10
```
**Output**
```
False
```
**Explanation**
```
Possible rearrangements: 01, 10 → neither is a power of two
```

---

## 🧠 Approach
1. **Digit Signature**  
   - For a given number, its "digit signature" is obtained by sorting its digits as a string.  
     Example:  
     ```
     128 → "128"
     281 → "128"
     2^7 = 128 → "128"
     ```
     All have the same signature.

2. **Precompute Power of Twos**  
   - All powers of two below `2^30` (≈ 1 billion) have unique signatures.
   - Compare the sorted digits of `n` with each power of two's sorted digits.

3. **Check Matches**  
   - If any power of two shares the same signature as `n`, return `True`.

---

## 💻 Code Implementation
```python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        def count_digits(x):
            return ''.join(sorted(str(x)))

        target = count_digits(n)
        
        for i in range(31):  # 2^0 to 2^30 fits in 32-bit int
            if count_digits(1 << i) == target:
                return True
        return False
```

---

## ⏱ Complexity Analysis
- **Time Complexity:** O(31 × d log d)  
  - `d` = number of digits in the largest power of two (~10 digits for 2^30)
  - Essentially constant for given constraints.
- **Space Complexity:** O(1)  
  - Only small fixed-size strings are stored.

---

## 🧪 Edge Cases
- `n` is itself a power of two → returns True
- `n` has same digits as a power of two but in different order → returns True
- Leading zero permutations are ignored automatically by sorted comparison
