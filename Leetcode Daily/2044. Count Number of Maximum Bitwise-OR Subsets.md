# countMaxOrSubsets - Count Subsets with Maximum Bitwise OR

## ðŸ“˜ Problem Statement

Given an integer array `a`, return the **number of subsets** whose **bitwise OR** is equal to the **maximum possible bitwise OR** of any subset.

---

### âœ… Example
```python
Input:  a = [3, 1]
Output: 2

# Explanation:
# Subsets: [3], [1], [3,1]
# OR values: 3, 1, 3 â†’ maximum is 3
# Subsets with OR = 3 â†’ [3], [3,1] â†’ count = 2
```

---

## ðŸ§  Approach

This solution uses a **recursive lambda function with short-circuit evaluation** to:
1. Explore all possible subsets by including or excluding each element.
2. Count how many of those subsets achieve the **maximum OR value**, computed with `reduce(or_, a)`.

### Core Logic:
```python
(f := lambda i, o, O=reduce(or_, a):
     a[i:] and f(i+1, o) + f(i+1, o | a[i]) or o == O)(0, 0)
```

- `i` is the current index
- `o` is the OR value accumulated so far
- `O` is the overall maximum OR possible (computed once)
- Recursively try:
  - Skipping the current element
  - Including the current element
- Base case: return 1 if current OR equals maximum OR `O`

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(2â¿) â€” all subsets explored (n = len(a))
- **Space Complexity**: O(n) â€” recursive call stack

Note: Although the code is concise and elegant, itâ€™s best suited for small arrays (typically n â‰¤ 15â€“20).

---

## ðŸ“„ Code

```python
from typing import List
from functools import reduce
from operator import or_

class Solution:
    def countMaxOrSubsets(self, a: List[int]) -> int:
        return (f := lambda i, o, O=reduce(or_, a):
                    a[i:] and f(i+1, o) + f(i+1, o | a[i]) or o == O
               )(0, 0)
```

---

## ðŸ“‚ Usage

This function is useful in **bitmask-based combinatorial analysis**, **signal aggregation**, or **logical circuit optimization** scenarios where OR-based evaluation across subsets is needed.
