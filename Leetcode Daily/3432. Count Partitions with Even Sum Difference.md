# ğŸ· Count Partitions Where Left and Right Halves Have the Same Parity

# ğŸ“œ Problem Statement
You are given an array `nums`. You must count how many ways you can split it into two non-empty parts such that:

```

sum(left) % 2 == sum(right) % 2

```

This solution uses a parity trick to compute the answer in O(n) time without scanning prefixes.

# ğŸ” Example Input/Output
Input:
```

nums = [1, 2, 3, 4]

```
Output:
```

2

```
Explanation: Only splits where total sum is even are valid.

# ğŸ§  Approach
1. Let `S = sum(nums)`.
2. A split at position `i` (1 â‰¤ i < n) satisfies:
```

sum(left) % 2 == sum(right) % 2

```
Since:
```

sum(right) = S - sum(left)

```
The condition becomes:
```

sum(left) % 2 == (S - sum(left)) % 2

```
Simplifying:
- If `S` is **odd**, no split can satisfy the condition â†’ answer = 0.
- If `S` is **even**, *every* split is valid â†’ answer = (n - 1).
3. To check whether the sum is even efficiently:
- `sum(nums) & 1` gives the parity (0 if even, 1 if odd).
- `~x & 1` flips a bit: if `x=0` gives 1, if `x=1` gives 0.
- Thus `(~sum(nums) & 1)` is `1` when total sum is even, otherwise `0`.

So:
```

answer = (n - 1)  if total_sum is even
answer = 0        if total_sum is odd

````

# ğŸ’» Code 
```python
class Solution:
    def countPartitions(self, nums: List[int]) -> int:
        return (len(nums) - 1) * (~sum(nums) & 1)
````

# â± Complexity Analysis

* **Time:** O(n) for summing the array
* **Space:** O(1)

# ğŸ§ª Edge Cases

* n = 1 â†’ no partitions â†’ result = 0
* All even numbers â†’ all splits valid
* Sum odd â†’ answer always 0
* Large integers â†’ unaffected, parity only matters

```
```
