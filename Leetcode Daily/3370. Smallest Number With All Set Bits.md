# Smallest Number with Same Bit-Length (Binary Ones Mask)

üìú **Problem Statement**  
Given an integer `n`, return the **smallest number** that has the same number of bits as `n` when written in binary representation, but **all bits set to 1**.  

In other words, for a binary string representation of `n`, replace every bit with `1` and return that number in decimal.

üîç **Example Input / Output**  
**Input**  
    n = 10  

**Explanation**  
- Binary of 10 = `1010` (4 bits)  
- Replace each bit with `1` ‚Üí `1111`  
- Decimal equivalent = 15  

**Output**  
    15  

üß† **Approach (step-by-step)**  
1. Convert `n` to binary using `bin(n)[2:]` to get its binary string without the `0b` prefix.  
2. Count the length of this binary string ‚Üí that‚Äôs the number of bits.  
3. Construct a string of that many `'1'` characters.  
4. Convert it back to an integer with base 2.  
   - `'1111'` ‚Üí int(..., 2) = 15  

üíª **Code**  

    class Solution:
        def smallestNumber(self, n: int) -> int:
            l = bin(n)[2:]           # binary string of n
            return int('1' * len(l), 2)  # all bits replaced by 1, then converted to int

‚è± **Complexity Analysis**  
- **Time:** O(log n) (proportional to the number of bits in n)  
- **Space:** O(log n) (for binary string)

üß™ **Edge Cases**  
| Input | Binary | Output | Explanation |
|--------|----------|----------|-------------|
| 1 | `1` | 1 | one bit ‚Üí stays 1 |
| 2 | `10` | 3 | `11` = 3 |
| 7 | `111` | 7 | all bits already 1 |
| 10 | `1010` | 15 | `1111` = 15 |
| 32 | `100000` | 63 | `111111` = 63 |

‚úÖ **Final Formula Insight**  
For any positive integer `n`,  
\[
\text{smallestNumber}(n) = 2^{(\text{bit\_length of } n)} - 1
\]
So equivalently, this could be written as:
```python
return (1 << n.bit_length()) - 1
```
which avoids string conversions.