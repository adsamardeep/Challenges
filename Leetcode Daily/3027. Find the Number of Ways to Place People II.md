# 🟩 Problem: Count Ordered Pairs After Diagonal-like Sweep

## 📜 Problem Statement
Given a list of 2D integer points `a = [[x1,y1], [x2,y2], ...]`, count ordered pairs `(i, j)` with `i < j` after sorting by `x` ascending and `y` descending for ties, using a sweep that for each `i` counts later `y2` values satisfying `yMin < y2 <= y1` (where `yMin` is the last counted y for that i). Stop scanning for i when you hit `y2 == y1`.

---

## 🔍 Example

Input:
    a = [[1,5],[2,4],[2,3],[3,3],[4,5]]

After sorting (x asc, y desc):
    [[1,5],[2,4],[2,3],[3,3],[4,5]]

Output:
    4

---

## 🧠 Approach
1. Sort points by `(x, -y)`.
2. For each i, scan j > i keeping `yMin = -inf`. When `yMin < y2 <= y1`, count and set `yMin = y2`. If `y2 == y1` break for this i.
3. Return total count.

---

## 💻 Code (indent each code line by 4 spaces so it stays inside the single outer fence)
    class Solution:
        def numberOfPairs(self, a: List[List[int]]) -> int:
            # Sort by x ascending; for equal x sort by y descending
            a.sort(key=lambda p: (p[0], -p[1]))
            res = 0
            for i, (_, y1) in enumerate(a):
                yMin = float("-inf")
                for _, y2 in a[i + 1 :]:
                    if yMin < y2 <= y1:
                        res += 1
                        yMin = y2
                        if y1 == y2:  # once we hit y1 we can stop for this i
                            break
            return res

---

## ⏱ Complexity
- Time: O(n²) worst-case (sorting O(n log n) + nested scan).
- Space: O(1) extra.

---
