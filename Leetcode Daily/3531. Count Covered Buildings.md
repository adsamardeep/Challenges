# üè∑ Count buildings covered from all four directions

## üìú Problem Statement
Given `n` (grid size, unused) and a list `buildings` where each element is `[x, y]` representing building coordinates on a 2D grid, count how many buildings are strictly *covered* from all four cardinal directions ‚Äî i.e., there exists at least one building to the left and right in the same row and at least one building above and below in the same column. Return the integer count.

## üîç Example Input/Output
**Input:** `n = 5, buildings = [[1,1],[1,3],[1,4],[2,3],[3,3],[4,3]]`  
**Output:** `1`  
(Explanation: Building at `[2,3]` has row neighbors at `[1,3]` and `[3,3]` (left/right) and column neighbors at `[2,?]` ‚Äî here we actually require min/max in column; with this example, only one building lies strictly between min and max in both row and column.)

**Input:** `n = 3, buildings = [[0,0],[0,1],[0,2]]`  
**Output:** `0`  
(Explanation: No building has both left & right neighbors and top & bottom neighbors.)

## üß† Approach
1. Build two maps:
   - `r`: maps each row `x` to the minimum and maximum `y` seen in that row (`[min_y, max_y]`).
   - `c`: maps each column `y` to the minimum and maximum `x` seen in that column (`[min_x, max_x]`).
2. For each building `(x, y)`, retrieve its row bounds `a,b = r[x]` and column bounds `p,q = c[y]`.
3. A building is counted as "covered from all four directions" iff it lies strictly inside both intervals: `a < y < b` (has left & right neighbors in the row) **and** `p < x < q` (has top & bottom neighbors in the column).
4. Sum such buildings and return the result.

This uses min/max precomputation per row/column, so each building is processed a constant number of times.

## üíª Code 
```python
class Solution(object):
    def countCoveredBuildings(self, n, buildings):
        """
        Count buildings covered from all 4 directions
        
        :type n: int
        :type buildings: List[List[int]]
        :rtype: int
        """
        r={}  # row map: x -> [min_y, max_y]
        c={}  # col map: y -> [min_x, max_x]
        
        # Build min-max maps for each row and column
        for x,y in buildings:
            if x not in r:
                r[x]=[y,y]
            else:
                r[x][0]=min(r[x][0],y)
                r[x][1]=max(r[x][1],y)
            if y not in c:
                c[y]=[x,x]
            else:
                c[y][0]=min(c[y][0],x)
                c[y][1]=max(c[y][1],x)
        
        # Check each building if it's between min and max
        res=0
        for x,y in buildings:
            a,b=r[x]  # min_y, max_y for this row
            p,q=c[y]  # min_x, max_x for this column
            if a<y<b and p<x<q:
                res+=1
        
        return res
````

## ‚è± Complexity Analysis

* Time complexity: O(m) where `m = len(buildings)`. Building the row/column maps iterates all buildings once, and the final check iterates all buildings once more ‚Äî both linear.
* Space complexity: O(m) extra space for the `r` and `c` dictionaries (in the worst case each building can contribute distinct row or column keys).

## üß™ Edge Cases

* No buildings (`buildings = []`): returns `0`.
* Single building: returns `0` (cannot be surrounded).
* Buildings exist only on a single row or single column: returns `0` because at least one direction will be missing.
* Multiple buildings with same coordinates: duplicates are processed as separate entries; behavior depends on whether duplicates should be considered distinct (current code treats them as separate points ‚Äî duplicates do not create strict inequality and typically won't count as covered).
* Boundary buildings at the min or max of a row/column: not counted (checks use strict `<` and `>`).
* Large coordinates and sparse distribution: handled normally since algorithm uses dictionary maps keyed by coordinates.

```
```
