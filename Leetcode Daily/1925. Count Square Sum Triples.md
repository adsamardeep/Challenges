# ğŸ· Count Pythagorean Triples â‰¤ n

# ğŸ“œ Problem Statement
Given an integer `n`, count the number of **positive integer triples** `(a, b, c)` such that `aÂ² + bÂ² = cÂ²` and `c â‰¤ n`. The method uses Euclidâ€™s formula to generate primitive Pythagorean triples and scales them as long as the hypotenuse stays â‰¤ n.

# ğŸ” Example Input/Output
Input:
```

n = 10

```
Valid triples: (3,4,5) and (6,8,10) â†’ total **2**

Output:
```

2

````

# ğŸ§  Approach
- Use Euclidâ€™s formula: for integers `u > v > 0`, if `(uâˆ’v)` is odd and `gcd(u,v)=1`, then  
  `(a,b,c) = (uÂ² âˆ’ vÂ², 2uv, uÂ² + vÂ²)` forms a primitive Pythagorean triple.
- Let `c = uÂ² + vÂ²`. For each primitive triple with hypotenuse `c â‰¤ n`, all multiples `kÂ·c â‰¤ n` are valid.
- The loop over `u` up to `sqrt(n)` ensures that resulting `c` can remain â‰¤ `n`.
- For every valid primitive triple, add `2 * (n // c)` because `(a,b)` and `(b,a)` are both counted.

# ğŸ’» Code 
```python
class Solution:
    def countTriples(self, n: int) -> int:
        res = 0
        for u in range(2, int(sqrt(n)) + 1):
            for v in range(1, u):
                if (u - v) & 1 == 0 or gcd(u, v) != 1:
                    continue                    
                c = u * u + v * v
                if c > n:
                    continue
                res += 2 * (n // c)
        return res
````

# â± Complexity Analysis

* Time: **O(âˆšn Â· log n)** roughly, due to gcd calls inside a nested loop up to `âˆšn`
* Space: **O(1)**

# ğŸ§ª Edge Cases

* `n < 5` â†’ no Pythagorean triples exist, returns 0
* Perfect-square or non-square `n` behaves the same rule-wise
* Very large `n` still works; loops prune early when `c > n`

```
```
