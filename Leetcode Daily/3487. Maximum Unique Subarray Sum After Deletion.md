# maxSum - Sum of Unique Non-Negative Elements

## ðŸ“˜ Problem Statement

Given a list of integers `nums`, return the **sum of all unique non-negative elements**. If no non-negative unique values exist, return the **maximum negative number** from the list.

---

### âœ… Example
```python
Input:  nums = [1, 2, 2, 3, -4, -1]
Output: 4
# Explanation:
# Unique values = [1, 3, -4, -1]
# Non-negative unique = [1, 3]
# Sum = 1 + 3 = 4
```

```python
Input: nums = [-5, -2, -1, -5]
Output: -1
# Explanation:
# No non-negative unique values
# Return the maximum negative number = -1
```

---

## ðŸ§  Approach

- Use a **set** to keep track of seen elements.
- If an element is seen for the **first time** and is **non-negative**, add it to the sum.
- If no non-negative values are included, return the **maximum negative** number encountered.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n) â€” single pass through the list
- **Space Complexity**: O(n) â€” for the `seen` set

---

## ðŸ“„ Code

```python
from typing import List

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        mn = float('-inf')
        seen = set()
        sum_ = 0

        for val in nums:
            if val not in seen:
                # First occurrence, hence unique
                if val >= 0:
                    sum_ += val
                else:
                    mn = max(mn, val)
            seen.add(val)

        if sum_ == 0 and 0 not in seen:
            return mn

        return sum_
```

---

## ðŸ“‚ Usage

This function is useful when analyzing **unique contributors** in a dataset, particularly when positive impact (non-negative values) matters, and you need a fallback based on negative extremes.
