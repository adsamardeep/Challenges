# üü© Problem: Longest V-shaped Alternating Diagonal Path

## üìú Problem Statement
Given an `m √ó n` integer grid, find the length of the longest path that:

- Starts at a cell with value `1`.
- Moves strictly along grid **diagonals** (four diagonal directions: down-right, down-left, up-left, up-right).
- The visited cell values **alternate** between `1` and `2`.
- The path may **turn at most once** (so it can form a V-shape: go along one diagonal, then optionally turn once to another diagonal direction).
- You may only visit cells that match the required alternating target value at each step.

Return the maximum number of cells in such a path.

---

## üîç Example (concrete)

**Input**
```
grid = [
  [1,2,1,0],
  [0,1,2,1],
  [1,0,1,2],
  [0,1,0,1]
]
```

**Output**
```
4
```

**Explanation**
- One longest V-shaped path of length 4 is:
  - Start at (2,0)=1 ‚Üí (1,1)=1 ‚Üí (0,2)=1 ‚Üí (1,3)=1.  
- Depending on grid arrangement, other valid V-shapes can also reach length 4.  
- The algorithm explores diagonals from each starting `1`, allowing one turn and alternating values, and returns the maximum length found.

---

## üß† Approach (overview)
1. **Diagonal directions** used are:
   - `DIRS = [(1, 1), (1, -1), (-1, -1), (-1, 1)]` (down-right, down-left, up-left, up-right).

2. **DFS with memoization**:
   - From each `1` cell `(i,j)`, try every diagonal direction `k`.
   - Recursively step along the diagonal expecting alternating targets `2,1,2,...`.
   - Allow **one turn** (controlled by `canTurn` flag). After a turn, `canTurn` becomes `0`.
   - Use a memo table keyed by `(i, j, direction, canTurn)` to avoid recomputation.

3. **State encoding & memo table**:
   - Encode state into a small integer mask: `(direction << 1) | canTurn` (range 0..7).
   - `memo[i][j][mask]` stores the best reachable length (counting from that next cell in that state).

4. **Pruning**:
   - Use quick upper bounds for remaining steps along diagonals from a cell to skip DFS if it cannot beat current `ans`.

5. **Aggregation**:
   - For each start cell with `1`, for each direction `k`, compute `dfs(...) + 1` (count the starting cell) and update the global maximum.

---

## üíª Code Implementation
```python
class Solution:
    DIRS = [(1, 1), (1, -1), (-1, -1), (-1, 1)]

    def lenOfVDiagonal(self, grid):
        m, n = len(grid), len(grid[0])
        # memo[i][j][mask] stores best length from cell (i,j) given state mask
        # mask uses bits: (direction << 1) | canTurn  => range 0..7
        memo = [[[0] * 8 for _ in range(n)] for _ in range(m)]
        ans = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] != 1:
                    continue
                # quick upper bounds for each diagonal direction to prune
                maxs = [m - i, j + 1, i + 1, n - j]
                for k in range(4):
                    if maxs[k] > ans:
                        # start searching: canTurn=1, initial target=2 (since start cell is 1)
                        ans = max(ans, self.dfs(i, j, k, 1, 2, grid, memo) + 1)
        return ans

    def dfs(self, i, j, k, canTurn, target, grid, memo):
        m, n = len(grid), len(grid[0])
        # move one step in direction k
        i += self.DIRS[k][0]
        j += self.DIRS[k][1]
        # boundary or value mismatch: cannot proceed
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != target:
            return 0

        # encode state: (direction << 1) | canTurn  -> 3 bits (0..7)
        mask = (k << 1) | canTurn
        if memo[i][j][mask] > 0:
            return memo[i][j][mask]

        # continue straight (next expected target alternates: 3 - target flips between 1 and 2)
        res = self.dfs(i, j, k, canTurn, 3 - target, grid, memo)

        # if still allowed to turn, try turning clockwise once (k+1) % 4
        if canTurn == 1:
            # quick bound check: remaining capacity along new direction
            maxs = [m - i - 1, j, i, n - j - 1]
            nk = (k + 1) % 4
            if maxs[nk] > res:
                res = max(res, self.dfs(i, j, nk, 0, 3 - target, grid, memo))

        memo[i][j][mask] = res + 1  # include this step
        return memo[i][j][mask]
```

---

## ‚è± Complexity Analysis
- **Time Complexity:** O(m √ó n √ó S) where `S` ‚â§ 8 is the number of states per cell (4 directions √ó 2 `canTurn`). Each memo state is computed at most once, so effectively **O(m √ó n)** with a small constant factor.
- **Space Complexity:** O(m √ó n √ó S) for the memo table, i.e. **O(m √ó n)**.

---

## üß™ Edge Cases
- Empty grid ‚Üí function should handle or be guarded before calling.
- Grid contains values other than `1` and `2` ‚Üí those act as blockers.
- Very small grids (1√ó1, 1√óN, N√ó1) ‚Üí diagonals quickly go out-of-bounds; algorithm returns valid small lengths.
- Multiple equally-long paths ‚Üí function returns the length (not the path).
