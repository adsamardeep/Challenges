# Count Unguarded Cells in a Grid (Guards / Walls / Visibility)

üìú **Problem Statement**  
Given an `m √ó n` grid, some cells contain **walls** and some contain **guards**. A guard watches in the four cardinal directions (up/down/left/right) and **sees** all empty cells in a straight line until a wall or another guard blocks the view. A cell is **unguarded** if it is empty (neither wall nor guard) and is not seen by any guard. Return the number of unguarded cells.

üîç **Example Input / Output**  
**Input**
- m = 4, n = 6  
- guards = [[0,0],[1,1]]  
- walls = [[2,2],[3,4]]

**Output**
- an integer count of cells that are empty and not visible by any guard (depends on layout)

üß† **Approach (step-by-step)**  
1. Represent the grid as a single list `grid` of length `m*n` with characters:
   - `' '` for empty,
   - `'X'` for walls and guards (we treat guard cells themselves as non-empty/blocked),
   - `'V'` for cells that have been marked visible by at least one guard.
2. Maintain a counter `comp` initialized to `m*n` then subtract 1 for every wall and guard (those cells are not candidates for being unguarded empty cells).
3. For each guard, scan outwards in each of the four directions:
   - Step cell-by-cell until you go out of bounds or hit an `'X'` (wall or guard).
   - For every empty cell (`' '`), mark it `'V'` and decrement `comp` (since it is no longer an unguarded empty cell).
   - If a cell is already `'V'`, do nothing (avoids double-counting).
4. After processing all guards, `comp` equals the number of empty cells that were never marked visible, i.e. the number of unguarded cells. Return `comp`.

This algorithm is linear in the grid size plus the total number of cells scanned from all guards (each visible cell is marked at most once).

üíª **Code**
  
    from typing import List

    class Solution:
        def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
            # helper: convert (r,c) to linear index
            def idx(r: int, c: int) -> int:
                return r * n + c

            # direction vectors (right, down, left, up) with convenient iteration
            d = (0, 1, 0, -1, 0)

            # grid as a flat list of characters: ' ' (empty), 'X' (wall/guard), 'V' (visible)
            grid = [' '] * (m * n)
            comp = m * n  # count of currently-unaccounted empty cells

            # mark walls
            for r, c in walls:
                grid[idx(r, c)] = 'X'
                comp -= 1

            # mark guards (they block view and are not "unguarded" empty cells)
            for r, c in guards:
                grid[idx(r, c)] = 'X'
                comp -= 1

            # function to propagate visibility from a guard at (r, c)
            def cross(r: int, c: int) -> None:
                nonlocal comp
                for a in range(4):
                    di, dj = d[a], d[a + 1]
                    i, j = r + di, c + dj
                    # walk along the direction until boundary or blocked cell 'X'
                    while True:
                        # check bounds first; if out-of-bounds, stop
                        if i < 0 or i >= m or j < 0 or j >= n:
                            break
                        pos = idx(i, j)
                        # stop when we hit a wall or a guard (marked 'X')
                        if grid[pos] == 'X':
                            break
                        # if this cell was empty, mark it visible and reduce unguarded count
                        if grid[pos] == ' ':
                            grid[pos] = 'V'
                            comp -= 1
                        # otherwise if already 'V', nothing to do
                        i += di
                        j += dj

            # propagate visibility from each guard
            for r, c in guards:
                cross(r, c)

            return comp

‚è± **Complexity Analysis**  
- Let `N = m * n`.  
- **Time:** O(N + S) where `S` is the total number of cells scanned from all guards; each empty cell becomes `'V'` at most once, so `S = O(N)` in aggregate ‚Äî overall O(N).  
- **Space:** O(N) for the flat `grid` array.

üß™ **Edge Cases & Notes**  
- If `guards` or `walls` overlap or include invalid coordinates, validate inputs before use (above code assumes inputs are valid).  
- Guards block each other‚Äôs view (guard cells are treated same as walls for blocking).  
- Multiple guards may see the same empty cell; we avoid double-counting by only decrementing `comp` when a cell transitions from `' '` to `'V'`.  
- If there are no guards, result is simply number of empty cells (`m*n - len(walls)`), since none are seen.  
- If all cells are walls/guards, result is `0`.  

