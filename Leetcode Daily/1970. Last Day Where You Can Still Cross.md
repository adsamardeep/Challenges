# üè∑ Latest Day to Cross a Flooded Grid Using Union-Find

## üìú Problem Statement
You are given a grid of size `row √ó col` that becomes flooded cell by cell each day. Given the flooding order, determine the **latest day** when it is still possible to cross from the **top row to the bottom row** using only non-flooded cells.

## üîç Example Input/Output
**Input:**
```python
row = 2
col = 2
cells = [[1,1],[2,1],[1,2],[2,2]]
````

**Output:**

```python
2
```

## üß† Approach

1. Instead of simulating flooding forward, process the grid **in reverse**, turning flooded cells back into land.
2. Use **Disjoint Set Union (Union-Find)** to dynamically connect adjacent land cells.
3. Add two virtual nodes:

   * One connected to all land cells in the **top row**
   * One connected to all land cells in the **bottom row**
4. Each time a cell is added back:

   * Union it with adjacent land cells.
   * Union it with the top or bottom virtual node if applicable.
5. The moment the top virtual node and bottom virtual node become connected, crossing is possible.
6. Return the corresponding day index.

This reverse-processing avoids repeated path searches and ensures efficiency.

## üíª Code 

```python
from typing import List

class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        dsu = DSU(row * col + 2)
        grid = [[0] * col for _ in range(row)]
        dirs = ((0,1),(0,-1),(1,0),(-1,0))

        for i in range(len(cells) - 1, -1, -1):
            r = cells[i][0] - 1
            c = cells[i][1] - 1
            grid[r][c] = 1

            id1 = r * col + c + 1
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 1:
                    id2 = nr * col + nc + 1
                    dsu.union(id1, id2)

            if r == 0:
                dsu.union(0, id1)
            if r == row - 1:
                dsu.union(row * col + 1, id1)

            if dsu.find(0) == dsu.find(row * col + 1):
                return i

        return -1


class DSU:
    def __init__(self, n):
        self.root = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.root[x] != x:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx == ry:
            return
        if self.size[rx] > self.size[ry]:
            rx, ry = ry, rx
        self.root[rx] = ry
        self.size[ry] += self.size[rx]
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O((row √ó col) ¬∑ Œ±(row √ó col))`
  (Nearly linear due to Union-Find with path compression)
* **Space Complexity:** `O(row √ó col)`
  For DSU structures and grid storage.

## üß™ Edge Cases

* Single row grid ‚Üí crossing is immediately possible
* Single column grid
* Flooding blocks all paths early
* Cells given in worst-case order (bottom-up or zig-zag)

```
```
