# maximumGain - Maximize Points by Removing Substrings

## ðŸ“˜ Problem Statement

You are given a string `s` and two integers `x` and `y`. You can remove substrings `"ab"` for `x` points or `"ba"` for `y` points. You can perform these operations **any number of times and in any order**, but each character can only be used once.

Your task is to find the **maximum total score** you can earn by optimally removing these substrings.

---

### âœ… Example
```python
Input: s = "cdbcbbaaabab", x = 4, y = 5
Output: 19

# Explanation:
# Optimal removal order is:
# 1. Remove "ba" â†’ +5 points
# 2. Remove "ab" â†’ +4 points
# Continue optimally until all valid substrings are removed
```

---

## ðŸ§  Approach

The strategy is:
- Always **remove the higher-scoring pattern first** to maximize total gain.
- Use a **stack** to simulate the removal of adjacent patterns (`"ab"` or `"ba"`).
- After removing one pattern type, pass the **remaining characters** to remove the other pattern type.

### ðŸ” Why Stack?
- We process the string left-to-right.
- For each character, check if the top of the stack forms the desired pattern with the current character.
- If yes, pop from the stack and add score.
- If no, push the current character onto the stack.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n) â€” where n is the length of `s`
- **Space Complexity**: O(n) â€” for stack usage in worst case

---

## ðŸ“„ Code

```python
class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        
        def solve(text: str, pattern: str, score: int):
            stack = []
            points = 0
            for char in text:
                if stack and stack[-1] == pattern[0] and char == pattern[1]:
                    stack.pop()
                    points += score
                else:
                    stack.append(char)
            return points, "".join(stack)

        if x >= y:
            points1, remaining_s = solve(s, "ab", x)
            points2, _ = solve(remaining_s, "ba", y)
        else:
            points1, remaining_s = solve(s, "ba", y)
            points2, _ = solve(remaining_s, "ab", x)
            
        return points1 + points2
```

---

## ðŸ“‚ Usage

This algorithm is useful in scenarios where **greedy ordering of pattern removal** matters â€” for example, text compression, stream editing, or optimizing token deletion in games.
