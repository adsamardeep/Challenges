# Find Smallest Missing Integer After Modular Shifts

📜 **Problem Statement**  
Given an integer array `nums` and an integer `value`, repeatedly perform the following operation any number of times:
- Choose any element `x` from `nums` and **add or subtract `value`** to it.

You can perform this operation on any elements as many times as you want.  
After performing any sequence of such operations, determine the **smallest non-negative integer** that **cannot** be obtained from the array.

🔍 **Example Input / Output**  
**Input**
    nums = [1,-10,7,13,6,8]
    value = 5

**Output**
    4

**Explanation**
All numbers can be transformed into numbers with certain remainders modulo 5:
remainders = [1,0,2,3,1,3]  
Frequencies per remainder = [1,2,1,2,0]

Now, we can construct:
- 0 (from remainder 0)
- 1 (from remainder 1)
- 2 (from remainder 2)
- 3 (from remainder 3)
But we can’t construct 4 — it’s the smallest missing number.

🧠 **Approach (step-by-step)**  
1. **Normalize all remainders:**  
   Each number `num` can be adjusted by ±`value` any number of times, so only its remainder modulo `value` matters.  
   Compute normalized remainder as `rem = ((num % value) + value) % value` (this handles negative numbers).  
2. **Count occurrences per remainder:**  
   Build an array `remainder_count[value]` to store how many numbers belong to each remainder class.  
3. **Greedy simulation:**  
   Start from `result = 0` and repeatedly check if we can “use up” a number of the same remainder class.  
   - If `remainder_count[result % value] > 0`, decrement it (use it) and increment `result`.  
   - If `remainder_count[result % value] == 0`, stop — this `result` is the smallest integer we can’t make.  
4. **Return `result`** as the answer.

💻 **Code**  

    class Solution:
        def findSmallestInteger(self, nums: list[int], value: int) -> int:
            remainder_count = [0] * value

            # Step 1: count normalized remainders
            for num in nums:
                rem = ((num % value) + value) % value
                remainder_count[rem] += 1

            # Step 2: simulate greedy construction
            result = 0
            while remainder_count[result % value] > 0:
                remainder_count[result % value] -= 1
                result += 1

            return result

⏱ **Complexity Analysis**  
- Let `n = len(nums)` and `m = value`.  
- **Time:** O(n + result) ≈ O(n + m) in worst case.  
- **Space:** O(m) for remainder count array.

🧪 **Edge Cases**  
- `nums` is empty → all remainder counts are 0 → answer is 0.  
- `value = 1` → all numbers map to remainder 0, so result = `len(nums)` (since we can form [0,1,2,...,len(nums)-1]).  
- Negative numbers handled correctly via `((num % value) + value) % value`.  
- Large values of `value` are fine — algorithm is linear in `n`.  
- Duplicate numbers automatically handled by incrementing remainder counts.

💡 **Intuition Recap:**  
Each remainder class acts like a “resource pool.” Starting from 0, you can build consecutive integers as long as each integer’s corresponding remainder has an available count.  
Once a remainder class runs out, you can no longer form that integer, so that’s your answer.
