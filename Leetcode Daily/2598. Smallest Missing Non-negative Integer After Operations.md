# Find Smallest Missing Integer After Modular Shifts

ğŸ“œ **Problem Statement**  
Given an integer array `nums` and an integer `value`, repeatedly perform the following operation any number of times:
- Choose any element `x` from `nums` and **add or subtract `value`** to it.

You can perform this operation on any elements as many times as you want.  
After performing any sequence of such operations, determine the **smallest non-negative integer** that **cannot** be obtained from the array.

ğŸ” **Example Input / Output**  
**Input**
    nums = [1,-10,7,13,6,8]
    value = 5

**Output**
    4

**Explanation**
All numbers can be transformed into numbers with certain remainders modulo 5:
remainders = [1,0,2,3,1,3]  
Frequencies per remainder = [1,2,1,2,0]

Now, we can construct:
- 0 (from remainder 0)
- 1 (from remainder 1)
- 2 (from remainder 2)
- 3 (from remainder 3)
But we canâ€™t construct 4 â€” itâ€™s the smallest missing number.

ğŸ§  **Approach (step-by-step)**  
1. **Normalize all remainders:**  
   Each number `num` can be adjusted by Â±`value` any number of times, so only its remainder modulo `value` matters.  
   Compute normalized remainder as `rem = ((num % value) + value) % value` (this handles negative numbers).  
2. **Count occurrences per remainder:**  
   Build an array `remainder_count[value]` to store how many numbers belong to each remainder class.  
3. **Greedy simulation:**  
   Start from `result = 0` and repeatedly check if we can â€œuse upâ€ a number of the same remainder class.  
   - If `remainder_count[result % value] > 0`, decrement it (use it) and increment `result`.  
   - If `remainder_count[result % value] == 0`, stop â€” this `result` is the smallest integer we canâ€™t make.  
4. **Return `result`** as the answer.

ğŸ’» **Code**  

    class Solution:
        def findSmallestInteger(self, nums: list[int], value: int) -> int:
            remainder_count = [0] * value

            # Step 1: count normalized remainders
            for num in nums:
                rem = ((num % value) + value) % value
                remainder_count[rem] += 1

            # Step 2: simulate greedy construction
            result = 0
            while remainder_count[result % value] > 0:
                remainder_count[result % value] -= 1
                result += 1

            return result

â± **Complexity Analysis**  
- Let `n = len(nums)` and `m = value`.  
- **Time:** O(n + result) â‰ˆ O(n + m) in worst case.  
- **Space:** O(m) for remainder count array.

ğŸ§ª **Edge Cases**  
- `nums` is empty â†’ all remainder counts are 0 â†’ answer is 0.  
- `value = 1` â†’ all numbers map to remainder 0, so result = `len(nums)` (since we can form [0,1,2,...,len(nums)-1]).  
- Negative numbers handled correctly via `((num % value) + value) % value`.  
- Large values of `value` are fine â€” algorithm is linear in `n`.  
- Duplicate numbers automatically handled by incrementing remainder counts.

ğŸ’¡ **Intuition Recap:**  
Each remainder class acts like a â€œresource pool.â€ Starting from 0, you can build consecutive integers as long as each integerâ€™s corresponding remainder has an available count.  
Once a remainder class runs out, you can no longer form that integer, so thatâ€™s your answer.
