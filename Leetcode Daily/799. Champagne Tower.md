# ğŸ¾ Champagne Tower

## ğŸ“œ Problem Statement

We pour `poured` glasses of champagne into the top glass of a tower.

Each glass can hold **1 cup**.  
If a glass overflows, the excess liquid is split **equally** between the two glasses directly below it.

Given:
- `poured`
- `query_row`
- `query_glass`

Return how full the specified glass is (between `0` and `1`).

---

## ğŸ§  Key Idea

This is a **simulation problem**.

Rules:
- A glass holds at most `1`
- Any excess `(amount - 1)` is split equally:
```

excess = (amount - 1) / 2

````
- The excess flows to:
- `tower[r+1][c]`
- `tower[r+1][c+1]`

We simulate row by row until `query_row`.

---

## ğŸ’» Code 

```python
class Solution:
  def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
      tower = [[0] * 102 for _ in range(102)]
      tower[0][0] = poured
      
      for r in range(query_row + 1):
          for c in range(r + 1):
              if tower[r][c] > 1:
                  excess = (tower[r][c] - 1.0) / 2.0
                  tower[r][c] = 1
                  tower[r+1][c] += excess
                  tower[r+1][c+1] += excess
                  
      return tower[query_row][query_glass]
````

---

## ğŸ” Example

### Input

```python
poured = 2
query_row = 1
query_glass = 1
```

### Simulation

Row 0:

```
[2]
```

Excess = `(2 - 1) / 2 = 0.5`

Row 1:

```
[0.5, 0.5]
```

Answer:

```
0.5
```

---

## â± Complexity

* **Time:** `O(query_rowÂ²)`
* **Space:** `O(query_rowÂ²)`

Maximum row is 100 â†’ safe and fast.

---

## âœ¨ Why 102 Ã— 102?

Constraints guarantee:

```
query_row â‰¤ 100
```

So we allocate slightly more space to avoid boundary checks.

---

## ğŸ§ª Edge Cases

* `poured = 0` â†’ always `0`
* Very large `poured` â†’ values capped at `1`
* Querying top glass â†’ `min(1, poured)`

---

