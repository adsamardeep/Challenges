# minCost - Minimum Cost to Make Baskets Equal

## ðŸ“˜ Problem Statement

You are given two baskets, `basket1` and `basket2`, each containing a list of integers representing different fruit types. Each fruit has an associated cost equal to its value.

You can **swap any two fruits between baskets**, and your goal is to make both baskets **identical** (same type and count of fruits). The **cost of a swap** is the **minimum of the two swapped values**. You may also swap a fruit with the **minimum-value fruit twice** (helper swap) at cost `2 Ã— min_fruit`.

Return the **minimum total cost** required to make both baskets equal. If it's **not possible**, return `-1`.

---

### âœ… Example

```python
Input:
basket1 = [4, 2, 2, 2]
basket2 = [1, 4, 1, 2]

Output: 1

# Explanation:
# Swap fruit type 2 in basket1 with fruit type 1 in basket2.
# Cost = min(2, 1) = 1
```

---

## ðŸ§  Approach

1. **Count fruit occurrences** across both baskets using `Counter`.
2. If any fruit has an **odd total count**, it's **impossible** to make the baskets equal â†’ return `-1`.
3. Determine how many of each fruit type are **misplaced** (surplus) in `basket1`.
4. Create a list of these misplaced fruits and sort it by fruit value (to prioritize low-cost swaps).
5. For each necessary swap:
   - Choose the minimum between:
     - Direct swap cost (the fruit value)
     - Helper swap cost using the **global minimum fruit**: `2 Ã— min_fruit`
6. Accumulate the total cost.

---

## ðŸ’¡ Key Points

- **Time Complexity**: O(n log n), due to sorting the misplaced fruit list.
- **Space Complexity**: O(n), for frequency tracking and the swap list.

---

## ðŸ“„ Code

```python
from collections import Counter

class Solution:
    def minCost(self, basket1: list[int], basket2: list[int]) -> int:
        total_counts = Counter(basket1) + Counter(basket2)
        
        for count in total_counts.values():
            if count % 2 != 0:
                return -1
        
        fruits_to_swap = []
        count1 = Counter(basket1)
        for fruit, total_count in total_counts.items():
            target = total_count // 2
            diff = count1.get(fruit, 0) - target
            
            for _ in range(abs(diff)):
                fruits_to_swap.append(fruit)

        fruits_to_swap.sort()
        
        min_val = min(total_counts.keys())
        total_cost = 0
        swaps_to_make = len(fruits_to_swap) // 2
        for i in range(swaps_to_make):
            total_cost += min(fruits_to_swap[i], 2 * min_val)
            
        return total_cost
```

---

## ðŸ“‚ Use Cases

This method is ideal for problems involving:
- Inventory balancing between two sources
- Symmetric data transformations
- Swap-cost optimization under constraints
