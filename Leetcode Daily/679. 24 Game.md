# 🃏 Problem: 24 Game

## 📜 Problem Statement
You are given four numbers (`cards`), each between **1 and 9**.  
Return `True` if you can compute the number **24** using:
- Addition `+`
- Subtraction `-`
- Multiplication `*`
- Division `/`  

You may use parentheses to change the order of operations.  

---

## 🔍 Example 1
**Input**
```python
cards = [4, 1, 8, 7]
```
**Explanation**
- `(8 - 4) * (7 - 1) = 24`

**Output**
```
True
```

---

## 🔍 Example 2
**Input**
```python
cards = [1, 2, 1, 2]
```
**Output**
```
False
```

---

## 🧠 Approach
This is a **backtracking + DFS search** problem:
1. Treat the problem as reducing a list of numbers until only one remains.
2. At each step:
   - Pick two numbers `a` and `b`.
   - Replace them with the result of applying an operation (`+`, `-`, `*`, `/`).
3. Continue recursively until one number is left.
   - If it is **close enough to 24**, return `True`.
4. Use a small tolerance `EPS = 1e-6` to handle floating-point errors.

---

## 💻 Code Implementation
```python
from typing import List

class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        EPS = 1e-6

        def dfs(nums: List[float]) -> bool:
            if len(nums) == 1:
                return abs(nums[0] - 24.0) < EPS

            for i in range(len(nums)):
                for j in range(len(nums)):
                    if i == j:
                        continue
                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                    a, b = nums[i], nums[j]
                    candidates = [a + b, a - b, b - a, a * b]
                    if abs(b) > EPS:
                        candidates.append(a / b)
                    if abs(a) > EPS:
                        candidates.append(b / a)

                    for val in candidates:
                        if dfs(next_nums + [val]):
                            return True
            return False

        return dfs([float(x) for x in cards])
```

---

## ⏱ Complexity Analysis
- **Time Complexity:** Exponential (backtracking explores many combinations).  
  However, since there are only **4 numbers**, it is manageable.
- **Space Complexity:** O(1) extra (apart from recursion stack).

---

## 🧪 Edge Cases
- `[8, 3, 8, 3]` → True (`(8 / (3 - 8/3)) = 24`)  
- `[1, 1, 1, 1]` → False  
- Large numbers (but ≤ 9) still work due to floating-point handling.
