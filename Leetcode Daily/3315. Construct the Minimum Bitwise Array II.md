# ğŸ· Minimum Bitwise Array Transformation (Bitwise One-Liner)

## ğŸ“œ Problem Statement
Given an array of integers `nums`, transform each element using a bitwise rule:
- If the number is **even**, return `-1`
- If the number is **odd**, produce the **minimum possible value** by clearing a specific bit using bitwise operations

Return the resulting transformed array.

## ğŸ” Example Input/Output
**Input**
```python
nums = [1, 3, 4, 7]
````

**Output**

```python
[0, 1, -1, 3]
```

**Explanation**

* `1 (001)` â†’ odd â†’ clear lowest relevant bit â†’ `0`
* `3 (011)` â†’ odd â†’ clear bit â†’ `1`
* `4 (100)` â†’ even â†’ `-1`
* `7 (111)` â†’ odd â†’ clear bit â†’ `3`

## ğŸ§  Approach

### Bitwise Insight

* `(p + 1) & -(p + 1)` isolates the **lowest set bit** of `p + 1`
* Shifting right by `1` gives the bit that should be toggled in `p`
* If this value becomes `0`, it means `p` is even
* The expression uses XOR (`^`) and masking tricks to:

  * Clear the correct bit for odd numbers
  * Convert even numbers directly to `-1`
* All logic is compressed into a single expression using Pythonâ€™s walrus operator

### Steps

1. Iterate through each number `p`
2. Compute the removable bit (`remB`)
3. Apply XOR-based transformation
4. Use a mask to return `-1` for even numbers

## ğŸ’» Code 

```python
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [
            p ^ (
                (remB := ((p + 1) & -(p + 1)) >> 1)
                | (-(remB == 0) & ~p)
            )
            for p in nums
        ]
```

## â± Complexity Analysis

* **Time Complexity:** `O(n)` where `n` is the length of `nums`
* **Space Complexity:** `O(n)` for the output array

## ğŸ§ª Edge Cases

* All even numbers â†’ output all `-1`
* Single-element array
* `p = 1` (smallest odd number)
* Large integers with long trailing `1` bits

```
```
