# ğŸ· Maximum Sum Divisible by Three (greedy removal of smallest remainder elements)

# ğŸ“œ Problem Statement
Given a list of integers `nums`, find the maximum possible sum of a subsequence of `nums` that is divisible by 3. You may remove any elements; return the largest sum divisible by 3 obtainable.

# ğŸ” Example Input/Output
Input:
```

nums = [3, 6, 5, 1, 8]

```
Output:
```

18

````
Explanation: Total sum = 23, remainder 2. Remove the smallest element(s) with total remainder 2 (e.g., remove 5) to get 18 which is divisible by 3.

# ğŸ§  Approach
1. Compute the total sum `sum_`.
2. Track the two smallest numbers with remainder 1 (`min1`, `min11`) and the two smallest with remainder 2 (`min2`, `min22`) as we iterate.
3. Let `rem = sum_ % 3`.
   - If `rem == 0`, the total sum is already divisible by 3 â€” return it.
   - If `rem == 1`, either remove the smallest single number with remainder 1, or remove the two smallest numbers with remainder 2. Choose the cheaper (smaller total removal).
   - If `rem == 2`, either remove the smallest single number with remainder 2, or remove the two smallest numbers with remainder 1. Choose the cheaper removal.
4. If no valid removal exists (i.e., required candidates are missing), return 0 (can't form a positive sum divisible by 3).

This greedy works because removing the minimum total value with the correct combined remainder minimizes lost sum while fixing the total remainder.

# ğŸ’» Code 
```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        sum_ = 0

        min1 = min2 = float('inf')
        min11 = min22 = float('inf')

        for x in nums:
            sum_ += x
            r = x % 3

            if r == 1:
                if x < min1:
                    min11, min1 = min1, x
                elif x < min11:
                    min11 = x
            elif r == 2:
                if x < min2:
                    min22, min2 = min2, x
                elif x < min22:
                    min22 = x

        rem = sum_ % 3

        if rem == 0:
            return sum_

        if rem == 1:
            r1 = min1
            r2 = min2 + min22 if min2 < float('inf') and min22 < float('inf') else float('inf')
            remove = min(r1, r2)
            return 0 if remove == float('inf') else sum_ - remove
        else:
            r1 = min2
            r2 = min1 + min11 if min1 < float('inf') and min11 < float('inf') else float('inf')
            remove = min(r1, r2)
            return 0 if remove == float('inf') else sum_ - remove
````

# â± Complexity Analysis

* **Time:** `O(n)` â€” single pass to compute sum and maintain the four minima.
* **Space:** `O(1)` â€” constant extra space for a few variables.

# ğŸ§ª Edge Cases

* Empty `nums` â†’ returns `0`.
* All numbers divisible by 3 â†’ returns the total sum.
* Not enough candidates to fix remainder (e.g., `rem == 1` but no remainder-1 element and fewer than two remainder-2 elements) â†’ returns `0`.
* Negative numbers: code still works (minima logic uses numeric comparison), but problem typically assumes non-negative integers.
* Very large numbers: uses Python floats for `inf` sentinel and integer arithmetic for sums; works correctly in Python.

```
```
