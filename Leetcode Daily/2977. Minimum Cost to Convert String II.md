# ğŸ· Minimum Cost to Convert Source String to Target String

## ğŸ“œ Problem Statement
You are given two strings `source` and `target` of equal length, along with transformation rules defined by `original`, `changed`, and `cost`.  
Each rule allows converting one substring into another at a certain cost.  
The task is to compute the **minimum total cost** to convert `source` into `target` using these rules; return `-1` if it is impossible.

## ğŸ” Example Input/Output
**Input**
```python
source = "abcd"
target = "bcde"
original = ["ab", "bc", "cd"]
changed  = ["bc", "cd", "de"]
cost     = [1, 1, 1]
````

**Output**

```python
3
```

**Explanation**

* "ab" â†’ "bc" (cost 1)
* "bc" â†’ "cd" (cost 1)
* "cd" â†’ "de" (cost 1)
* Total minimum cost = `3`

## ğŸ§  Approach

### High-Level Strategy

This problem combines **graph shortest paths** with **dynamic programming**.

### Steps

1. **Map substrings to IDs**
   Assign each unique substring in `original` and `changed` a numeric ID.

2. **Build cost graph**
   Create a distance matrix where `dist[i][j]` is the minimum cost to transform substring `i` into substring `j`.

3. **Floydâ€“Warshall Algorithm**
   Compute the all-pairs shortest transformation costs between substrings.

4. **Dynamic Programming over the string**

   * `dp[i]` = minimum cost to convert `source[:i]` to `target[:i]`
   * Transition:

     * If characters match, move forward with no cost
     * Try all valid substring lengths and apply the precomputed transformation cost

5. **Final Answer**

   * Return `dp[n]` if reachable, otherwise `-1`

## ğŸ’» Code 

```python
class Solution:
    def minimumCost(self, source, target, original, changed, cost):
        INF = 10**30
        id = {}
        lens = set()
        sz = 0

        dist = [[INF] * 201 for _ in range(201)]

        for s, t, c in zip(original, changed, cost):
            if s not in id:
                id[s] = sz
                lens.add(len(s))
                sz += 1
            if t not in id:
                id[t] = sz
                sz += 1
            dist[id[s]][id[t]] = min(dist[id[s]][id[t]], c)

        for i in range(sz):
            dist[i][i] = 0

        for k in range(sz):
            for i in range(sz):
                if dist[i][k] < INF:
                    for j in range(sz):
                        if dist[k][j] < INF:
                            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

        n = len(source)
        dp = [INF] * (n + 1)
        dp[0] = 0

        for i in range(n):
            if dp[i] == INF:
                continue

            if source[i] == target[i]:
                dp[i + 1] = min(dp[i + 1], dp[i])

            for L in lens:
                if i + L > n:
                    continue
                s = source[i:i + L]
                t = target[i:i + L]
                if s in id and t in id:
                    dp[i + L] = min(dp[i + L], dp[i] + dist[id[s]][id[t]])

        return -1 if dp[n] == INF else dp[n]
```

## â± Complexity Analysis

* **Time Complexity:**

  * Floydâ€“Warshall: `O(KÂ³)` where `K` is number of unique substrings (â‰¤ 200)
  * DP over string: `O(n Ã— L)` where `L` is number of distinct substring lengths
* **Space Complexity:** `O(KÂ² + n)`

## ğŸ§ª Edge Cases

* No valid transformation path â†’ return `-1`
* `source == target` â†’ cost `0`
* Overlapping substring transformations
* Multiple rules for same transformation (pick minimum)
* Substrings of varying lengths

```
```
