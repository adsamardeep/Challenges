# Valid Triangle Number (Count Triplets Forming a Triangle)

üìú **Problem Statement**  
Given an integer array `nums`, return the number of triplets `(i, j, k)` with `0 <= i < j < k < len(nums)` such that `nums[i]`, `nums[j]`, and `nums[k]` can form the side lengths of a triangle. A triple forms a triangle iff the sum of any two sides is greater than the third; with sorted sides `a <= b <= c` it suffices to check `a + b > c`.

üîç **Example Input / Output**  
**Input**
    nums = [2, 2, 3, 4]

**Output**
    3

**Explanation**
Valid triplets (indices) ‚Äî values:
- (0,1,2): 2,2,3 ‚Üí 2+2>3 ‚úì
- (0,1,3): 2,2,4 ‚Üí 2+2>4 ‚úó (equal, not >)
- (0,2,3): 2,3,4 ‚Üí 2+3>4 ‚úì
- (1,2,3): 2,3,4 ‚Üí 2+3>4 ‚úì
So total = 3.

üß† **Approach (step-by-step)**  
1. Sort `nums` in non-decreasing order.  
2. Iterate `i` from `n-1` down to `0` treating `nums[i]` as the largest side `c` of a potential triangle.  
3. Use two pointers `left` = 0 and `right` = `i-1` to find pairs `(left, right)` with `nums[left] + nums[right] > nums[i]`.  
   - If the condition holds, then all indices between `left` and `right-1` paired with `right` also satisfy the condition because the array is sorted (their values are ‚â• `nums[left]`), so add `right - left` to the count and `right -= 1` to check other pairs.  
   - Otherwise increment `left` to increase the sum.  
4. Continue until `left >= right`. Repeat for each `i`.  
5. The two-pointer technique ensures each pair is considered efficiently.

üíª **Code**  

    from typing import List

    class Solution:
        def triangleNumber(self, nums: List[int]) -> int:
            nums.sort()
            n = len(nums)
            count = 0

            # Treat nums[i] as the largest side c
            for i in range(n - 1, -1, -1):
                left, right = 0, i - 1
                while left < right:
                    if nums[left] + nums[right] > nums[i]:
                        # All elements from left..right-1 with nums[right] form valid pairs
                        count += right - left
                        right -= 1
                    else:
                        left += 1
            return count

‚è± **Complexity Analysis**  
- Let `n = len(nums)`.  
- Sorting: `O(n log n)`.  
- The outer loop runs `n` times; for each `i` the inner two-pointer loop moves `left` and `right` at most `i` steps total ‚Äî overall the two-pointer work across all `i` is `O(n^2)` in the worst case.  
- **Time Complexity:** `O(n^2)` after sorting.  
- **Space Complexity:** `O(1)` extra space (besides input and sorting).

üß™ **Edge Cases**  
- `n < 3` ‚Üí return `0` (no triplets possible).  
- Zeros in `nums` (e.g., `[0,0,0]`) ‚Üí zeros cannot form a triangle because `0 + 0 > 0` is false; algorithm correctly excludes them.  
- Many duplicate values ‚Üí handled correctly by counting ranges via `right - left`.  
- Large `n` (up to problem constraints) ‚Üí algorithm is optimal typical approach; ensure time limits allow `O(n^2)`.  
- Negative numbers are not meaningful for triangle sides; problem usually assumes non-negative integers ‚Äî if negatives appear, they should be filtered/handled according to problem specification (current algorithm will treat them numerically, which may produce unexpected results).
