# ğŸ· Count Special Triplets of the Form (2x, x, 2x)

# ğŸ“œ Problem Statement
Given a list `nums`, count the number of index triplets `(i, j, k)` with `0 â‰¤ i < j < k < n` such that `nums[i] == nums[k] == 2 * nums[j]`. Return the count modulo `10^9 + 7`.

# ğŸ” Example Input/Output
Input:
```

nums = [2, 1, 2, 1, 2]

```
Output:
```

6

```
Explanation (one way to see it): for each middle position `j` with value `1`, there are `prev[2]` choices for the left `i` (2s before `j`) and `(freq[2] - prev[2])` choices for the right `k` (2s after `j`). Summing over all middle indices gives 6.

# ğŸ§  Approach
- Treat each index `j` as the middle element `x = nums[j]`.
- Maintain `freq` = counts of all numbers (remaining occurrences to the right initially), and `prev` = counts of numbers seen so far (to the left of current `j`).
- For a middle value `x`, the number of valid `(i,k)` pairs with `i<j<k` and `nums[i]=nums[k]=2*x` equals:
```

prev[2*x] * (freq[2*x] - prev[2*x] - (x == 0))

````
- `prev[2*x]` = count of eligible left elements.
- `freq[2*x] - prev[2*x]` = count of eligible right elements *including* the current element if `2*x == x` (i.e., when `x == 0`).
- For `x == 0` we subtract 1 to exclude the middle element itself from the right-side count.
- Accumulate this for all middle positions `j = 1..n-2`.
- Return the total modulo `1e9+7`.

# ğŸ’» Code 
```python
from typing import List
from collections import Counter

class Solution:
  def specialTriplets(self, nums: List[int]) -> int:
      n, MOD = len(nums), 10**9+7
      freq, prev = Counter(nums), Counter()
      cnt = 0
      prev[nums[0]] += 1
      for i in range(1, n - 1):
          x = nums[i]
          x2 = x << 1
          # prev[x2] = choices for left; freq[x2]-prev[x2] = choices for right (exclude middle when x==0)
          cnt += prev[x2] * (freq[x2] - prev[x2] - (x == 0))
          prev[x] += 1
      return cnt % MOD
````

# â± Complexity Analysis

* **Time:** `O(n)` â€” single pass with O(1) average-time Counter operations per element.
* **Space:** `O(u)` where `u` is the number of distinct values in `nums` (for the two Counters).

# ğŸ§ª Edge Cases

* `n < 3` â†’ returns `0` (no triplets).
* Values not producing any `2*x` occurrences â†’ zero contribution for those middles.
* Zeros (`x == 0`) are handled explicitly (avoid counting the middle zero as a right-side candidate).
* Large counts â†’ result is reduced modulo `1e9+7`.
* Negative numbers and duplicates are supported because doubling and equality checks work for any integers.

```
```
