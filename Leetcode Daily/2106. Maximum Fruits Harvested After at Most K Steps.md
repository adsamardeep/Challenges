# maxTotalFruits - Maximum Fruits Within Steps

## 📘 Problem Statement

You're given:
- A list `fruits`, where `fruits[i] = [position, amount]`
- An integer `startPos` (your starting location)
- An integer `k` (maximum total steps you can move)

You can move left or right along the number line, consuming **all fruits at each position** you visit. Your goal is to collect the **maximum total fruits** without exceeding `k` steps.

---

### ✅ Example

```python
Input:
fruits = [[2, 4], [4, 2], [6, 1], [8, 5]]
startPos = 5
k = 4

Output: 7

# Explanation:
# Visit positions 4 and 6 (step cost: 1 + 1 = 2).
# Fruits collected = 2 + 1 = 3

# Or visit position 2 (step cost: 3), then 4 (1 step right).
# Fruits = 4 + 2 = 6

# Best option: 4 (2 fruits) → 6 (1 fruit) → 8 (5 fruits) exceeds k.
# So, best is 2 + 1 + 4 = 7 within 4 steps.
```

---

## 🧠 Approach

1. Use the **sliding window technique** to find the optimal subarray (interval of positions) where total steps from `startPos` to both ends is ≤ `k`.
2. Sort or assume `fruits` is already in sorted order by position.
3. Iterate with two pointers (`left` and `right`) representing a valid interval:
   - Expand `right` and accumulate fruit amounts.
   - Shrink `left` if the **minimum walking cost** exceeds `k`.
   - Update the result (`res`) with the best total seen so far.

### 🚶‍♂️ Walking Distance Consideration

You can go left then right or right then left. The total steps taken is:
- `abs(startPos - fruits[left][0]) + (fruits[right][0] - fruits[left][0])`
- or `abs(startPos - fruits[right][0]) + (fruits[right][0] - fruits[left][0])`

Take the **minimum** of these two paths.

---

## 💡 Key Insights

- **Min path cost** ensures we choose the most efficient left-right walk.
- Use a **sliding window** to maintain fruit ranges within step constraints.

---

## 📄 Code

```python
class Solution:
    def maxTotalFruits(self, fruits, startPos: int, k: int) -> int:
        left = total = res = 0
        for right in range(len(fruits)):
            total += fruits[right][1]
            while left <= right and min(
                abs(startPos - fruits[left][0]) + fruits[right][0] - fruits[left][0],
                abs(startPos - fruits[right][0]) + fruits[right][0] - fruits[left][0]
            ) > k:
                total -= fruits[left][1]
                left += 1
            res = max(res, total)
        return res
```

---

## 🕒 Complexity

- **Time**: O(n)  
- **Space**: O(1) extra space (not counting input)

---

## 📂 Use Cases

- Optimizing range selection under movement constraints
- Time-window filtering with value maximization
- Efficient interval aggregation
