# ğŸ· Find the Smallest Missing Value of the Form kÂ·2^t in an Array

# ğŸ“œ Problem Statement
Given an integer array `nums` and a positive integer `k`, consider the values in `nums` that are divisible by `k` and whose quotient `n = num // k` is a power of two. Return the smallest value of the form `k * 2^t` that **does not** appear in `nums`. The code collects which `2^t` quotients are present and returns `k` multiplied by the smallest missing power-of-two.

# ğŸ” Example Input/Output
Input:
```

nums = [3, 6, 12, 48], k = 3

```
Explanation:
- Divisible by k: 3â†’n=1 (2^0), 6â†’n=2 (2^1), 12â†’n=4 (2^2), 48â†’n=16 (2^4)
- Present powers: 1,2,4,16 (i.e. 2^0,2^1,2^2,2^4). The smallest missing power-of-two in the sequence 2^0,2^1,2^2,... is 2^3 = 8.
Output:
```

3 * 8 = 24

````

# ğŸ§  Approach
1. Iterate `nums`. For each `num`:
   - Skip if `num % k != 0`.
   - Let `n = num // k`. If `n` is a power of two (checked by `n & (n - 1) == 0`), record that power by OR-ing `n` into a bitmask variable `bits`.
     - Note: here we use the actual power-of-two value (1,2,4,8,...) as bit positions in `bits`.
2. After processing all numbers, `bits` has 1-bits at positions corresponding to powers-of-two quotients present.
3. `bits + 1` produces a number whose lowest set bit corresponds to the lowest power-of-two **not** present among the contiguous run of low powers-of-two. Taking `d & -d` extracts that least significant set bit; multiplying by `k` yields the desired missing value `k * 2^t`.
4. Return that product.

This technique is a compact bit-hack to find the smallest missing power-of-two multiplier when you treat each power-of-two value `2^t` as the bit `1<<t`, but implemented using the powers themselves (1,2,4,...) as bit masks.

# ğŸ’» Code 
```python
class Solution:
    def findFinalValue(self, nums: list[int], k: int) -> int:
        bits = 0
        for num in nums:
            if num % k != 0:
                continue
            n = num // k
            if n & (n - 1) == 0:
                bits |= n
        d = bits + 1
        return k * (d & -d)
````

# â± Complexity Analysis

* **Time Complexity:** `O(n)` â€” single pass over `nums`.
* **Space Complexity:** `O(1)` â€” constant extra space.

# ğŸ§ª Edge Cases

* `nums` contains no elements divisible by `k` â†’ `bits = 0`, `d = 1`, returns `k * 1 = k` (smallest missing is `k` itself).
* `nums` contains some divisible elements but none whose quotient is a power of two â†’ same as above.
* `nums` contains `k, 2k, 4k, ...` up to `k*2^t` contiguous from 1 â†’ returns `k * 2^(t+1)` as expected.
* Large values: using bitwise ops on the actual power-of-two values (1,2,4,...) relies on Python's unbounded ints; works correctly but be mindful if `nums` contains extremely large powers (still O(n) time).
* Non-positive or zero `k` is not considered; assume `k > 0` per typical problem constraints.

```
```
