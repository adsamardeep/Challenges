# üè∑ Maximum Product of Splitted Binary Tree

## üìú Problem Statement
Given the root of a binary tree, split the tree into two subtrees by removing exactly one edge. Return the **maximum product** of the sums of the two resulting subtrees, modulo `10^9 + 7`.

## üîç Example Input/Output
**Input:**
```python
# Tree:
#       1
#      / \
#     2   3
#    / \
#   4   5
````

**Output:**

```python
50
```

**Explanation:**
Total sum = 15.
Best split separates subtree `{3}` (sum = 3) and the rest `{1,2,4,5}` (sum = 12).
Product = `3 √ó 12 = 36`.

## üß† Approach

1. Use a **DFS traversal** to compute subtree sums.
2. First DFS computes the **total sum** of the tree.
3. A second DFS recomputes each subtree sum and considers cutting the edge above it.
4. For each subtree sum `S`, compute the product `(total - S) √ó S`.
5. Track the maximum product across all possible splits.
6. Return the result modulo `10^9 + 7`.

This approach ensures every possible edge cut is evaluated efficiently.

## üíª Code 

```python
from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        ans, total = -inf, 0

        def dfs(root):
            nonlocal ans, total
            if not root:
                return 0
            Sum = root.val + dfs(root.left) + dfs(root.right)
            ans = max(ans, (total - Sum) * Sum)
            return Sum

        total = dfs(root)
        dfs(root)

        return ans % (10**9 + 7)
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(n)`
  Each node is visited a constant number of times.
* **Space Complexity:** `O(h)`
  Recursive call stack, where `h` is the height of the tree.

## üß™ Edge Cases

* Tree with only two nodes
* Highly skewed (linked-list-like) tree
* Large node values (handled by modulo)
* Balanced vs unbalanced trees

```
```
