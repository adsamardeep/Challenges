# ğŸ· Minimum number of boxes to store all apples

## ğŸ“œ Problem Statement
Given two lists, `apple` representing the number of apples in different piles and `cap` representing the capacities of available boxes, determine the minimum number of boxes needed to store all apples. Each box can hold up to its capacity, and apples can be distributed arbitrarily across boxes.

## ğŸ” Example Input/Output
**Input:**
```python
apple = [1, 3, 2]
cap = [4, 3, 1]
````

**Output:**

```python
2
```

**Explanation:**
The total number of apples is `6`. Using boxes with capacities `4` and `3` is sufficient to store all apples.

## ğŸ§  Approach

1. Compute the total number of apples by summing the `apple` list.
2. Sort the box capacities in descending order to prioritize larger boxes first.
3. Iteratively use the largest available box, subtracting its capacity from the remaining apples.
4. Count how many boxes are used until all apples are stored.
5. Return the count of boxes used.

This greedy strategy works because using larger boxes first minimizes the number of boxes needed.

## ğŸ’» Code 

```python
from typing import List

class Solution:
    def minimumBoxes(self, apple: List[int], cap: List[int]) -> int:
        tot = sum(apple) 
        cap.sort(reverse=True)

        res = 0
        while tot > 0:
            tot -= cap[res]
            res += 1

        return res
```

## â± Complexity Analysis

* Time complexity: **O(n log n)** due to sorting the `cap` list.
* Space complexity: **O(1)** extra space (sorting done in place).

## ğŸ§ª Edge Cases

* No apples (`apple` sums to `0`) â†’ returns `0`.
* One box with very large capacity â†’ returns `1`.
* Box capacities exactly match total apples â†’ minimal boxes used.
* Many small boxes vs. few large boxes â†’ greedy choice ensures optimal result.
* Capacities list assumed sufficient to hold all apples (as per problem constraints).

```
```
