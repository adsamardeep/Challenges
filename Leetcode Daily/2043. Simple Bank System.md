# Bank System Implementation (LeetCode: "Bank")

ğŸ“œ **Problem Statement**  
Design a class `Bank` that simulates a simple banking system supporting:  
- **Transfer** of money between accounts  
- **Deposit** into an account  
- **Withdraw** from an account  

Each account is indexed from **1 to n**, and all balances are stored in a list `balance`.  
If any operation references an invalid account number or insufficient funds, it should return `False`; otherwise `True`.

ğŸ” **Example Input / Output**  
**Input**
    balance = [10, 100, 20, 50, 30]
    bank = Bank(balance)
    bank.withdraw(3, 10) â†’ True (balance[2]=10)
    bank.transfer(5, 1, 20) â†’ True (balance[4]-=20, balance[0]+=20)
    bank.deposit(5, 20) â†’ True (balance[4]+=20)
    bank.transfer(3, 4, 15) â†’ False (balance[2]<15)

**Output**
    [30, 100, 10, 50, 30]  (final state after valid operations)

ğŸ§  **Approach (step-by-step)**  
1. **Initialization (`__init__`)**  
   - Store account balances in a list `self.bal`.  
   - Record total number of accounts `self.n`.

2. **Validation (`valid`)**  
   - A helper to check if an account index is within `[1, n]`.

3. **Transfer**  
   - Validate both accounts.  
   - Ensure the sender (`account1`) has enough funds.  
   - Subtract money from sender, add to receiver.

4. **Deposit**  
   - Validate account.  
   - Add money to balance.

5. **Withdraw**  
   - Validate account.  
   - Ensure sufficient funds.  
   - Subtract money from balance.

All methods return `True` on success, `False` otherwise.

ğŸ’» **Code**  

    class Bank:
        def __init__(self, balance: list[int]):
            self.bal = balance
            self.n = len(balance)

        def valid(self, acc: int) -> bool:
            return 1 <= acc <= self.n

        def transfer(self, account1: int, account2: int, money: int) -> bool:
            if not self.valid(account1) or not self.valid(account2) or self.bal[account1 - 1] < money:
                return False
            self.bal[account1 - 1] -= money
            self.bal[account2 - 1] += money
            return True

        def deposit(self, account: int, money: int) -> bool:
            if not self.valid(account):
                return False
            self.bal[account - 1] += money
            return True

        def withdraw(self, account: int, money: int) -> bool:
            if not self.valid(account) or self.bal[account - 1] < money:
                return False
            self.bal[account - 1] -= money
            return True

â± **Complexity Analysis**  
- **Time:** O(1) per operation (constant-time arithmetic and index access).  
- **Space:** O(n) for storing account balances.  

ğŸ§ª **Edge Cases**  
- Invalid account index (0 or > n) â†’ returns `False`.  
- Withdraw or transfer more than available balance â†’ returns `False`.  
- Depositing negative or zero amount is not explicitly handled (could add guard if needed).  
- Operations do not mutate unrelated accounts.  

âœ… **Example Trace**
| Operation | Input | Output | Balances |
|------------|--------|---------|-----------|
| Init | [10,100,20,50,30] | â€“ | [10,100,20,50,30] |
| withdraw(3,10) | True | [10,100,10,50,30] |
| transfer(5,1,20) | True | [30,100,10,50,10] |
| deposit(5,20) | True | [30,100,10,50,30] |
| transfer(3,4,15) | False | [30,100,10,50,30] |

