# üü© Problem: People Aware of a Secret

## üìú Problem Statement
A secret is initially known by one person on day 1.  
Every day, any person who knows the secret:

- will start sharing it after `delay` days (i.e., they can share on days `t + delay`, `t + delay + 1`, ...),
- will forget the secret after `forget` days (i.e., on day `t + forget` they no longer know it and cannot share).

Given `n` days, `delay`, and `forget`, return the number of people who know the secret at the end of day `n`.  
Return the answer modulo `10^9 + 7`.

---

## üîç Examples

**Example 1**
Input:
    n = 6, delay = 2, forget = 4

Output:
    5

Explanation (one valid trace):
- Day 1: person A knows (1)
- Day 3: A can start sharing ‚Üí new persons B (day3) and C (day4) eventually get it following delays; after accounting all shares and forgettings, 5 people know at end of day 6.

**Example 2**
Input:
    n = 4, delay = 1, forget = 3

Output:
    4

Explanation:
- Simple small trace results in 4 people knowing by day 4.

---

## üß† Approach
We use dynamic programming plus a sliding-window technique to track how many *active sharers* are available on each day.

- Let `dp[i]` = number of people who **learn** the secret exactly on day `i`.
  - `dp[1] = 1` (initial person).

- A person who learned on day `t` can start contributing new learners on days `t + delay` through `t + forget - 1` (inclusive).  
  So when we are at day `i`, the number of people who can share on day `i` equals the sum of `dp[t]` for all `t` such that `t + delay <= i <= t + forget - 1`. This is a sliding window of previous `dp` values.

- Maintain a variable `window` = sum of `dp[enter_day]` values that are currently able to share on day `i`.  
  For day `i`:
  - `enter = i - delay` ‚Üí if `enter >= 1`, add `dp[enter]` to `window` (these people become eligible to share).
  - `exit_ = i - forget` ‚Üí if `exit_ >= 1`, subtract `dp[exit_]` from `window` (these people have forgotten and are no longer sharers).
  - Then `dp[i] = window` (everyone currently able to share will cause that many new people to learn on day `i`).

- After filling `dp[1..n]`, the final answer is the number of people who still remember the secret on day `n`:
  - Those are all people who learned on days `t` with `t ‚â• n - forget + 1` (they haven't yet forgotten).
  - Sum `dp[start..n]` where `start = max(1, n - forget + 1)`.

All operations are done modulo `MOD = 10**9 + 7`.

This yields an O(n) time and O(n) space solution. You can reduce space to O(forget) if needed by keeping only a sliding buffer.

---

## üíª Code 
    class Solution:
        def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
            MOD = 10**9 + 7
            if n == 1:
                return 1
            dp = [0] * (n + 1)
            dp[1] = 1
            window = 0
            for i in range(2, n + 1):
                enter = i - delay
                exit_ = i - forget
                if enter >= 1:
                    window = (window + dp[enter]) % MOD
                if exit_ >= 1:
                    window = (window - dp[exit_] + MOD) % MOD
                dp[i] = window
            start = max(1, n - forget + 1)
            ans = sum(dp[start: n + 1]) % MOD
            return ans

---

## ‚è± Complexity Analysis
- **Time Complexity:** O(n) ‚Äî loop runs from 2 to n, with O(1) updates each iteration.  
- **Space Complexity:** O(n) ‚Äî the `dp` array of size `n+1`.  
  - Can be optimized to O(forget) by using a circular buffer instead of full `dp`.

---

## üß™ Edge Cases
- `n = 1` ‚Üí only the initial person knows: return `1`.  
- `delay >= forget` ‚Üí nobody who learns ever reaches the sharing window; result counts only remaining learners who haven't yet forgotten.  
- Large `n` ‚Üí modulo arithmetic prevents overflow.  
- `forget = 1` ‚Üí people forget immediately the next day; only same-day learners count.  
- Ensure subtraction when updating `window` is done modulo `MOD` to avoid negative values.  
