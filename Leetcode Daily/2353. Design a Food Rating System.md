# Food Ratings System (Per-Cuisine Highest Rated)

üìú **Problem Statement**  
Design a system that tracks foods, their cuisines, and ratings. It must support:
1. Initializing with lists of `foods`, `cuisines`, and `ratings`.
2. `changeRating(food, newRating)`: update the rating for a specific food.
3. `highestRated(cuisine)`: return the food with the highest rating in that cuisine; if multiple foods share the same highest rating, return the lexicographically smallest food name.

This should handle many updates and queries efficiently.

üîç **Example Input/Output**  
    foods = ["kimchi","ramen","burger","ramen2"]
    cuisines = ["korean","japanese","american","japanese"]
    ratings = [9, 7, 8, 7]

Operations and expected outputs:
    fr = FoodRatings(foods, cuisines, ratings)
    fr.highestRated("japanese")   # -> "ramen" (both ramen & ramen2 have rating 7, "ramen" < "ramen2")
    fr.changeRating("ramen2", 10)
    fr.highestRated("japanese")   # -> "ramen2"
    fr.changeRating("ramen", 11)
    fr.highestRated("japanese")   # -> "ramen"

üß† **Approach (step-by-step)**  
1. Maintain a dictionary `food_info` mapping each food -> (cuisine, current_rating). This gives O(1) access to update or validate the current rating.  
2. For each cuisine, maintain a max-heap implemented via Python's min-heap (`heapq`) by pushing tuples `(-rating, food)`. Negative rating gives max-heap behavior; food string is used to break ties lexicographically (min-heap keeps lexicographically smallest when ratings tie).  
3. On `changeRating`, update `food_info[food]` and push the new `(-newRating, food)` into that cuisine's heap. We do **not** remove the old heap entry immediately (lazy deletion).  
4. On `highestRated`, peek at the top of the heap and compare with `food_info`'s current rating. If they match, it's valid; otherwise pop and continue until a valid entry is found (lazy cleanup). Return the food when found.

This design gives efficient updates (O(log m) push into heap) and amortized/query-time correctness via lazy deletion.

üíª **Code**  

    import heapq
    from typing import List, Dict, Tuple

    class FoodRatings:

        def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
            # food_info maps food -> (cuisine, current_rating)
            self.food_info: Dict[str, Tuple[str, int]] = {}
            # cuisine_heaps maps cuisine -> list used as a heap of (-rating, food)
            self.cuisine_heaps: Dict[str, List[Tuple[int, str]]] = {}

            for food, cuisine, rating in zip(foods, cuisines, ratings):
                self.food_info[food] = (cuisine, rating)
                if cuisine not in self.cuisine_heaps:
                    self.cuisine_heaps[cuisine] = []
                heapq.heappush(self.cuisine_heaps[cuisine], (-rating, food))

        def changeRating(self, food: str, newRating: int) -> None:
            cuisine, _ = self.food_info[food]
            # update current rating
            self.food_info[food] = (cuisine, newRating)
            # push new entry into the heap (lazy deletion of old entries)
            heapq.heappush(self.cuisine_heaps[cuisine], (-newRating, food))

        def highestRated(self, cuisine: str) -> str:
            heap = self.cuisine_heaps[cuisine]
            # lazy removal of outdated entries
            while heap:
                rating_neg, food = heap[0]
                current_rating = self.food_info[food][1]
                if current_rating == -rating_neg:
                    return food
                heapq.heappop(heap)
            return ""

‚è± **Complexity Analysis**  
- Let `N` = number of foods, `Q` = number of operations, and `m` = number of foods in a cuisine (worst-case).  
- **Initialization:** Each push is O(log m) ‚Äî building all heaps is O(N log m) across cuisines.  
- **changeRating:** O(log m) to push the updated entry into that cuisine's heap. (Old entries remain for lazy deletion.)  
- **highestRated:** Amortized O(1) per valid peek, but can be O(log m) per popped stale entry. Overall across many operations, each stale heap entry is popped at most once, so total work is bounded amortized by the number of pushes.  
- **Space:** O(N) for `food_info` plus O(#heap_entries) which is O(N + #updates) due to lazy entries.

üß™ **Edge Cases**  
- Multiple foods in a cuisine with equal rating ‚Üí heap ordering by `( -rating, food )` ensures lexicographically smallest is chosen.  
- Frequent rating changes for a single food ‚Üí heap accumulates stale entries; lazy deletion handles correctness but increases heap size (still correct and amortized efficient).  
- Querying a cuisine with no foods (shouldn't happen with valid inputs) ‚Üí returns `""`.  
- Very large number of updates ‚Üí memory grows because of lazy stale entries; if memory is a concern, periodic rebuilding of the heap for a cuisine can be added.  
- Food names are unique (assumed). If duplicates are allowed, the design needs a unique id per food to distinguish entries.
