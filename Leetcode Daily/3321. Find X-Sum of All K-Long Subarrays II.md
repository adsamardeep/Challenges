# Sliding-window top-`x` frequency sum â€” balanced `SortedList` implementation (single markdown block)

ðŸ“œ **Goal**  
For each window of length `k` in `nums`, maintain the `x` distinct numbers with largest `(frequency, value)` (frequency primary, value secondary) and compute the sum `âˆ‘ value * frequency` over those top-`x` entries. Slide the window and output the top-`x` sum for every window.

ðŸ” **Notes about the provided code**
- The approach is correct in spirit: keep two ordered sets (`top` = current chosen top-x, `rest` = other distinct items) ordered by `(freq, value)`, update on add/remove, and rebalance so `top` has at most `x` best items.
- The implementation relies on an ordered container with efficient `pop`/`pop(0)`/`remove`/`add`/membership` operations. The easiest drop-in in Python is `SortedList` from the `sortedcontainers` package.

ðŸ§  **Improvements & corrections**
1. Use `SortedList` from `sortedcontainers` (`pip install sortedcontainers`) â€” it supports all needed operations efficiently.
2. Store entries as tuples `(freq, value)` so ordering is `(freq, value)`. We want descending order by `freq` then `value` when selecting best items. But `SortedList` sorts ascending â€” so we will store `(freq, value)` and treat the **largest** elements as at the end. To make comparisons and code intuitive, we will:
   - Keep `top` sorted ascending but interpret its best elements as its rightmost `len(top)` items. For convenience we maintain invariants so that `top` contains the best `x` items (i.e., the largest `x` elements by `(freq, value)`).
3. Carefully handle membership/removal of the "old" tuple before changing `freq[num]`.
4. Make `balance()` move largest items (from `rest`'s end) into `top`, and move worst items (from `top`'s start) back into `rest` when needed. Also swap when the largest in `rest` is greater than the smallest in `top`.
5. Keep `top_sum` updated when items move in/out of `top`.
6. Defensive handling when `x` can be larger than number of distinct elements.

ðŸ’» **Copy-paste ready, working code**  
```python
# Requires: pip install sortedcontainers
from collections import Counter
from sortedcontainers import SortedList
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        # freq map (num -> count)
        freq = Counter()
        # top: SortedList of best items (freq, num) but stored ascending; best items are the largest tuples
        top = SortedList()
        # rest: SortedList of the other items (freq, num)
        rest = SortedList()
        top_sum = 0
        ans = []

        def _make_tuple(num):
            return (freq[num], num)

        def balance():
            nonlocal top_sum
            # ensure top.size() <= x by moving smallest from top to rest if needed
            while len(top) > x:
                f, v = top.pop(0)        # smallest in top
                top_sum -= f * v
                rest.add((f, v))

            # fill top up to x by taking largest from rest
            while len(top) < x and rest:
                f, v = rest.pop()       # largest in rest
                top.add((f, v))
                top_sum += f * v

            # swap if largest in rest better than smallest in top
            while rest and top and rest[-1] > top[0]:
                f1, v1 = rest.pop()     # largest from rest
                f2, v2 = top.pop(0)     # smallest from top
                top_sum += f1 * v1 - f2 * v2
                top.add((f1, v1))
                rest.add((f2, v2))

        def add(num):
            nonlocal top_sum
            # remove old tuple (if present) from whichever structure it is in
            if freq[num] > 0:
                old = (freq[num], num)
                if old in top:
                    top.remove(old)
                    top_sum -= old[0] * old[1]
                else:
                    # may raise ValueError if not present; but logically it must be in rest
                    rest.remove(old)
            # increase frequency and add new tuple into rest (we'll rebalance)
            freq[num] += 1
            rest.add((freq[num], num))
            balance()

        def remove(num):
            nonlocal top_sum
            old = (freq[num], num)
            # remove old tuple from whichever structure it is in
            if old in top:
                top.remove(old)
                top_sum -= old[0] * old[1]
            else:
                # if not in top, it must be in rest
                rest.remove(old)
            # decrement frequency
            freq[num] -= 1
            if freq[num] == 0:
                del freq[num]
            else:
                # insert updated tuple into rest (never directly into top)
                rest.add((freq[num], num))
            balance()

        # initial window
        for i in range(k):
            add(nums[i])
        ans.append(top_sum)

        # slide
        for i in range(k, len(nums)):
            remove(nums[i - k])
            add(nums[i])
            ans.append(top_sum)

        return ans
