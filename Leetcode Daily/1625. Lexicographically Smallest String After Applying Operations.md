# Find Lexicographically Smallest String

📜 **Problem Statement**  
You are given a numeric string `s` (digits `'0'..'9'`) and two integers `a` and `b`. You may perform either operation any number of times (in any order):

1. Add `a` to every digit at an **odd index** (1-based indexing in the original problem; here we use 0-based so "odd index" means index%2==1); each addition is modulo 10.
2. Rotate the string to the right by `b` positions.

Return the lexicographically smallest string obtainable.

🔍 **Example Input / Output**  
**Input**  
    s = "5525", a = 9, b = 2

**Output**  
    "2050"

**Explanation (sketch)**  
Applying allowed operations in a suitable sequence you can reach many strings; the lexicographically smallest reachable string here is `"2050"`.

🧠 **Approach (step-by-step)**  
1. The operations form a finite-state graph where nodes are strings and edges are the two operations (add-on-odd-digits, rotate-by-b). We need the lexicographically smallest node reachable from the start — classical BFS/graph search on the state space.  
2. Use BFS (queue) from the start string, apply both operations to generate neighbors, and use a `visited` set to avoid reprocessing states. Record the smallest string seen.  
3. Implementation details / optimizations:
   - Use `collections.deque` for O(1) pops from the front.
   - Build the "add-to-odd-indices" string using a single pass/list-comprehension for speed.
   - Rotation is a constant-time slice operation on strings.
   - Stop when the queue is exhausted (we will have explored the reachable component). Because digits are finite (10^n possible strings but BFS typically explores far fewer due to structure), this terminates.
   - This BFS guarantees the lexicographically smallest visited string will be found (we must examine all reachable states since operations are not monotone in lexicographic order), so we track the minimum as we visit.

💻 **Code (copy-paste ready)**  
    from collections import deque
    from typing import List

    class Solution:
        def findLexSmallestString(self, s: str, a: int, b: int) -> str:
            # BFS over reachable strings
            q = deque([s])
            seen = {s}
            best = s

            while q:
                cur = q.popleft()
                if cur < best:
                    best = cur

                # Operation 1: add 'a' to every digit at odd indices (0-based index%2==1)
                # Build new string with one pass
                lst = list(cur)
                for i in range(1, len(lst), 2):
                    # int conversion and modulo; convert back to char
                    lst[i] = chr(((ord(lst[i]) - 48 + a) % 10) + 48)
                added = ''.join(lst)
                if added not in seen:
                    seen.add(added)
                    q.append(added)

                # Operation 2: rotate right by b
                if b % len(cur) != 0:  # if rotation by b is non-trivial
                    rotated = cur[-b:] + cur[:-b]
                else:
                    rotated = cur  # rotation by a full cycle is the same string
                if rotated not in seen:
                    seen.add(rotated)
                    q.append(rotated)

            return best

⏱ **Complexity Analysis**  
- Let `n = len(s)`. The state space size is at most `10^n` but, due to constraints/structure, reachable states are usually much smaller.  
- Each BFS step does O(n) work (constructing the added string and rotation). If `R` is the number of reachable states, time is `O(R * n)`. Space is `O(R * n)` for the queue and visited set.  
- In typical problem constraints (e.g. n ≤ 10), this is fine; BFS explores at most a few thousand states in practice because rotations and digit-cycles limit growth.

🧪 **Edge Cases**  
- `b % n == 0`: rotation is identity — BFS will only explore the "add" operation repeatedly; still handled correctly.  
- `a % 10 == 0`: "add" does nothing — only rotations matter (we'll explore the rotation orbit).  
- Very small `n` (1 or 2) — code handles them correctly.  
- The algorithm is safe for negative `a`/`b` only if problem guarantees non-negative; given the problem statement `a,b` are non-negative. If inputs include unexpected values, normalize them (`a %= 10`, `b %= n`) before BFS.
