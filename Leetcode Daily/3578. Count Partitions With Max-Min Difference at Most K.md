# ðŸ· Count Valid Partitions With Bounded Range (sliding-window + DP)

# ðŸ“œ Problem Statement
Given an array `nums` and an integer `k`, count the number of ways to partition `nums` into contiguous subarrays such that in every subarray the difference between the maximum and minimum element is at most `k`. Return the count modulo `10^9+7`.

# ðŸ” Example Input/Output
Input:
```

nums = [2, 1, 4, 3], k = 2

```
One valid partitioning example: `[2,1] | [4,3]` (both segments have max-min â‰¤ 2).  
Output (conceptual):
```

5

````
(There are 5 different ways to cut the array into contiguous pieces satisfying the condition.)

# ðŸ§  Approach
1. Use a sliding window `[left..rght]` that maintains the invariant `max(window) - min(window) â‰¤ k`. Maintain `mxQ` (monotonic decreasing deque) for maximum and `mnQ` (monotonic increasing deque) for minimum to update max/min in O(1) amortized time.
2. Let `dp[i]` be the number of valid partitionings for the prefix `nums[:i]` (with `dp[0] = 1` representing "no elements"). As we extend to the right, the number of new partitions ending at position `rght` equals the sum of `dp[t]` for all `t` where the subarray `nums[t:rght+1]` satisfies the max-min constraint.
3. Maintain `cnt` = sum of `dp[t]` for all valid starting indices `t` for the current window. When the window becomes invalid (`mx - mn > k`), increment `left` and subtract `dp[left]` from `cnt` (and pop from deques if needed) until it becomes valid again.
4. For each `rght`:
   - append current `cnt` to `dp` (these are contributions for partitions that end at `rght`),
   - then double `cnt` (since future positions can choose to cut or not at the current boundary) modulo `MOD`.
5. Final answer is `dp[-1] % MOD`.

This yields an O(n) time and O(n) space algorithm (deques and dp array), because each element is pushed/popped at most once in the monotonic deques and the sliding window moves only forward.

# ðŸ’» Code 
```python
from typing import List
from collections import deque

class Solution:             # Time = O(n), Space = O(n)
    def countPartitions(self, nums: List[int], k):
        left, cnt, mod = 0, 1, 1000000007
        mnQ, mxQ, dp = deque(), deque(), [cnt]
        for rght, num in enumerate(nums):
            while mxQ and num > mxQ[-1]:
                mxQ.pop()
            while mnQ and num < mnQ[-1]:
                mnQ.pop()
            mxQ.append(num) ; mnQ.append(num)
            while mxQ[0] - mnQ[0] > k:
                if nums[left] == mxQ[0]:
                    mxQ.popleft()
                if nums[left] == mnQ[0]:
                    mnQ.popleft()
                cnt -= dp[left]
                left += 1
            dp.append(cnt)
            cnt = (cnt * 2) % mod
        return dp[-1] % mod
````

# â± Complexity Analysis

* **Time:** `O(n)` â€” each element is pushed/popped from each deque at most once; the sliding window moves `left` and `rght` forward linearly; dp updates are O(1) per element.
* **Space:** `O(n)` â€” for the `dp` list and the two deques (worst-case sizes linear in `n`).

# ðŸ§ª Edge Cases

* `nums = []` (empty list): returns `1` (one way to partition an empty array â€” the empty partition). Adjust if the problem expects `0`.
* All elements within `k`: the algorithm counts all `2^(n-1)` possible ways to cut (each boundary can be cut or not).
* All elements with range > `k`: only single-element subarrays are valid; the result equals `1` (forced partition into all singletons) if interpreted as unique partitioning count.
* Large `k` (â‰¥ max-min of full array): result becomes all possible partitions, may be large but kept modulo `1e9+7`.
* Very large `n`: recursion not used, but `dp` array size grows to `n+1` â€” ensure memory is available.

```
```
