# ğŸ· Number of Paths With Sum Divisible by k

# ğŸ“œ Problem Statement  
You are given a 2D grid of integers and an integer `k`.  
You can move only **right** or **down** from the top-left corner to the bottom-right corner.  
A pathâ€™s value is the **sum of all cell values along the path**.  
Return the number of such paths whose sum is divisible by `k`, modulo `1e9+7`.

# ğŸ” Example Input/Output  
Input:
```

grid = [[5,2,4],[3,0,5],[0,7,2]]
k = 3

```
Output:
```

2

```

# ğŸ§  Approach  
This is a classic DP-with-remainder problem.

1. Let `dp[i][j][r]` = number of ways to reach cell `(i, j)` with total path-sum having remainder `r` modulo `k`.  
2. Initialize  
```

dp[0][0][grid[0][0] % k] = 1

```
3. For each cell `(i, j)`, inherit contributions from:
- the top cell `(i-1, j)`
- the left cell `(i, j-1)`
4. For each previous remainder `summ`, update:
```

newSum = (summ + grid[i][j]) % k
dp[i][j][newSum] += dp[i-1][j][summ]  # if exists
dp[i][j][newSum] += dp[i][j-1][summ]  # if exists

````
5. Result is `dp[m-1][n-1][0]` meaning sum divisible by `k`.

# ğŸ’» Code 
```python
class Solution:
def numberOfPaths(self, grid: list[list[int]], k: int) -> int:
 MOD = 1_000_000_007
 m = len(grid)
 n = len(grid[0])
 # dp[i][j][r] = number of ways to reach (i,j) with remainder r
 dp = [[[0] * k for _ in range(n)] for _ in range(m)]
 
 dp[0][0][grid[0][0] % k] = 1

 for i in range(m):
   for j in range(n):
     for summ in range(k):
       newSum = (summ + grid[i][j]) % k
       if i > 0:
         dp[i][j][newSum] += dp[i - 1][j][summ]
       if j > 0:
         dp[i][j][newSum] += dp[i][j - 1][summ]
       dp[i][j][newSum] %= MOD

 return dp[m - 1][n - 1][0]
````

# â± Complexity Analysis

* **Time:** O(m Â· n Â· k)
* **Space:** O(m Â· n Â· k)

# ğŸ§ª Edge Cases

* Single cell grid
* `k = 1` â†’ every sum is divisible; result equals number of paths
* Large grid values â€” handled via modulo arithmetic
* Very large grids â†’ memory use may be high

```
```
