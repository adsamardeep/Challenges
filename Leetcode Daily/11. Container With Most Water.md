# Container With Most Water

📜 **Problem Statement**  
Given an array `height` where `height[i]` represents the height of a vertical line drawn at index `i`, find two lines that together with the x-axis form a container that holds the most water. Return the maximum water area that can be trapped.

🔍 **Example Input/Output**  
**Input**  
    height = [1,8,6,2,5,4,8,3,7]

**Output**  
    49

**Explanation**  
- Choosing lines at indices 1 and 8:  
  width = 8 - 1 = 7, height = min(8,7) = 7 → area = 49.  
- This is the maximum possible.

🧠 **Approach (step-by-step)**  
1. Use two pointers `i` and `j`, starting at the leftmost and rightmost ends.  
2. Compute area as `(j - i) * min(height[i], height[j])`. Update result if larger.  
3. Move the pointer corresponding to the shorter line inward because moving the taller line cannot help increase area (width decreases and height bound is already limited by the shorter line).  
4. Continue until pointers meet.  
5. Return the maximum area found.

💻 **Code**  

    class Solution:
        def maxArea(self, height: list[int]) -> int:
            i, j = 0, len(height) - 1
            res = 0
            while i < j:
                res = max(res, (j - i) * min(height[i], height[j]))
                if height[i] < height[j]:
                    i += 1
                else:
                    j -= 1
            return res

⏱ **Complexity Analysis**  
- Let `n = len(height)`.  
- **Time Complexity:** O(n) — each pointer moves at most `n` steps.  
- **Space Complexity:** O(1).  

🧪 **Edge Cases**  
- `n < 2`: cannot form a container → return 0.  
- All heights equal (e.g., `[5,5,5,5]`) → max area = (n-1)*5.  
- Very large heights → Python handles big integers safely.  
- Strictly increasing or decreasing arrays — algorithm still finds the correct pair by moving pointers optimally.  
