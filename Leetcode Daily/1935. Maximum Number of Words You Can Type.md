# Count Words That Can Be Typed

📜 **Problem Statement**  
You are given a string `s` consisting of words separated by spaces and a string `t` consisting of broken letters on a keyboard. Return the number of words in `s` that can be fully typed without using any of the broken letters.

🔍 **Example Input/Output**  
**Input**  
    s = "hello world"
    t = "ad"

**Output**  
    1

**Explanation**  
- "hello" does not contain `a` or `d` → can be typed.  
- "world" contains `d` → cannot be typed.  
Answer = 1.

**Input**  
    s = "leet code"
    t = "lt"

**Output**  
    1

**Explanation**  
- "leet" contains `l` and `t` → cannot be typed.  
- "code" does not contain broken letters → can be typed.  
Answer = 1.

🧠 **Approach (step-by-step)**  
1. Split the string `s` into words using `s.split()`.  
2. For each word `w`, check if it shares any character with the set of broken letters `t`.  
   - Convert both to sets: `{*w}` for word, `{*t}` for broken letters.  
   - If intersection is empty, the word is typeable.  
3. Use `sum()` over boolean checks (`True` counts as 1, `False` as 0) to get the total count.

💻 **Code**  

    class Solution:
        def canBeTypedWords(self, s: str, t: str) -> int:
            # Count words that do not share any character with broken letters
            return sum(not {*w} & {*t} for w in s.split())

⏱ **Complexity Analysis**  
- Let `n = len(s)` and `m = len(t)`.  
- Splitting `s`: O(n).  
- For each word of length `k`, set creation is O(k), intersection with `{*t}` is O(min(k, m)).  
- Worst-case total: O(n + total_word_length * m) → effectively **O(n * m)**.  
- **Space:** O(n + m) for sets.

🧪 **Edge Cases**  
- Empty string `s` → result = 0.  
- Empty string `t` (no broken letters) → all words can be typed, answer = number of words in `s`.  
- All letters broken (e.g., `t` contains all alphabets) → answer = 0.  
- Words with repeated letters → handled correctly because set removes duplicates.  
- Multiple spaces in `s` → `split()` ignores extra spaces, still works.  
