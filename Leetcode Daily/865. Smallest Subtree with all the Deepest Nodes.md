# üè∑ Smallest Subtree Containing All the Deepest Nodes

## üìú Problem Statement
Given the root of a binary tree, return the **smallest subtree** that contains **all the deepest nodes** in the tree. A deepest node is one that has the maximum depth from the root.

## üîç Example Input/Output
**Input:**
```python
# Tree:
#        3
#       / \
#      5   1
#     / \   \
#    6   2   8
#       / \
#      7   4
````

**Output:**

```python
TreeNode(2)
```

**Explanation:**
The deepest nodes are `7` and `4`, and the smallest subtree containing both has root `2`.

## üß† Approach

1. Use a **post-order DFS traversal**.
2. For each node, compute:

   * The maximum depth of its left subtree.
   * The maximum depth of its right subtree.
3. If one subtree is deeper, propagate the deeper subtree‚Äôs result upward.
4. If both subtrees have equal depth, the current node is the **lowest common ancestor** of all deepest nodes.
5. Return both the depth and the candidate subtree root at each step.

## üíª Code 

```python
from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node):
            if not node:
                return 0, None

            left_height, left_node = dfs(node.left)
            right_height, right_node = dfs(node.right)

            if left_height > right_height:
                return left_height + 1, left_node
            elif right_height > left_height:
                return right_height + 1, right_node
            else:
                return left_height + 1, node

        return dfs(root)[1]
```

## ‚è± Complexity Analysis

* **Time Complexity:** `O(n)`
  Each node is visited exactly once.
* **Space Complexity:** `O(h)`
  Recursion stack where `h` is the height of the tree.

## üß™ Edge Cases

* Tree with only one node
* Completely skewed tree
* Multiple deepest nodes at different branches
* Balanced vs unbalanced trees

```
```
