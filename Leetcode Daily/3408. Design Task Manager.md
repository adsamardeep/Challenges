# Task Manager with Priority Operations

📜 **Problem Statement**  
Implement a task manager that stores tasks with `(userId, taskId, priority)` and supports operations to add a task, edit a task's priority, remove a task, and execute (pop) the highest-priority task returning its `userId`. Priorities are compared lexicographically by `(priority, taskId)` where higher priority means larger tuple order; ties are broken by `taskId`. Internally maintain quick lookup by `taskId` and an ordered structure to find/remove the top-priority task efficiently.

🔍 **Example Input/Output**  

Initial tasks:
    tasks = [
        (101, 1, 5),   # user 101, task 1, priority 5
        (102, 2, 3),   # user 102, task 2, priority 3
        (103, 3, 7)    # user 103, task 3, priority 7
    ]

Operations & results:
    tm = TaskManager(tasks)
    tm.execTop()        -> 103    # task 3 (priority 7) executed, returns userId 103
    tm.add(104, 4, 8)
    tm.execTop()        -> 104    # task 4 (priority 8)
    tm.edit(1, 9)
    tm.execTop()        -> 101    # task 1 now priority 9
    tm.rmv(2)
    tm.execTop()        -> -1     # no tasks left -> returns -1

🧠 **Approach (step-by-step)**  
1. Maintain a dictionary `mp` mapping `taskId -> (userId, priority)` for O(1) lookup and updates.  
2. Maintain a sorted list `st` of tuples `(priority, taskId)` so the highest-priority task is at the end. Use `bisect.insort` to insert while maintaining order.  
3. `add(userId, taskId, priority)`: insert mapping into `mp` and insert `(priority, taskId)` into `st`.  
4. `edit(taskId, newPriority)`: lookup old priority from `mp`, find its index in `st` using `bisect_left`, remove the old tuple, update `mp`, then `insort` the new tuple.  
5. `rmv(taskId)`: lookup and remove tuple from `st` via `bisect_left`, and delete from `mp`.  
6. `execTop()`: if `mp` empty return `-1`; otherwise pop the last tuple from `st` (highest priority), remove from `mp` and return the associated `userId`.  
7. The design relies on (priority, taskId) being unique per task in `st` so `bisect_left` finds the correct index.

💻 **Code**  

    import bisect

    class TaskManager:
        def __init__(self, tasks):
            # mp: taskId -> (userId, priority)
            self.mp = {}
            # st: sorted list of (priority, taskId) where highest priority is at the end
            self.st = []

            for userId, taskId, priority in tasks:
                self.mp[taskId] = (userId, priority)
                bisect.insort(self.st, (priority, taskId))

        def add(self, userId, taskId, priority):
            # add or overwrite task entry
            self.mp[taskId] = (userId, priority)
            bisect.insort(self.st, (priority, taskId))

        def edit(self, taskId, newPriority):
            userId, oldPriority = self.mp[taskId]
            idx = bisect.bisect_left(self.st, (oldPriority, taskId))
            # Expect the exact tuple at idx
            if 0 <= idx < len(self.st) and self.st[idx] == (oldPriority, taskId):
                self.st.pop(idx)
            self.mp[taskId] = (userId, newPriority)
            bisect.insort(self.st, (newPriority, taskId))

        def rmv(self, taskId):
            userId, priority = self.mp[taskId]
            idx = bisect.bisect_left(self.st, (priority, taskId))
            if 0 <= idx < len(self.st) and self.st[idx] == (priority, taskId):
                self.st.pop(idx)
            del self.mp[taskId]

        def execTop(self):
            if not self.mp:
                return -1
            priority, taskId = self.st.pop()  # highest priority (end of list)
            userId, _ = self.mp[taskId]
            del self.mp[taskId]
            return userId

⏱ **Complexity Analysis**  
- Let `n` be the number of tasks currently stored.  
- `add`: insertion with `bisect.insort` is O(n) due to list insertion shifting elements.  
- `edit` / `rmv`: `bisect_left` is O(log n) for search, but `pop(idx)` is O(n) for arbitrary index removal; overall O(n).  
- `execTop`: O(1) to pop from the end and O(1) dictionary deletion.  
- **Space:** O(n) for `mp` and `st`.

🧪 **Edge Cases**  
- Duplicate `taskId` on `add`: this implementation overwrites `mp` and inserts a new tuple into `st`, leaving the old tuple in `st` (could lead to duplicates). To avoid stale tuples you must remove the old tuple before insertion (similar to `edit`) or accept stale entries and handle lazily.  
- `edit`/`rmv` when the tuple isn't found at expected index (data inconsistency) — current code checks tuple equality before popping.  
- Ties in priority: tie broken by `taskId` since `(priority, taskId)` ordering is used. Ensure `taskId` comparison matches desired tie-break rule.  
- Large number of tasks/operations: frequent arbitrary removals and insertions on a Python list are O(n) and may be slow. For better performance consider using a balanced tree, `heapq` with lazy deletion, or `sortedcontainers.SortedList` (third-party) to get O(log n) inserts/removals.
