# üè∑ Tree-based knapsack optimization with discounts and capacity constraint

## üìú Problem Statement
Given a rooted tree with `n` nodes, each node having a profit and a cost, compute the maximum achievable profit under a global capacity limit `b`. Each node can be chosen in two modes (full cost or discounted cost), and the selection must respect tree dependencies (children contribute to parents). The goal is to maximize total profit without exceeding capacity.

## üîç Example Input/Output
**Input (conceptual):**
```python
n = 3
p = [10, 8, 6]          # profits
f = [5, 4, 3]           # costs
h = [(1,2), (1,3)]      # tree edges (parent -> child)
b = 5                   # capacity
````

**Output:**

```python
13
```

(Explanation: Selecting nodes with an optimal mix of full and discounted costs yields the maximum profit within capacity.)

## üß† Approach

1. Build the tree adjacency list from the edge list `h`.
2. Perform a DFS traversal to obtain a post-order (`ord`) so children are processed before parents.
3. Use dynamic programming on trees:

   * For each node `u`, maintain two DP arrays:

     * One for selecting `u` at full cost.
     * One for selecting `u` at discounted cost.
   * Each DP array is indexed by used capacity and stores the maximum profit.
4. Merge children‚Äôs DP arrays using a knapsack-style convolution (`mg`), respecting the capacity limit `b`.
5. After merging all children, incorporate the current node‚Äôs profit and cost using another transition (`mk`), producing the two DP states for node `u`.
6. At the root (node `1`), take the maximum achievable profit from its DP table.

## üíª Code 

```python
class Solution:
    def maxProfit(self,n,p,f,h,b):
        g=[[]for _ in range(n+1)];st,ord,dp=[1],[],[0]*(n+1)
        for u,v in h:g[u].append(v)
        while st:u=st.pop();ord.append(u);st+=g[u][::-1]
        for u in ord[::-1]:
            g0=g1=[0]
            for v in g[u]:
                f0,f1=dp[v];dp[v]=0
                def mg(a,c):
                    m=min(b,len(a)+len(c)-2)+1;r=[-1]*m
                    for i,x in enumerate(a):
                        if x<0:continue
                        for j,y in enumerate(c[:m-i]):
                            if y>=0:r[i+j]=max(r[i+j],x+y)
                    return r
                g0,g1=mg(g0,f0),mg(g1,f1)
            c=p[u-1];pf,ph=f[u-1]-c,f[u-1]-c//2
            def mk(g0,g1,c,pf):
                m=min(b,max(len(g0)-1,len(g1)-1+c))+1; r=[-1]*m
                for i in range(min(m,len(g0))):r[i]=g0[i]
                for i in range(len(g1)):
                    if i+c<m and g1[i]>=0:r[i+c]=max(r[i+c],g1[i]+pf)
                return r
            dp[u]=(mk(g0,g1,c,pf),mk(g0,g1,c//2,ph))
        return max(dp[1][0])
```

## ‚è± Complexity Analysis

* Time complexity: **O(n ¬∑ b¬≤)** in the worst case, due to repeated knapsack-style DP merges across tree nodes.
* Space complexity: **O(n ¬∑ b)** for storing DP arrays per node (amortized during traversal).

## üß™ Edge Cases

* `n = 1`: only the root node is considered; result depends on whether its cost fits within `b`.
* `b = 0`: no capacity available ‚Üí profit is `0`.
* Deep tree (linked list): still handled correctly due to post-order DP.
* Large capacity `b`: DP arrays grow but are explicitly capped.
* Nodes whose costs exceed `b`: they are automatically excluded by DP bounds.

```
```
