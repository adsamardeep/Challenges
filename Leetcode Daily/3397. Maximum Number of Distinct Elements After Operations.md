# Maximum Distinct Elements After ±k Shifts

📜 **Problem Statement**  
Given an array of integers `nums` and an integer `k`, you may change every element `a` into any integer in the inclusive range `[a-k, a+k]`. Choose new values for some or all elements such that the number of **distinct** chosen integers is maximized (two chosen values count distinct by their numeric equality). Return that maximum possible count.

🔍 **Example Input / Output**  
**Input**
    nums = [1, 1, 3, 4], k = 1

**Output**
    3

**Explanation**
Possible choices (one optimal): transform to [0,1,2,3] or [1,2,2,3] etc. We can make three distinct values (0,1,2 or 1,2,3).

🧠 **Approach (step-by-step / intuition)**  
1. Sort `nums` so we handle intervals `[a-k, a+k]` in increasing order of their center.  
2. Maintain `prev` as the last integer we assigned (we require chosen integers to be strictly increasing to guarantee distinctness). Initialize `prev` to a very small number.  
3. For each `a` in sorted `nums`:
   - Its allowable interval is `[low, high] = [a-k, a+k]`.
   - The earliest integer we can assign that is strictly greater than `prev` is `x = prev + 1`.
   - If `x < low` we can push `x` up to `low` (still the earliest feasible new distinct value).
   - If this `x` is `<= high`, we can assign `x` to this element (increasing `count` and setting `prev = x`).
   - Otherwise the interval doesn't allow any new distinct integer beyond `prev`, so skip this element.
4. This greedy picks the smallest feasible integer for each element, which maximizes opportunities for later elements and thus is optimal.

💻 **Code**  

    from typing import List

    class Solution:
        def maxDistinctElements(self, nums: List[int], k: int) -> int:
            if not nums:
                return 0
            nums.sort()
            count = 0
            prev = -(1 << 30)  # sentinel very small number
            for a in nums:
                low = a - k
                high = a + k
                x = prev + 1
                if x < low:
                    x = low
                if x <= high:
                    count += 1
                    prev = x
            return count

⏱ **Complexity Analysis**  
- Let `n = len(nums)`.  
- Sorting: O(n log n).  
- Single linear scan after sort: O(n).  
- **Overall Time:** O(n log n).  
- **Space:** O(1) extra (ignoring input sort space), or O(n) if sorting creates a copy.

🧪 **Edge Cases**  
- `nums` empty → return `0`.  
- `k = 0` → you can only use original values; result is the number of distinct elements in `nums`. The algorithm reduces to picking each distinct in sorted order.  
- Large negative/positive values → handled by Python ints; sentinel `prev` chosen very small to not interfere.  
- Many duplicates → algorithm spaces them out greedily across available integer slots.  
- If intervals are tight and overlap heavily, some elements cannot contribute new distinct values; the greedy earliest-choice ensures optimal use of available integers.
