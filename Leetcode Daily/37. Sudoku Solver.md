# ðŸŸ© Problem: Sudoku Solver (Bitmask + Backtracking with Heuristic)

## ðŸ“œ Problem Statement
Given a partially filled `9 Ã— 9` Sudoku board (empty cells marked by `"."`), fill the board **in-place** so that it becomes a valid Sudoku solution.

Sudoku rules:
- Each row must contain digits `1â€“9` exactly once.
- Each column must contain digits `1â€“9` exactly once.
- Each `3 Ã— 3` sub-box must contain digits `1â€“9` exactly once.

The algorithm should modify the input board to a valid completed Sudoku.

---

## ðŸ” Example

**Input**
    board = [
      ["5","3",".",".","7",".",".",".","."],
      ["6",".",".","1","9","5",".",".","."],
      [".","9","8",".",".",".",".","6","."],
      ["8",".",".",".","6",".",".",".","3"],
      ["4",".",".","8",".","3",".",".","1"],
      ["7",".",".",".","2",".",".",".","6"],
      [".","6",".",".",".",".","2","8","."],
      [".",".",".","4","1","9",".",".","5"],
      [".",".",".",".","8",".",".","7","9"]
    ]

**Output (filled board)**
    [
      ["5","3","4","6","7","8","9","1","2"],
      ["6","7","2","1","9","5","3","4","8"],
      ["1","9","8","3","4","2","5","6","7"],
      ["8","5","9","7","6","1","4","2","3"],
      ["4","2","6","8","5","3","7","9","1"],
      ["7","1","3","9","2","4","8","5","6"],
      ["9","6","1","5","3","7","2","8","4"],
      ["2","8","7","4","1","9","6","3","5"],
      ["3","4","5","2","8","6","1","7","9"]
    ]

---

## ðŸ§  Approach (overview)
This solution uses **bitmasks** + **backtracking** with a Minimum Remaining Value (MRV) heuristic:

- **Bitmask representation**
  - `rows[r]`, `cols[c]`, `boxes[b]` are integers where bit `k` (0-based) is `1` if digit `k+1` is already used in that row/column/box.
  - A 9-bit mask (0..0x1FF) represents digits 1..9.

- **Initialization**
  - Scan the board: for each filled cell place its digit into the corresponding row/col/box masks.
  - Collect coordinates of empty cells into `empties`.

- **Heuristic (MRV)**
  - On each recursive step, pick the empty cell that has the **fewest legal options** (i.e., smallest number of possible digits). This drastically prunes the search.

- **Enumerating options**
  - For a chosen empty cell compute `used = rows[r] | cols[c] | boxes[b]`.
  - Available digits mask: `(~used) & 0x1FF`.
  - Use `pick = mask & -mask` to extract the least significant set bit (one available digit).
  - Convert bit to digit index via `bit_position(pick)`.

- **Backtracking**
  - Place the digit (update masks and board), recurse.
  - If recursion fails, remove the digit and try the next option.
  - Restore `empties` ordering when backtracking.

This combines fast bit operations and the MRV heuristic to solve Sudoku efficiently in practice.

---

## ðŸ’» Code Implementation
    class Solution:
        def solveSudoku(self, board: List[List[str]]) -> None:
            rows = [0] * 9
            cols = [0] * 9
            boxes = [0] * 9
            empties = []

            def place(r, c, num):
                mask = 1 << num
                rows[r] |= mask
                cols[c] |= mask
                boxes[(r // 3) * 3 + (c // 3)] |= mask

            def remove(r, c, num):
                mask = ~(1 << num)
                rows[r] &= mask
                cols[c] &= mask
                boxes[(r // 3) * 3 + (c // 3)] &= mask

            def count_bits(n):
                count = 0
                while n:
                    n &= n - 1
                    count += 1
                return count

            def bit_position(mask):
                pos = 0
                while (1 << pos) != mask:
                    pos += 1
                return pos

            # Initialize
            for i in range(9):
                for j in range(9):
                    if board[i][j] == '.':
                        empties.append((i, j))
                    else:
                        num = int(board[i][j]) - 1
                        place(i, j, num)

            def backtrack():
                if not empties:
                    return True

                # Pick empty cell with minimum options (MRV)
                min_options, idx, mask = 10, -1, 0
                for k, (r, c) in enumerate(empties):
                    b = (r // 3) * 3 + (c // 3)
                    used = rows[r] | cols[c] | boxes[b]
                    options = 9 - count_bits(used)
                    if options < min_options:
                        min_options = options
                        idx = k
                        mask = (~used) & 0x1FF
                        if options == 1:
                            break

                r, c = empties.pop(idx)
                while mask:
                    pick = mask & -mask
                    num = bit_position(pick)
                    place(r, c, num)
                    board[r][c] = str(num + 1)

                    if backtrack():
                        return True

                    remove(r, c, num)
                    board[r][c] = '.'
                    mask -= pick

                empties.insert(idx, (r, c))
                return False

            backtrack()

---

## â± Complexity Analysis
- **Time Complexity:** Exponential in the worst case (backtracking), but **practically very fast** due to:
  - Bitmask operations (constant time per candidate),
  - MRV heuristic drastically reducing branching.
- **Space Complexity:** O(1) extra (masks + empties list) aside from recursion stack (depth â‰¤ 81).

---

## ðŸ§ª Edge Cases
- Already solved board â†’ function exits quickly.
- Invalid board (contradiction) â†’ backtracking will fail (this implementation assumes a valid solvable Sudoku).
- Extremely sparse board (many empties) â†’ more search, but MRV helps.
- Unique-solution vs multiple-solution puzzles â†’ algorithm will find one valid completed board.

