# Max Frequency After ¬±k Changes with Limited Operations

üìú **Problem Statement**  
Given an integer array `a`, an integer `k`, and an operation budget `op`, you may perform up to `op` operations. In a single operation you can change a single element `x` to any integer `y` such that `|x - y| ‚â§ k`. After at most `op` such operations, what is the maximum possible frequency (count) of any single integer value in the array?

üîç **Example Input / Output**  
**Input**
    a = [1,2,2,3,7], k = 1, op = 2

**Output**
    4

**Explanation**  
Targeting value `2`: elements within `[1,3]` are `{1,2,2,3}` (4 elements). Two of them are already `2`. With `op = 2` we can convert the other two (`1` and `3`) to `2`, achieving frequency `4`.

üß† **Approach (step-by-step)**  
We evaluate candidate targets using information from the sorted array and a frequency map. For each value `v` in the sorted array we consider two practical strategies and take the best:

1. **Make `v` the target**  
   - Count how many elements lie inside the interval `[v-k, v+k]` (these elements are convertible to `v` with one operation each).  
   - Let `freq_v` be how many elements already equal `v`. The number of other convertible elements in that interval is `available = total_in_range - freq_v`.  
   - Using at most `op` operations we can convert up to `min(op, available)` of those into `v`.  
   - Achievable frequency for this strategy: `freq_v + min(op, available)`.

2. **Right-window / shift strategy**  
   - Consider the window of array elements from index `i` (where `a[i]==v`) up to the largest index with value `‚â§ v + 2*k`. All those elements lie within a span of width `2k` and can be equalized to some value inside that span with appropriate conversions.  
   - We can also use some operations `op` to bring additional elements into this window. Conservatively, the achievable frequency here is `min(count_in_window + op, n)` (cannot exceed total `n`).

For each `v` we compute both candidates and take the maximum; the overall answer is the maximum across all `v`. Binary searches (`bisect_left` / `bisect_right`) allow O(log n) counting of values in any interval; `Counter` gives `freq_v` in O(1).

üíª **Code**  

    from typing import List
    from collections import Counter
    from bisect import bisect_left, bisect_right

    class Solution:
        def maxFrequency(self, a: List[int], k: int, op: int) -> int:
            """
            Return maximum frequency achievable for any value after at most `op`
            operations where each operation can change an element by at most `k`.
            """
            if not a:
                return 0

            a_sorted = sorted(a)
            freq = Counter(a_sorted)
            n = len(a_sorted)
            best = 0

            for i, v in enumerate(a_sorted):
                # Strategy 1: make v the target using values in [v-k, v+k]
                left = bisect_left(a_sorted, v - k)
                right = bisect_right(a_sorted, v + k)
                total_in_range = right - left
                cnt_v = freq[v]
                others_available = total_in_range - cnt_v
                cand1 = cnt_v + min(op, others_available)

                # Strategy 2: use right-side window up to v + 2*k (values from index i)
                right2 = bisect_right(a_sorted, v + 2 * k)
                count_window_from_i = right2 - i
                cand2 = min(count_window_from_i + op, n)

                best = max(best, cand1, cand2)

            return best

‚è± **Complexity Analysis**  
- Let `n = len(a)`.  
- Sorting: `O(n log n)`.  
- For each of the `n` candidates we do a constant number of `bisect` calls (each `O(log n)`) and O(1) arithmetic ‚Üí `O(n log n)` after sorting.  
- **Time:** `O(n log n)`.  
- **Space:** `O(n)` for the sorted array and counter.

üß™ **Edge Cases**  
- `a` empty ‚Üí return `0`.  
- `op = 0` or `k = 0` ‚Üí no effective changes; result equals the current maximum frequency.  
- Very large `op` (‚â• `n`) ‚Üí answer ‚â§ `n`.  
- Negative numbers supported (we sort and use bisect on their real values).  
- Many duplicates ‚Üí `Counter` ensures we count existing occurrences correctly.

**Notes / Remarks**  
- This two-strategy heuristic covers the typical beneficial operations: focusing on turning nearby elements into a chosen value `v`, or expanding a right-side window to find a dense cluster to amplify. It is efficient and practical.  
- If you want a different method (e.g., exact sliding-window approach centered on sorted values, or coordinate-compressed histogram approach for small value-range cases), I can provide that alternative in the same single-markdown-block format.
