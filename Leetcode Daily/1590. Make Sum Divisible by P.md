# ğŸ· Minimum Subarray to Remove for Divisibility by p (Prefix-Sum Hashing)

# ğŸ“œ Problem Statement  
Given an integer array `nums` and an integer `p`, remove the **shortest** subarray such that the remaining array's sum becomes divisible by `p`. If no such subarray exists, return `-1`.  
This algorithm uses prefix sums modulo `p` and a hash map to efficiently detect the smallest removable subarray.

# ğŸ” Example Input/Output  
Input:
```

nums = [3, 1, 4, 2], p = 6

```
Output:
```

1

````
Explanation: Removing subarray `[4]` makes the remaining sum equal to 6, which is divisible by 6.

# ğŸ§  Approach  
1. Compute `total % p`.  
   - If the result is `0`, no removal is needed.  
2. Let `need = total % p` â€” we must remove a subarray whose sum â‰¡ `need (mod p)`.  
3. Traverse the array while maintaining a running prefix sum modulo `p`.  
4. For each prefix `prefix`, compute `target = (prefix - need) % p`.  
   - If any earlier prefix has this value, removing the subarray between them achieves the required modulo correction.  
5. Track the minimum such subarray length using a hash map `last_index`.  
6. Return the minimum length or `-1` if impossible.

# ğŸ’» Code 
```python
from typing import List

class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        total = 0
        for x in nums:
            total = (total + x) % p
        
        need = total
        if need == 0:
            return 0
        
        n = len(nums)
        last_index = {0: -1}
        ans = n
        prefix = 0
        
        for i, x in enumerate(nums):
            prefix = (prefix + x) % p
            target = (prefix - need) % p
            
            if target in last_index:
                ans = min(ans, i - last_index[target])
            
            last_index[prefix] = i
        
        return -1 if ans == n else ans
````

# â± Complexity Analysis

* **Time:** O(n) â€” one pass through the array with O(1) hash map ops.
* **Space:** O(n) â€” stores prefix indices in a dictionary.

# ğŸ§ª Edge Cases

* Total sum already divisible by `p` â†’ returns `0`.
* No valid subarray exists â†’ returns `-1`.
* Single-element array.
* All elements are multiples of `p`.
* Large `p` relative to array sum still works (modulo logic).

```
```
