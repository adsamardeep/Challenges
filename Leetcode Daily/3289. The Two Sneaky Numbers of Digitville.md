# Find the Two Missing (Sneaky) Numbers using XOR Partitioning

üìú **Problem Statement**  
You are given an array `nums` containing all integers from `0` to `N-1` except **two missing numbers**.  
Your task is to find the two missing numbers in **O(n)** time and **O(1)** space.

üîç **Example Input / Output**  
**Input**  
    nums = [0, 1, 3, 4, 6]  
**Output**  
    [2, 5]  
**Explanation**  
The complete range should be `0..6` ‚Üí missing numbers are `2` and `5`.

üß† **Approach (step-by-step)**  
1. Let `n = len(nums) + 2` (since two numbers are missing).  
2. XOR all elements in `nums` and also all integers in the range `[0, n-1]`.  
   - This gives `xor_all = missing1 ^ missing2`.  
3. Identify the **rightmost set bit** in `xor_all` using `diffBit = xor_all & -xor_all`.  
   - This bit differs between the two missing numbers.  
4. Partition both `nums` and `[0, n-1]` into two groups based on whether this bit is set or not.  
   - XOR within each group separately.  
   - The result of each partition‚Äôs XOR gives one missing number.  
5. Return both missing numbers.

üíª **Code**  

    from typing import List

    class Solution:
        def getSneakyNumbers(self, nums: List[int]) -> List[int]:
            n = len(nums) + 2
            xor_all = 0

            # XOR all elements in nums
            for num in nums:
                xor_all ^= num

            # XOR all numbers from 0 to n-1
            for i in range(n):
                xor_all ^= i

            # Get rightmost set bit
            diffBit = xor_all & -xor_all

            a = b = 0

            # Partition nums into two groups
            for num in nums:
                if (num & diffBit) == 0:
                    a ^= num
                else:
                    b ^= num

            # Partition [0..n-1] into two groups
            for i in range(n):
                if (i & diffBit) == 0:
                    a ^= i
                else:
                    b ^= i

            return [a, b]

‚è± **Complexity Analysis**  
- **Time:** O(n) ‚Üí two linear passes (over `nums` and `0..n-1`)  
- **Space:** O(1) ‚Üí only constant extra variables  

üß™ **Edge Cases**  
| Case | Input | Output | Notes |
|------|--------|---------|-------|
| Both missing at start | [2,3,4] | [0,1] | Works |
| Both missing at end | [0,1,2,3] | [4,5] | Works |
| Random gaps | [1,2,4,5,6] | [0,3] | Works |
| Small input | [0] | [1,2] | Works |

‚úÖ **Key Insight**  
XOR efficiently cancels out all paired numbers, leaving only the XOR of the missing ones.  
By splitting numbers using a differing bit, we isolate each missing number separately.
