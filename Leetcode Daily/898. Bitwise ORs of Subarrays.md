# subarrayBitwiseORs - Count Distinct Bitwise ORs of Subarrays

## ðŸ“˜ Problem Statement

Given an integer array `arr`, return the **number of distinct bitwise OR results** of all possible non-empty subarrays.

A subarray is a contiguous sequence of elements within the array.

---

### âœ… Example

```python
Input: arr = [1, 2, 4]
Output: 6

# Explanation:
# All possible subarrays and their bitwise ORs:
# [1] = 1
# [2] = 2
# [4] = 4
# [1,2] = 1|2 = 3
# [2,4] = 2|4 = 6
# [1,2,4] = 1|2|4 = 7

# Distinct ORs = {1, 2, 3, 4, 6, 7} â†’ total = 6
```

---

## ðŸ§  Approach

### Observations:

- Bitwise OR is **monotonic**: once a bit is set, it stays set.
- We can track all possible ORs ending at each index.

### Strategy:

1. Use a set `cur` to store all distinct OR results of subarrays **ending at the current index**.
2. For each number in `arr`, update `cur` as:
   - `cur = {num | x for x in cur} | {num}`
   - This represents all previous ORs extended by the current number, plus a new subarray starting at current index.
3. Add all ORs in `cur` to the result set `res`.

---

## ðŸ’¡ Key Points

- **Time Complexity**:  
  - Worst-case O(nÂ²), but in practice far fewer unique ORs due to early bit saturation.
- **Space Complexity**: O(k), where k is number of unique OR values.

---

## ðŸ“„ Code

```python
class Solution:
    def subarrayBitwiseORs(self, arr):
        res = set()
        cur = set()
        for num in arr:
            cur = {num | x for x in cur} | {num}
            res |= cur
        return len(res)
```

---

## ðŸ“‚ Use Cases

This is useful in:
- Bitmask and bitwise logic problems.
- Subarray variation problems.
- Understanding bit propagation in sequences.

```python
# Test
sol = Solution()
print(sol.subarrayBitwiseORs([1, 2, 4]))  # Output: 6
```
