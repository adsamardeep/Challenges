# Movie Renting System

üìú **Problem Statement**  
Design a movie renting system that supports:
- Initializing with a list of entries `(shop, movie, price)`.
- `search(movie) -> List[int]`: return up to 5 shop ids that have the movie available (not currently rented), ordered by increasing price, and then by increasing shop id when prices tie.
- `rent(shop, movie) -> None`: mark a movie as rented from a shop.
- `drop(shop, movie) -> None`: mark a previously rented movie as available again.
- `report() -> List[List[int]]`: return up to 5 currently rented pairs `[shop, movie]` ordered by increasing rental price, then by shop id, then by movie id.

The provided implementation keeps simple in-memory structures to track availability, per-movie shop price lists, and rented pairs.

üîç **Example Input/Output**  
```
Initialization:
    n = 3
    entries = [
        [0, 1, 5],   # shop 0 has movie 1 for price 5
        [1, 1, 4],   # shop 1 has movie 1 for price 4
        [1, 2, 6],   # shop 1 has movie 2 for price 6
    ]
Operations:
    mrs = MovieRentingSystem(n, entries)
    mrs.search(1)      -> [1, 0]      # shop 1 price 4, shop 0 price 5
    mrs.rent(1, 1)
    mrs.search(1)      -> [0]         # shop 1 is rented, only shop 0 remains
    mrs.report()       -> [[1,1]]     # rented: (shop 1, movie 1) price 4
    mrs.drop(1,1)
    mrs.report()       -> []          # no rented movies
```

üß† **Approach (step-by-step / explanation of the given design)**  
1. `available`: map `(shop, movie) -> price` for O(1) price lookups and existence checks.  
2. `movie_shops`: map `movie -> list[(price, shop)]` sorted once on initialization. This list is used by `search(movie)` to iterate in ascending price order and collect up to 5 shops that are not currently rented. Note: this list is not updated on `rent`/`drop` ‚Äî `search` filters rented entries on the fly.  
3. `rented`: a `set` of `(shop, movie)` pairs currently rented. `rent` adds the pair, `drop` removes it.  
4. `search(movie)`: iterate the pre-sorted `movie_shops[movie]`, skip pairs present in `rented`, collect up to 5 shop ids.  
5. `report()`: iterate `rented`, look up each pair's price via `available`, collect `(price, shop, movie)` tuples, sort them, and return the top 5 as `[shop, movie]` pairs.

This design favors simplicity and correctness: `search` and `report` always respect the current `rented` set without modifying the precomputed lists (lazy filtering).

üíª **Code**  

    class MovieRentingSystem:

        def __init__(self, n: int, entries: List[List[int]]):
            # available maps (shop, movie) -> price
            self.available = {}
            # movie_shops maps movie -> list of (price, shop) (kept sorted)
            self.movie_shops = {}
            # rented is the set of (shop, movie) currently rented
            self.rented = set()

            for shop, movie, price in entries:
                self.available[(shop, movie)] = price
                if movie not in self.movie_shops:
                    self.movie_shops[movie] = []
                self.movie_shops[movie].append((price, shop))

            # Sort shops by (price, shop) for each movie
            for movie in self.movie_shops:
                self.movie_shops[movie].sort()

        def search(self, movie: int) -> List[int]:
            result = []
            for price, shop in self.movie_shops.get(movie, []):
                if (shop, movie) not in self.rented:
                    result.append(shop)
                if len(result) == 5:
                    break
            return result

        def rent(self, shop: int, movie: int) -> None:
            self.rented.add((shop, movie))

        def drop(self, shop: int, movie: int) -> None:
            self.rented.discard((shop, movie))

        def report(self) -> List[List[int]]:
            rented_list = []
            for shop, movie in self.rented:
                price = self.available[(shop, movie)]
                rented_list.append((price, shop, movie))

            rented_list.sort()
            return [[shop, movie] for price, shop, movie in rented_list[:5]]

‚è± **Complexity Analysis**  
- Let `E = len(entries)`, `R = |rented|`, and for a movie `m`, let `k_m = len(movie_shops[m])`.  
- **Initialization:** building `movie_shops` then sorting each list: `O(E log E)` overall (sums of sorts).  
- **search(movie):** iterates `movie_shops[movie]` until it collects 5 available shops or exhausts the list ‚Üí O(k_m) worst-case but practically stops early; checking membership in `rented` is O(1).  
- **rent / drop:** O(1) to add/remove from `rented` (set).  
- **report():** builds a list of size `R` then sorts it: O(R log R). Returning up to 5 results.  
- **Space:** O(E) to store `available` and `movie_shops`, O(R) for `rented`.

üß™ **Edge Cases & Notes**  
- `movie_shops` is **not** updated on `rent`/`drop`. This is correct because `search` filters rented pairs on the fly; however, if many items are frequently rented, `search` may scan many entries to find 5 available shops ‚Äî performance deggrades if many top entries are rented.  
- `report` sorts the entire `rented` set each time; when `R` is large and queries frequent, this can be costly.  
- Assumes `entries` do not contain duplicates for the same `(shop, movie)`. If duplicates appear, `available` will keep the last price and `movie_shops` may contain duplicate tuples ‚Äî consider deduplicating on initialization if needed.  
- All data structures assume moderate sizes; for large-scale usage or heavy query/update workloads consider optimized structures (see improvements).

üîß **Possible Improvements**
1. **Faster search** ‚Äî maintain a per-movie min-heap (priority queue) of `(price, shop)` and a separate set of rented flags; use lazy deletion to pop rented or outdated entries until you find an available shop. This avoids scanning many rented entries repeatedly.  
2. **Faster report** ‚Äî maintain a global min-heap (or balanced tree) of currently rented items keyed by `(price, shop, movie)` so `report()` can return top 5 in O(5 log N) time with lazy deletions on rating updates.  
3. **Consistent updates** ‚Äî if you need stricter performance guarantees, use `heapq` + lazy deletion or `sortedcontainers.SortedList` (third-party) to get O(log N) inserts/removals and O(log N + k) range/top-k queries.
