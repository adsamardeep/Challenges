# Fraction to Decimal String

📜 **Problem Statement**  
Convert a fraction given by `numerator` and `denominator` into its decimal string representation.  
- If the fractional part is repeating, enclose the repeating part in parentheses.  
- Handle negative numbers, zero numerator, and large integers correctly.

🔍 **Example Input/Output**  
```
**Input**
    numerator = 1
    denominator = 2
**Output**
    "0.5"

**Input**
    numerator = 2
    denominator = 1
**Output**
    "2"

**Input**
    numerator = 2
    denominator = 3
**Output**
    "0.(6)"

**Input**
    numerator = -50
    denominator = 8
**Output**
    "-6.25"

**Input**
    numerator = 1
    denominator = 333
**Output**
    "0.(003)"
```

🧠 **Approach (step-by-step)**  
1. Handle the trivial zero numerator case — return `"0"`.  
2. Determine the sign: if exactly one of `numerator` and `denominator` is negative, prepend `"-"`. Work with absolute values for the rest.  
3. Compute the integer (whole) part with integer division `dividend // divisor` and append it to the result. Compute the initial remainder `dividend % divisor`. If remainder is zero, return the integer part (with sign if any).  
4. Otherwise, append the decimal point `"."`.  
5. To generate the fractional digits and detect repeating cycles, repeatedly:
   - If the current `remainder` has been seen before, a repeating cycle is detected. Insert `"("` at the index recorded for that remainder and append `")"` at the end — then stop.
   - Otherwise, record the current `remainder` mapping to the current length (index) of the `fraction` list (this marks where the next produced digit will be placed). Multiply the remainder by 10, append the digit `remainder // divisor`, and update `remainder = remainder % divisor`.
6. Join and return the accumulated parts as a single string.

The key idea for repetition detection is mapping each remainder to the position in the output where digits produced from that remainder begin — when the same remainder appears again, the digits between the two occurrences repeat.

💻 **Code**  

    class Solution:
        def fractionToDecimal(self, numerator: int, denominator: int) -> str:
            if numerator == 0:
                return "0"

            fraction = []
            # Determine sign
            if (numerator < 0) ^ (denominator < 0):
                fraction.append("-")

            dividend = abs(numerator)
            divisor = abs(denominator)

            # Integer part
            fraction.append(str(dividend // divisor))
            remainder = dividend % divisor
            if remainder == 0:
                return "".join(fraction)

            # Fractional part
            fraction.append(".")
            # map remainder -> index in fraction list where digit for this remainder will be placed
            map_dict = {}
            while remainder != 0:
                if remainder in map_dict:
                    # Insert '(' at the recorded index and append ')' at the end
                    fraction.insert(map_dict[remainder], "(")
                    fraction.append(")")
                    break
                # Record the index for this remainder
                map_dict[remainder] = len(fraction)
                remainder *= 10
                fraction.append(str(remainder // divisor))
                remainder %= divisor

            return "".join(fraction)

⏱ **Complexity Analysis**  
- Let `d` be the number of distinct remainders encountered (bounded by `divisor`).  
- **Time:** Each loop iteration either produces a fractional digit or detects a repeat; the loop runs at most `O(divisor)` iterations, so time is **O(d)** — in practice this is linear in the length of the non-repeating + repeating decimal digits. Converting and joining parts is linear in output length.  
- **Space:** O(d) for the `map_dict` and for the fractional digits stored in the list.

🧪 **Edge Cases**  
- `numerator == 0` → return `"0"`.  
- Exact division (e.g., `4/2`) → no fractional part, return integer string.  
- Negative results → sign handled via XOR of signs.  
- Repeating decimals where the repetition starts immediately after the decimal point (e.g., `1/3 -> "0.(3)"`) or later in the fractional digits (e.g., `1/6 -> "0.1(6)"`).  
- Very large `numerator`/`denominator` values — Python `int` supports arbitrary precision; algorithm uses remainders so correctness holds.  
- Denominator of `1` or `-1` — returns integer (with sign).  
- Ensure `denominator != 0` (assumed valid input).  
