# Max Frequency After Limited Local Changes

ðŸ“œ **Problem Statement**  
Given an integer array `nums`, an integer `k`, and a budget `numOps` of allowed change-operations, you may change any element `x` into any value `y` provided `|x - y| â‰¤ k`. Each such change counts as one operation. Return the maximum possible frequency (count) of any single integer value after performing at most `numOps` operations.

ðŸ” **Example Input / Output**  
**Input**
    nums = [1,2,2,3,7], k = 1, numOps = 2

**Possible reasoning**
- For target value `2`, numbers within `[1,3]` are {1,2,2,3} (total 4). Frequency of `2` is 2, available others in range = 2. With `numOps=2` we can convert both (1 and 3) to 2 â†’ final freq = 4.

**Output**
    4

ðŸ§  **Approach (step-by-step)**  
1. This solution relies on counting occurrences of each integer value and using prefix sums to quickly query how many original numbers fall into any integer range `[i-k, i+k]`.  
2. Let `count[v]` be the number of elements equal to `v`. Build a prefix-sum array so `count_prefix[v]` = number of elements `â‰¤ v`.  
3. For each candidate target value `i` (we iterate over all possible integer values in a bounded range), compute:
   - `freq = count[i]` (how many already equal to `i`),
   - `total = number of elements within [i-k, i+k]` = `count_prefix[i+k] - count_prefix[i-k-1]` (with bounds checks),
   - We can convert up to `total - freq` other elements inside the allowable range to `i`, but limited by `numOps`. So the achievable frequency is `freq + min(numOps, total - freq)`.  
4. The answer is the maximum achievable frequency over all candidate values `i`.  
5. The implementation bounds the candidate `i` range to `[0 .. max(nums) + k + 1]` (so that `i+k` is safe) â€” this assumes input numbers are non-negative. If negatives are possible, shift values or use a different approach (sorting + sliding window) to avoid large memory.

ðŸ’» **Code**  

    from typing import List

    class Solution:
        def maxFrequency(self, nums: List[int], k: int, numOps: int) -> int:
            # Assumes nums contains non-negative integers.
            # Bound for counts: need up to max(nums) + k (plus a small safety margin)
            maxVal = max(nums) + k + 2
            count = [0] * maxVal

            # frequency histogram
            for v in nums:
                count[v] += 1

            # prefix sums: count_prefix[i] = number of elements <= i
            for i in range(1, maxVal):
                count[i] += count[i - 1]

            res = 0
            m = len(nums)
            for i in range(maxVal):
                left = max(0, i - k)
                right = min(maxVal - 1, i + k)
                total = count[right] - (count[left - 1] if left else 0)
                freq = count[i] - (count[i - 1] if i else 0)
                # we can convert up to (total - freq) other elements in range, limited by numOps
                res = max(res, freq + min(numOps, total - freq))

            return res

â± **Complexity Analysis**  
- Let `M = max(nums) + k`.  
- **Time:** O(M + n) â€” building histogram O(n), prefix sums O(M), scanning candidate targets O(M).  
- **Space:** O(M) for the count/prefix array.  
- This is efficient if `M` is reasonably small (e.g., values and `k` within practical bounds). If `M` is large (sparse or negative values), this memory/time can be prohibitive.

ðŸ§ª **Edge Cases & Notes**  
- **Negative numbers:** current implementation assumes `nums` are non-negative. If negatives can appear, you must shift all values by `-min(nums)` before using this histogram approach, or use a sorting + sliding-window method instead.  
- **Large value range:** If `max(nums) + k` is huge (e.g., up to 10â¹), this array-based method is infeasible â€” use sort + two-pointer sliding window over sorted `nums` and greedily compute how many elements fall within `k` of each candidate center (or use coordinate compression).  
- **numOps = 0:** reduces to the original frequency of any value (answer = max count).  
- **k = 0:** can only change a number to itself (no effect) â€” same as `numOps = 0`.  
- **All numbers same:** returns `len(nums)`.  

