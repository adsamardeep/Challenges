# Pacific Atlantic Water Flow üåä

üìú **Problem Statement**  
Given an `m x n` matrix `heights` where `heights[i][j]` represents the height of the terrain at coordinate `(i, j)`, find all grid coordinates from which water can flow to both the **Pacific Ocean** and the **Atlantic Ocean**.

Water can only flow from a cell to neighboring cells **(up, down, left, right)** that have **equal or lower height**.  
- The **Pacific Ocean** touches the **top** and **left** edges.  
- The **Atlantic Ocean** touches the **bottom** and **right** edges.  

Return a list of coordinates `[i, j]` that can reach both oceans.

üîç **Example Input/Output**  
**Input**
    heights = [
      [1,2,2,3,5],
      [3,2,3,4,4],
      [2,4,5,3,1],
      [6,7,1,4,5],
      [5,1,1,2,4]
    ]

**Output**
    [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

**Explanation**
Water from these cells can flow both to:
- Pacific (top/left border)
- Atlantic (bottom/right border)

üß† **Approach (step-by-step)**  
1. **Observation**: Instead of simulating water flow *from every cell to the ocean* (which is inefficient), reverse the flow:  
   - Simulate flow **from the ocean inward** ‚Äî find all cells reachable *from* each ocean under reversed flow condition:  
     ‚ÄúYou can move from a lower or equal height cell to a higher one.‚Äù  
2. Perform two DFS traversals:
   - One starting from all **Pacific-border** cells (top row & left column).
   - One starting from all **Atlantic-border** cells (bottom row & right column).  
3. Each DFS marks cells that can flow into that ocean (because water could flow *out* from those cells in the original direction).
4. The final answer is the intersection of the two visited sets ‚Äî cells that can reach both oceans.

üíª **Code**  

    from typing import List

    class Solution:
        def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
            if not heights or not heights[0]:
                return []

            m, n = len(heights), len(heights[0])
            directions = [(1,0), (-1,0), (0,1), (0,-1)]

            def dfs(i, j, visited):
                visited.add((i, j))
                for dx, dy in directions:
                    x, y = i + dx, j + dy
                    if 0 <= x < m and 0 <= y < n:
                        # can flow "uphill" or same height in reverse flow simulation
                        if (x, y) not in visited and heights[x][y] >= heights[i][j]:
                            dfs(x, y, visited)

            pacific, atlantic = set(), set()

            # Pacific Ocean (top row + left column)
            for j in range(n):
                dfs(0, j, pacific)
            for i in range(m):
                dfs(i, 0, pacific)

            # Atlantic Ocean (bottom row + right column)
            for j in range(n):
                dfs(m - 1, j, atlantic)
            for i in range(m):
                dfs(i, n - 1, atlantic)

            # Intersection of reachable cells
            return list(pacific & atlantic)

‚è± **Complexity Analysis**  
- Let `m = rows`, `n = cols`.  
- Each cell visited at most twice (once per ocean).  
- **Time Complexity:** O(m √ó n)  
- **Space Complexity:** O(m √ó n) for visited sets and recursion stack.

üß™ **Edge Cases**  
- Empty matrix ‚Üí return `[]`.  
- Single row/column ‚Üí all cells can flow to both oceans.  
- Flat grid (all heights equal) ‚Üí all cells flow to both oceans.  
- Strictly increasing or decreasing grid ‚Üí only border cells flow to both.  
- Large `m, n` (e.g., 200√ó200) ‚Üí recursion depth okay in Python; for larger grids, BFS or iterative DFS may be safer to avoid recursion limit.

üí° **Optimization Tip**  
You can replace recursive DFS with a BFS (using queues) to avoid stack overflows on deep grids. BFS offers the same logic and complexity but is more stable for large input sizes.
