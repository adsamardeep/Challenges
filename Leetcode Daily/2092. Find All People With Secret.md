# üè∑ Find all people who learn a secret through timed meetings

## üìú Problem Statement
Given `n` people labeled `0` to `n-1`, a list of `meetings` where each meeting is `[x, y, time]`, and an initial `firstPerson` who knows a secret along with person `0`, determine all people who will eventually know the secret. A person can share the secret only during meetings that occur after they know it, and knowledge does not persist across unrelated meetings at the same time.

## üîç Example Input/Output
**Input:**
```python
n = 6
meetings = [[1,2,5],[2,3,8],[1,5,10],[0,1,2],[3,4,8]]
firstPerson = 1
````

**Output:**

```python
[0, 1, 2, 3]
```

**Explanation:**

* Person `0` and `1` know the secret initially.
* At time `2`, `0` meets `1` (no change).
* At time `5`, `1` shares with `2`.
* At time `8`, `2` shares with `3`.
* Person `4` meets `3` at the same time but does not get the secret due to isolation reset logic.

## üß† Approach

1. Use a Union-Find (Disjoint Set Union) structure to track connected components of people.
2. Initially union person `0` and `firstPerson` since both know the secret.
3. Sort meetings by time so meetings at the same time are processed together.
4. For each group of meetings at the same timestamp:

   * Union all participants of those meetings.
   * Track all involved participants.
5. After processing that time group, disconnect (reset parent) any involved person who is not connected to person `0`, preventing secret leakage across unrelated time groups.
6. At the end, all people connected to person `0` are those who know the secret.

## üíª Code (copy-paste ready)

```python
class Solution:
    def findAllPeople(self, n, meetings, firstPerson):
        parent = list(range(n))

        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(a, b):
            parent[find(b)] = find(a)

        meetings.sort(key=lambda x: x[2])

        union(0, firstPerson)

        i = 0
        while i < len(meetings):
            time = meetings[i][2]
            involved = []

            while i < len(meetings) and meetings[i][2] == time:
                x, y, _ = meetings[i]
                union(x, y)
                involved.append(x)
                involved.append(y)
                i += 1

            root0 = find(0)
            for p in involved:
                if find(p) != root0:
                    parent[p] = p

        return [i for i in range(n) if find(i) == find(0)]
```

## ‚è± Complexity Analysis

* Time complexity: **O(m log m + m Œ±(n))**, where `m` is the number of meetings (sorting dominates; Union-Find operations are nearly constant).
* Space complexity: **O(n)** for the parent array.

## üß™ Edge Cases

* No meetings ‚Üí only persons `0` and `firstPerson` know the secret.
* `firstPerson = 0` ‚Üí secret starts with only one person.
* Multiple meetings at the same time ‚Üí handled together to avoid incorrect propagation.
* Disconnected meeting groups ‚Üí correctly isolated by resetting parents.
* All people connected through time-ordered meetings ‚Üí everyone learns the secret.

```
```
