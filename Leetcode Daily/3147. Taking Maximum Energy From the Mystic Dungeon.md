# Maximum Energy Collection (Jump-DP Approach)

📜 **Problem Statement**  
You are given an integer array `energy` where `energy[i]` represents the energy value at index `i`, and an integer `k`.  
Starting from any index `i`, you can repeatedly jump **forward by exactly `k` steps** (i.e., from index `i` to `i + k`, `i + 2k`, etc.) collecting the total energy sum along your path.  
Your task is to return the **maximum energy** you can collect starting from any valid index.

🔍 **Example Input/Output**  
**Input**
    energy = [5,2,-10,-5,1]
    k = 3

**Output**
    3

**Explanation**
- Starting from index 1 (energy = 2): you can jump to index 4 (energy = 1) → total = 2 + 1 = 3.  
- Starting from index 0: path → 0 → 3 → total = 5 + (-5) = 0.  
- Starting from others yields smaller totals.  
Hence, maximum = 3.

🧠 **Approach (step-by-step)**  
1. The problem is a simple **dynamic programming (DP)** task computed from the end of the array backward.  
2. Define `dp[i]` as the **maximum energy collectible starting at index `i`**.  
   - If `i + k < n`, you can jump to `i + k` and continue accumulating energy:  
     `dp[i] = energy[i] + dp[i + k]`
   - Otherwise, you can only take `energy[i]` (no further jumps possible).  
3. Iterate `i` from `n-1` down to `0` to fill `dp`.  
4. Keep track of the global maximum across all starting positions (`result = max(result, dp[i])`).

💻 **Code**  

    from typing import List

    class Solution:
        def maximumEnergy(self, energy: List[int], k: int) -> int:
            n = len(energy)
            dp = [0] * n
            result = float('-inf')
            for i in range(n - 1, -1, -1):
                dp[i] = energy[i] + (dp[i + k] if i + k < n else 0)
                result = max(result, dp[i])
            return result

⏱ **Complexity Analysis**  
- Let `n = len(energy)`.  
- **Time Complexity:** O(n) — single backward pass.  
- **Space Complexity:** O(n) for the `dp` array (can be optimized to O(1) if we reuse values modulo `k` since jumps are fixed step).  

🧪 **Edge Cases**  
- `n = 1` → only one element → result = `energy[0]`.  
- `k >= n` → no jumps possible → result = max(energy).  
- All negative values → best to pick the least negative number (the code handles this naturally).  
- `k = 1` → standard suffix-sum DP — maximum subarray starting at any point.  
- Very large arrays → algorithm still linear and efficient.

💡 **Optimization Insight:**  
Since jumps are exactly `k` apart, each `i` belongs to one of `k` independent sequences `(i, i+k, i+2k, …)`.  
Thus, you could compute the suffix sum separately for each of these `k` chains in-place, eliminating the need for a full `dp` array (O(1) extra space version).
